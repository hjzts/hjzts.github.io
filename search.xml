<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CO-P0-logisim相关</title>
    <url>/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>关于本次P0,提供我个人的一点拙见</p>
</blockquote>
<span id="more"></span>
<h2><span id="第一题">第一题</span></h2>
<p><strong>题目描述：</strong></p>
<p>给定五个8bit输入，输出一个8bit的在五个输入中没出现的最小正整数。</p>
<p>这里首先考虑到这里必然最大的输出也只是6（因为只有5个数），那么这思路就来了。利用一个6bit的中间量<code>hot</code>(有点独热码的那个意思，因为只会有一项为1，其余为0）来处理。</p>
<p>如果某一个数小于等于5，那就将这个<code>hot</code>的对应位置为1。然后将每个输入的<code>hot</code><strong>或</strong>起来，那么就得到了个6bit 2进制数，其中有1的位置代表存在该数（由于计数是从0开始，所以最终得到结果的时候需要加个1）</p>
<p><strong>电路图如图所示：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/1.png" alt></p>
<p>把这个作为一个子电路，对每一个input进行处理，再将得到的<code>hot</code><strong>或</strong>起来。</p>
<p>最后利用一个bit finder找最低位的0就可以了。这里因为引入的是6位，就能够解决输入为1 2 3 4 5的问题。如果使用5位就需要特判。</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/2.png" alt></p>
<h2><span id="第二题">第二题</span></h2>
<p><strong>题目描述：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/3.png" alt></p>
<p>输入为2bit方向信号，1bit clk，1bit reset(异步复位，直接接在寄存器reset端即可)。</p>
<p>类似课下的navigation的题目，这里题目要求使用mealy状态机。最开始位于1处，根据输入的2bit方向信息前往下一个位置，如果没有（或者撞墙）则停留在当前位置。输出为下一步的位置标号。</p>
<p>输出4bit位置信号</p>
<p>**状态转移图：**直接根据题目信息即可得到状态转移图。这里直接使用4bit二进制码或者3bit二进制码来表示状态即可。</p>
<p>**打真值表：**略</p>
<p>Mealy型状态机：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/4.png" alt></p>
<p>补充好status状态转移部分和output输出逻辑即可。</p>
<p><strong>需要注意的是：</strong></p>
<p>这里可以直接在寄存器前面接输出（如上图红线部分，当然这里是使用状态的编码从1开始而且为4bit的情况，其他状态也可以进行修改），在计组讨论区中也有讨论，其实也就是Mealy机的实现模式~~，具体可参见这篇<a href="https://www.hugohealthy.top">博客</a>~~（还没写）。</p>
<p><strong>还有一些打表的小细节：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/5.png" alt></p>
<blockquote>
<p>第三题</p>
</blockquote>
<p><strong>题目描述：</strong></p>
<p>输入：多个4bit二进制数作为一个16进制数</p>
<p>判断输入的序列中是否存在指定的序列，并得到对应输出。</p>
<table>
<thead>
<tr>
<th>输入序列</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>EEE</td>
<td>1</td>
</tr>
<tr>
<td>A0E</td>
<td>2</td>
</tr>
<tr>
<td>0A0</td>
<td>3</td>
</tr>
<tr>
<td>其他</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>输出：2bit output</p>
<p>题目要求使用<code>moore机</code>实现</p>
<p><strong>状态转移图：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/6.png" alt></p>
<p>**打真值表：**略</p>
<p><strong><code>moore机</code></strong>：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/7.png" alt></p>
<p>当然这里还有更加偷巧的办法，比如：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/8.png" alt></p>
<p>然后对每个state进行判断就睡简单的组合逻辑了(这里我并没有测试过，不知道具体实施能否行得通，欢迎批评指正)</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>MPI</title>
    <url>/2024/04/24/MPI/</url>
    <content><![CDATA[<h1><span id="mpi分布式内存编程技术">MPI分布式内存编程技术</span></h1>
<blockquote>
<p>Fortran 77 是什么呀~~</p>
</blockquote>
<ul>
<li>单个进程(process)
<ul>
<li>拥有独立的执行环境</li>
<li>独立地申请和占有内存空间</li>
</ul>
</li>
<li>单机内多个进程
<ul>
<li>多个进程可同时存在在单机内同一个操作系统</li>
<li>进程间相互独立，内存空间不相交</li>
<li>进程间可以相互交换信息</li>
</ul>
</li>
<li>包含于通过网络链接的不同处理器的多个进程
<ul>
<li>进程独立存在，需要通过一些接口函数来实现目前编程空间的需求</li>
<li>物理隔离，不能越过内存，访问需要通过“复印“的操作</li>
</ul>
</li>
</ul>
<h2><span id="mpi重要概念"><code>MPI</code>重要概念</span></h2>
<ul>
<li>进程序号(rank)的进程由进程组活通信器序号唯一确定
<ul>
<li>也就是每个进程自己的名字</li>
<li>同一个进程在不同的通信组或通信器之间可以有不同的序号</li>
</ul>
</li>
<li>消息(message)</li>
</ul>
<h2><span id="mpi原始数据类型"><code>MPI</code>原始数据类型</span></h2>
<table>
<thead>
<tr>
<th>MPI类型</th>
<th>C类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>MPI_CHAR</td>
<td>signed char</td>
</tr>
<tr>
<td>MPI_SHORT</td>
<td>signed short int</td>
</tr>
<tr>
<td>MPI_INT</td>
<td>signed int</td>
</tr>
<tr>
<td>MPI_LONG</td>
<td>signed long</td>
</tr>
<tr>
<td>MPI_UNSIGNED_CHAR</td>
<td>unsigned char</td>
</tr>
<tr>
<td>MPI_UNSIGNED_SHORT</td>
<td>unsigned short int</td>
</tr>
<tr>
<td>MPI_UNSIGNED</td>
<td>unsigned int</td>
</tr>
<tr>
<td>MPI_UNSIGNED_LONG</td>
<td>unsigned long int</td>
</tr>
<tr>
<td>MPI_FLOAT</td>
<td>float</td>
</tr>
<tr>
<td>MPI_DOUBLE</td>
<td>double</td>
</tr>
<tr>
<td>MPI_LONG_DOUBLE</td>
<td>long double</td>
</tr>
<tr>
<td>MPI_BYTE</td>
<td></td>
</tr>
<tr>
<td>MPI_PACKED</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>MPI——BYTE</code>(一个字节)</p>
<p><code>MPI_PACKED</code>(打包数据)</p>
</blockquote>
<h2><span id="mpi基本结构"><code>MPI</code>基本结构</span></h2>
<blockquote>
<p><code>MPI include file</code></p>
</blockquote>
<blockquote>
<p>变量定义</p>
</blockquote>
<blockquote>
<p><code>MPI</code> 环境初始化</p>
</blockquote>
<p><code>int MPI_Init(int *argc,char *argv[]);</code></p>
<p><code>int MPI_Init(NULL,NULL);</code></p>
<blockquote>
<p>执行程序</p>
<p>进程间通信</p>
</blockquote>
<blockquote>
<p>退出``MPI`环境</p>
</blockquote>
<p><code>int MPI_Finalize(void);</code></p>
<h2><span id="mpi基本函数"><code>MPI</code>基本函数</span></h2>
<p>开始</p>
<p>终止</p>
<p>获取墙钟时间</p>
<p><code>double MPI_Wtime(void)</code></p>
<h2><span id="sample-hello-world">Sample Hello World</span></h2>
<h2><span id="点对点通信">点对点通信</span></h2>
<ul>
<li>
<p>定义</p>
<ul>
<li>communicator(通信子，通信域) source destination 0</li>
</ul>
</li>
<li>
<p>阻塞式点对点通信</p>
<ul>
<li>
<pre><code class="language-c">int MPI_Send(void *buf,int count,MPI_Datatype,int dest,int tag ,MPI_Comm comm);
//count是指定数据类型的个数
//dest范围是0~np-1，或MPI_PROC_NULL
//tag范围是0~MPI_TAG_UB，用来区分消息
<pre class="line-numbers language-none"><code class="language-none">
- ```c
  int MPI_Recv(void *buf,int count,MPI_Datatype datatype,int source,int tag,MPI_Comm comm,MPI_Status *status);
  //count是接受缓冲区的大小，表示接受上界。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</code></pre>
</li>
<li></li>
</ul>
</li>
<li>
<p>编写安全的``MPI`程序</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>非阻塞式点对点通信</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MPI_Isend</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> MPI_Datatype datatype<span class="token punctuation">,</span> <span class="token keyword">int</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> tag<span class="token punctuation">,</span>MPI_Comm COmm，MPI_Request <span class="token operator">*</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
IN buf 发送缓冲区的起始地址
IN count 发送缓冲区的大小(发送元素个数)
IN datatype 发送缓冲区数据的数据类型
IN dest 月的进程的rank值
IN tag 消息标签
IN comm 通信空间/通信城
OUT request 非阳塞通信完成对象(句树)
MPI_Ibsend/MPI_Issend/MPI_Irsend:非阻塞缓冲模式/非阻赛同步模式/
*/</span>
<span class="token keyword">int</span> <span class="token function">MPI_Irecv</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> MPI_Datatype datatype<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">,</span> <span class="token keyword">int</span> tag<span class="token punctuation">,</span>MPI_Comm comm，MPI_Request<span class="token operator">*</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1><span id="并行计算优化技巧">并行计算优化技巧</span></h1>
<h2><span id="编译优化">编译优化</span></h2>
<p>IPCC比赛环境：CPU AMD EPYC 7452</p>
<p>-O3-fopenmp -march=znver1 -mfma -fomit-frame-pointer -mavx2 -mtune=znever**……**</p>
<h2><span id="cache-优化">Cache 优化</span></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//matrix multiplication</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//ikj这个组合是最快，多重循环套一起，可以尝试将循环次序进行交换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="simd">SIMD</span></h2>
<p>向量指令是一种并行计算技术，可以在一次指令中同时处理多个数据元素，从而提高计算效率。与传统的标量指令相比，向量指令能够耨将计算操作应用**……**</p>
<ul>
<li>使用条件</li>
<li>最内层循环</li>
<li>循环的长度是固定的</li>
<li>循环体内没有变量依赖关系。   不然就不好进行</li>
<li>循环访问的数据最好是连续的，或者最起码是相同的步长间隔</li>
<li>循环体内没有复杂的分支判断</li>
<li>循环内没有调用其他复杂的函数</li>
</ul>
<blockquote>
<p>查CPU手册</p>
</blockquote>
<ul>
<li>
<p>对齐</p>
</li>
<li>
<p>在C语言中可以使用aligned_alloc函数来申请对齐的内存。该函数的声明：</p>
</li>
<li>
<blockquote>
<p><strong>……</strong></p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>一个例子</strong></p>
<p>记得free</p>
</blockquote>
</li>
<li>
<p>边角料的处理   加一个非SIMD的处理</p>
</li>
<li>
<p>内部处理</p>
</li>
<li>
<p>外部处理</p>
</li>
</ul>
<blockquote>
<p>向量点乘</p>
</blockquote>
<ul>
<li>手动/自动向量化</li>
<li>#pragma ivdep</li>
<li>#pragma vector aligned</li>
<li>#pragma vector</li>
<li>** ……**</li>
</ul>
<h2><span id="预取">预取</span></h2>
<p>__builtin_prefetch函数</p>
<p><strong>……</strong></p>
<ul>
<li>执行缓存预取操作。可以将制定地址的数据预取到cache中</li>
</ul>
<h2><span id="openmp-task">Openmp task</span></h2>
<p>TASK定义一个可以被任何线程执行的独立的工作单元</p>
<ul>
<li>if：指定是否生成一个任务</li>
<li>final：制定是否将生成的任务和它的所有子任务都标记为final，即不可再分</li>
<li><strong>……</strong></li>
</ul>
<h2><span id="任务流">任务流</span></h2>
<p><a href="https://taskflow.github.io/">https://taskflow.github.io/</a></p>
<ul>
<li>一个例子</li>
</ul>
<p>打比赛用不上</p>
<p>工程好用，cpu和gpu都可用</p>
<p>C++不支持异步程序</p>
<p>Qt是C++界面库，需要手动wait</p>
<h2><span id="排序">排序</span></h2>
<ul>
<li>
<p>SortKey   排一个</p>
</li>
<li>
<p>SortPairs   排点对（结构体）</p>
</li>
<li>
<p>Std::sort</p>
</li>
<li>
<p>Omp task sort</p>
</li>
<li>
<p>__gnu_parallel::sort 网上的项目，开源库</p>
</li>
<li>
<p>parallel_radix_sort  开源的并行的基数排序</p>
</li>
</ul>
<h1><span id="ipcc-2022初赛">IPCC 2022初赛</span></h1>
<p>支撑点切比雪夫距离和——SumDistance</p>
<p>k = 2，3，的情况</p>
<blockquote>
<p>伪代码</p>
<p><strong>……</strong></p>
</blockquote>
<ul>
<li>j  &lt; i</li>
</ul>
<h1><span id="pac2019初赛">PAC2019初赛</span></h1>
<p>CFD 应用物理量梯度求解算法优化</p>
<p>PAC2019-初赛题</p>
<h4><span id="简介">简介</span></h4>
<p>计算流体力学程序中，粘性项离散的关键是计算物理量在界面处的梯度。求梯度的原理是高斯-格林公式：</p>
<p>$\oint_{V}\triangledown Q dV=\iint_{\partial V} Q \cdot\vec{n} dS$</p>
<p>即单元中心的梯度可以积分面心的值得到。</p>
<blockquote>
<p>核心是将几个循环进行合并，然后将代码修改为编译器更容易优化的形式，关键还是使用omp来优化，当然对于这种计算比较原子操作而且数量大的操作使用cuda肯定也挺好的，<code>lxc</code>试了一下确实是这样的</p>
</blockquote>
]]></content>
      <categories>
        <category>并行计算</category>
      </categories>
      <tags>
        <tag>mpi</tag>
      </tags>
  </entry>
  <entry>
    <title>OO-U1</title>
    <url>/2024/04/24/OO-U1/</url>
    <content><![CDATA[<h1><span id="oo第一单元-表达式化简总结">OO第一单元-表达式化简总结</span></h1>
<h2><span id="0-前言">0 前言</span></h2>
<h3><span id="作业简介">作业简介</span></h3>
<p>本次作业要求对表达式进行恒等变形，要求只保留必要的括号并使得表达式的长度尽量的短</p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323021402.png" alt></p>
<p>本次作业用到了递归下降法进行表达式解析和层次化程序设计的思想。</p>
<blockquote>
<p>首先说明自己用到的一些名词的特定含义</p>
<ul>
<li>表达式Expr：特指只经过解析后得到的式子</li>
<li>多项式Poly：指解析并去括号后得到的式子</li>
<li>单项式Mono：指构成多项式的基本单元，多项式为一个或多个单项式相加</li>
</ul>
</blockquote>
<p>下面对自己的架构和整体作业设计进行分享</p>
<h2><span id="1-架构设计体验心得">1 架构设计体验心得</span></h2>
<p>最终架构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323164353.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323182259.png" alt></p>
<p>本单元主要是为了进行层次化进行架构设计的学习和应用。</p>
<p>首先是整体的层次化处理方法，Lexer-Parser-Optimizer的结构，Lexer为Parser提供词法单元，Parser为Optimizer提供解析后的表达式Expr，Optimizer最后将结果字符串输出。</p>
<p>还有Parser内部的层次化结构，从parseExpr调用parseTerm，再在parseTerm中调用parseFactor，而parseFactor中又包含多种因子，其中还包括对parseExpr的递归调用。</p>
<p>从数据结构和功能结构的角度进行分析：</p>
<ul>
<li>
<p>数据结构层次</p>
<p>数据结构主要是解析得到的抽象语法树结构，设计了Expr表达式类作为解析得到的结果，Expr中存储多个Term，与Term形成聚合关系；Term中存储多个Factor，与Factor形成聚合关系</p>
</li>
<li>
<p>功能结构层次</p>
<p>功能层次主要是进行运算，进行括号化简，设计了Poly多项式进行运算，Poly中存储多个Mono，与Mono形成聚合关系。在进行调用Poly的multiplyPoly的方法时，调用multiplyMono方法，层次化清楚，每个方法的功能作用也更加明确。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323182447.png" alt></p>
<h3><span id="11-第一次作业">1.1 第一次作业</span></h3>
<p>本次作业要求完成简单的表达式化简问题，表达式中仅含有加、减、乘、乘方等基本操作，一方面是结合自己的踩坑经历，另一方面是考虑到递归下降法良好的可拓展性，我果断选择使用递归下降法作为表达式解析的主要方法。</p>
<p>以下是代码架构的主体部分：</p>
<ul>
<li>Processer将输入的表达式字符串进行化简处理后得到新的表达式字符串</li>
<li>Lexer得到当前词法单元，将词法单元传递给Parser进行解析</li>
<li>Parser 对表达式进行解析，得到expr</li>
<li>expr调用toPoly后，得到多项式poly</li>
<li>Optimizer对poly进行优化输出，得到结果的字符串</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323021635.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323021804.png" alt></p>
<p>语法分析：</p>
<p>首先我们看一下设定的形式化表述</p>
<blockquote>
<ul>
<li>表达式 →→ 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项</li>
<li>项 →→ [加减 空白项] 因子 | 项 空白项 ‘*’ 空白项 因子</li>
<li>因子 →→ 变量因子 | 常数因子 | 表达式因子</li>
<li>变量因子 →→ 幂函数</li>
<li>常数因子 →→ 带符号的整数</li>
<li>表达式因子 →→ ‘(’ 表达式 ‘)’ [空白项 指数]</li>
<li>幂函数 →→ ‘x’ [空白项 指数]</li>
</ul>
</blockquote>
<p>简单来看，我们可以大体上设计这么几个部分：</p>
<ul>
<li>
<p><code>Factor</code>:因子，包括变量因子（包括幂函数），常数因子，表达式因子</p>
</li>
<li>
<p><code>Term</code>:项，由乘法运算符连接的因子组成</p>
</li>
<li>
<p><code>Expr</code>:表达式，由<code>+-</code>连接的项组成</p>
</li>
<li>
<p><code>空白字符</code>：<code>space-ascii=32</code>,<code>tab-ascii=9</code></p>
</li>
</ul>
<p>可以简单分析得到<strong>空白字符可以直接去掉</strong>，一个是考虑到有效字符的部分不计算空白字符，同时不会产生什么影响，于是可以直接不处理空白字符。同时空白字符在词法单元时并不会在区分特定的词法之间起到任何的作用，不会影响运行的优先级以及每个词法单元的特定含义。</p>
<blockquote>
<p>这里举个不能去掉空白字符的例子，比如<code>shell</code>中<code>echo=1</code>与<code>echo = 1</code>的区别，前者是作为赋值符号，后者是作为参数传递，如果去掉空格，二者无法区分。</p>
</blockquote>
<h3><span id="processer"><code>Processer</code></span></h3>
<p>预处理器，对输入的字符串进行预处理，使得后面的递归下降法的使用更加便于进行。</p>
<p>预处理部分包括：</p>
<ul>
<li>去除所有空白字符</li>
<li>化简合并连续的<code>+-</code>符号</li>
<li>除去前导0，这个我也没有处理，直接使用<code>BigInteger</code>处理就行</li>
<li>同时可以化简<code>^+</code>为<code>^</code></li>
<li><code>(+)</code>为<code>()</code>，也就是除去括号后的正号，这个我并没有进行了</li>
</ul>
<p>这里讲一下我的预处理的方法，主要是第二个化简合并连续的<code>+-</code>符号，通过互测中的代码观察，$\frac78$的同学进行了除去空白字符，$\frac38$的同学合并了连续的<code>+-</code>号，合并的方法基本上都是遍历一遍字符串然后进行判断，这里我的方法是使用六次字符串的<code>replaceAll</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"--"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将连续的两个- 化为一个 +，那么之后在生成-前不会有连续的-号</span>
input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\+\\+"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 将连续的两个- 化为一个 +，那么之后在生成+前不会有连续的+号</span>
input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"-\\+"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// </span>
input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\+-"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将正负交替的 +- 化为一个 -</span>
input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"--"</span><span class="token punctuation">,</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 由于生成了- ，可能会有两个--连续的情况</span>
input <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\+\\+"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 即可处理完毕</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这么处理可能写起来方便的一点，但是时间上可能会是直接遍历的几倍(\流泪)</p>
<p>这里想分析一下<strong>为什么说会便于进行</strong>，我认为主要在于对设定的形式化表述可以进行优化。</p>
<p>在预处理完之后我们的形式化表述变为：</p>
<blockquote>
<ul>
<li>表达式 →→ 项 | 表达式 加 项</li>
<li>项 →→ [加减 ] 因子 | 项  ‘*’  因子</li>
<li>因子 →→ 变量因子 | 常数因子 | 表达式因子</li>
<li>变量因子 →→ 幂函数 x | x^b</li>
<li>常数因子 →→ 带符号的整数</li>
<li>表达式因子 →→ ‘(’ 表达式 ‘)’ [ 指数]</li>
<li>幂函数 →→ ‘x’ [ 指数]</li>
</ul>
</blockquote>
<p>采取向前靠的策略，可以发现现在已经变成了，表达式就是多个项相加（已经没有减这种情况了），项就是多个因子相乘，那么这时我们对于<code>Expr</code>表达式的构造就可以不需要记录符号了(这也就是我第一次的错误思路的来由)，具体来说，<code>Expr</code>里面只需要存<code>Term</code>就行，不需要存<code>BinOp</code>，因为每个运算都是加法。</p>
<p>这个时候我们可以想到的数据结构就可以是<code>HashSet</code>来实现了。</p>
<blockquote>
<p>在后续的作业中发现HashSet由于访问顺序的不确定，可能会出现一些奇怪的bug，因此后来采用的是ArrayList作为容器。至于HashSet的bug的具体原因，打算之后再进行具体研究分析。</p>
</blockquote>
<h3><span id="lexer"><code>Lexer</code></span></h3>
<p>词法分析器，功能是解析出表达式的每个token，那么分析词法单元的思路主要有两种，一个是只保存当前的<code>token</code>，另一个是先将所有<code>token</code>全部存放在一个容器中，然后每次去取即可。当时处理的时候考虑的是先一次性将所有token解析好，有更好的空间连续性，更加优雅<s>也没有具体分析，二者都可以</s></p>
<blockquote>
<p>idea1:根据前一个是什么，判断下一个的区间，得到当前token<code>curToken</code></p>
<p>idea2:直接先全部解析出来，放到一个数据结构里面，然后只需要get_next</p>
</blockquote>
<blockquote>
<p>简单分析一下：</p>
<p>在这里我们其实每次都只需要用到<code>curToken</code>就行，如果要全部存起来，使用的数据结构可以直接使用一个<code>ArrayList</code>即可。因此我便采用了这种处理。</p>
</blockquote>
<p>这里我们在使用<code>lexer</code>的时候主要包括<code>getCurToken</code>或者<code>getNextToken</code>，<a href="https://volcaxiao.top/2023/02/28/BUAA-OO-Expr-expansion-1-0/">xcgg</a>在博客也提到了要注意这个，但是具体怎么处理了。</p>
<p>我是这么处理的，我使用了两个方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Token</span> <span class="token function">curToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tokens<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    position<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我是先将所有的<code>Token</code>解析出来，然后再依次取每一个<code>curToken</code>，这么处理的一个理由是我想着这样先把字符串一次性处理或许会有更好的数据连续性，然后会有需要判<code>curToken</code>的类型的部分，每次判断成功后，调用<code>next</code>方法，这样就可以确保我的每一次判断都是在我进入了下一个层次后再修改的<code>position</code>。或许更容易理解一些~~</p>
<h3><span id="parser"><code>Parser</code></span></h3>
<p>解析器，采用递归下降法进行解析。</p>
<p>首先我们容易建立这三个层级的解析方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token keyword">int</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token keyword">int</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token keyword">int</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里加入了<code>signal</code>这个元素，是为了方便的将符号一步步进到底层进行处理</p>
<p>同时在解析式我并没有处理表达式的幂的运算，于是在<code>Expr</code>中添加了<code>exp</code>这个属性。</p>
<blockquote>
<p>于是这里就递归的将表达式解析好了，现在我们看<code>Expr</code>，他就是一个<code>Term</code>的<code>HashSet</code>，只需要处理好了这些<code>Term</code>那么这个<code>Expr</code>就处理好了～<code>Term</code>同理</p>
</blockquote>
<p>最关键的部分，同时也是相对比较难处理的一部分就是消括号，我在这里使用到了<code>Poly</code>和<code>Mono</code>两个类来处理。</p>
<p><code>Poly</code>是多项式类，<code>Mono</code>是单项式类，其实从功能上讲只有一个<code>Poly</code>就够了，新添一个<code>Mono</code>方便实现<code>Poly</code>的相加和相乘～</p>
<p>在<code>Expr</code>和<code>Term</code>中实现了<code>toPoly</code>的方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">toPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在<code>Factor</code>中实现了<code>toMono</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Mono</span> <span class="token function">toMono</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在转化是处理<code>Expr</code>的幂次实际上就是调用<code>Poly</code>的<code>pow</code>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Poly</span> <span class="token function">powPoly</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="optimizer"><code>Optimizer</code></span></h3>
<blockquote>
<p>优化，目前主要包括两个点</p>
</blockquote>
<ul>
<li>重写Mono的toString方法，化简每一个单项式，通过特判系数为0,1,-1的情况，以及x的指数为0,1的情况即可。</li>
<li>在Optimizer中得到Poly的字符串时，调整顺序，尽量使得正项在第一个。可以通过将每一个Mono的string存在一个ArrayList中，然后判断是否存在正项，然后将该项放在前面，其余项顺序输出即可。</li>
</ul>
<h3><span id="12-第二次作业">1.2 第二次作业</span></h3>
<p>在仔细分析下，第二次作业的两大难点是：</p>
<ol>
<li>自定义函数的处理</li>
<li>exp的化简与合并同类项</li>
</ol>
<p>对此的处理策略是：</p>
<ol>
<li>结合C语言中对于自定义函数的处理策略中的一个是进行值传递，我们将实参解析后直接进行字符串层级的替换，然后将最后得到的因子作为一个表达式因子进行解析。首先将自定义函数作为一个因子进行处理，将里面的每一个实参作为一个表达式进行解析，使用词法分析器，可以自然的处理对于逗号和括号的判断，得到表达式后转化为字符串，在函数中进行字符串层级的替换后，再次生成一个词法分析器和解析器得到一个表达式，作为表达式因子并完成解析</li>
</ol>
  <img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323172922.png" style="zoom: 33%;">
<ol start="2">
<li>为了合并同类项，需要判断指数函数的两个表达式是否是<strong>同类项</strong>，需要添加两个判断Poly相等的办法，我使用的是<strong>将两个Poly相减</strong>，如果得到的结果为空，那么两个表达式就是相等。而我们在第一次作业就已经实现了Poly的add和multiply方法，我们只需要增加一个toNegate取相反数的方法然后再次调用已有的add方法即可。这种策略符合我们的对拓展开放，对修改封闭的开闭原则。</li>
</ol>
<p>下面对两种处理策略进行详细论述。</p>
<p>首先是在definer中对于函数的实参和形参的转化采取如下的方法，这里主要是为了解决几个问题：</p>
<ul>
<li>x，y，z这几个形参在函数定义式中的顺序不固定，不便于传入实参后的实际处理</li>
<li>将函数形式更加规范化</li>
</ul>
<p>于是采取一下策略对函数进行预处理：</p>
<p><img src="https://gitee.com/hhhugo/imgs/raw/master/img/image-20240314103520812.png" alt="expr"></p>
<p>对于判断两个单项式Mono是否为同类项来进行合并同类项的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isSameKind</span><span class="token punctuation">(</span><span class="token class-name">Mono</span> mono1<span class="token punctuation">,</span> <span class="token class-name">Mono</span> mono2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mono1<span class="token punctuation">.</span><span class="token function">getExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>mono2<span class="token punctuation">.</span><span class="token function">getExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Poly</span> expPoly1 <span class="token operator">=</span> mono1<span class="token punctuation">.</span><span class="token function">getExpPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Poly</span> expPoly2 <span class="token operator">=</span> mono2<span class="token punctuation">.</span><span class="token function">getExpPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Poly</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Poly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> expPoly2<span class="token punctuation">.</span><span class="token function">toNegate</span><span class="token punctuation">(</span>expPoly2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">addPoly</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> expPoly1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里用到静态方法，提高了函数的调用效率。</p>
<h3><span id="13-第三次作业">1.3 第三次作业</span></h3>
<p>本次作业在我的架构下的实现相对比较简单。仅修改了约70行即完成任务。</p>
<p>首先是关于自定义函数的嵌套，根据1.2中关于我对自定义函数处理的论述可以看出，我对于自定义函数的处理<strong>可以自然的处理函数定义式的嵌套</strong>。</p>
<p>关于求导，我只做了两件事情。</p>
<ol>
<li>
<p>新添了继承于<code>Factor</code>的<code>Derive</code>导数类进行解析</p>
<ul>
<li>
<pre><code class="language-java">public class Derive implements Factor {
    private Expr expr;
    public Derive(Expr expr) {
        this.expr = expr;
    }
}
<pre class="line-numbers language-none"><code class="language-none">
     `Derive`中只需要有一个expr的属性即可

2. 给`Poly Mono`增加了一个求导的方法

   - `Poly`中只需要递归解析`Mono`即可

   - `Mono`中模拟即可
     $$
     \begin{align}
     &amp;b\ne 0 ;dx(a*x^b*exp(Poly))=a*b*x^{b-1}*exp(Poly)+a*x^b*exp(Poly)*dx(Poly)\\
     \\
     &amp;b =0;d(a*exp(Poly)) = a*exp(Poly)*dx(Poly)
     \end{align}
     $$

   然后递归调用poly的求导方法即可

那么就可以完成本次作业。

以下是本次作业之后的架构：


![](https://gitee.com/hhhugo/imgs/raw/master/img/20240315151459.png)

![](https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323170510.png)

## 2 基于度量的程序架构分析

### 2.1 代码量

![](https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323183656.png)

### 2.2 方法复杂度

&gt;  使用IDEA的MetrcisReloaded插件进行分析

- ev(G) 基本复杂度是用来衡量程序非结构化程度的，非结构成分降低了程序的质量，增加了代码的维护难度，使程序难于理解。因此，基本复杂度高意味着非结构化程度高，难以模块化和维护。实际上，消除了一个错误有时会引起其他的错误。

- iv(G) 模块设计复杂度是用来衡量模块判定结构，即模块和其他模块的调用关系。软件模块设计复杂度高意味模块耦合度高，这将导致模块难于隔离、维护和复用。模块设计复杂度是从模块流程图中移去那些不包含调用子模块的判定和循环结构后得出的圈复杂度，因此模块设计复杂度不能大于圈复杂度，通常是远小于圈复杂度。

- v(G) 是用来衡量一个模块判定结构的复杂程度，数量上表现为独立路径的条数，即合理的预防错误所需测试的最少路径条数，圈复杂度大说明程序代码可能质量低且难于测试和维护，经验表明，程序的可能错误和高的圈复杂度有着很大关系。

**项目复杂度/模块复杂度**

| project/module | v(G)avg | v(G)tot |
| -------------- | ------- | ------- |
| Expression     | 2.86    | 352     |

**包复杂度**

| package | v(G)avg | v(G)tot |
| ------- | ------- | ------- |
| .       | 3.71    | 104     |
| expr    | 1.86    | 82      |
| poly    | 3.40    | 163     |
| token   | 1.00    | 3       |

**类复杂度**

| class           | OCavg | OCmax | WMC  |
| --------------- | ----- | ----- | ---- |
| Definer         | 2.0   | 4.0   | 6.0  |
| expr.Derive     | 1.0   | 1.0   | 4.0  |
| expr.Expon      | 1.75  | 4.0   | 7.0  |
| expr.Expr       | 2.0   | 11.0  | 30.0 |
| expr.Func       | 1.4   | 3.0   | 7.0  |
| expr.Pow        | 2.125 | 10.0  | 17.0 |
| expr.Term       | 2.125 | 7.0   | 17.0 |
| Lexer           | 3.83  | 16.0  | 23.0 |
| Main            | 1.0   | 1.0   | 1.0  |
| Optimizer       | 6.33  | 9.0   | 19.0 |
| Parser          | 3.54  | 9.0   | 39.0 |
| poly.Mono       | 2.75  | 14.0  | 77.0 |
| poly.Poly       | 3.4   | 10.0  | 68.0 |
| Processer       | 1.5   | 2.0   | 6.0  |
| token.Token     | 1.0   | 1.0   | 3.0  |
| token.TokenType |       |       | 0.0  |

**方法复杂度**

| method                                 | CogC | ev(G)   | iv(G) | v(G) |
| -------------------------------------- | ---- | ------- | ----- | ---- |
| Processer.funcMap()                    | 1.0  | 1.0     | 2.0   | 2.0  |
|                                        |      |         |       |      |
| Definer.define()                       | 5.0  | 1.0     | 4.0   | 4.0  |
|                                        |      |         |       |      |
| Lexer.tokenize()                       | 22.0 | **5.0** | 15.0  | 18.0 |
| Lexer.curToken()                       | 1.0  | 2.0     | 1.0   | 2.0  |
|                                        |      |         |       |      |
| Parser.parseExpr(int)                  | 9.0  | 5.0     | 6.0   | 7.0  |
| Parser.parseTerm(int)                  | 9.0  | 3.0     | 7.0   | 7.0  |
| Parser.parseFactor(int, Term)          | 10.0 | 7.0     | 11.0  | 11.0 |
|                                        |      |         |       |      |
| expr.Expr.toString()                   | 30.0 | 10.0    | 10.0  | 11.0 |
| expr.Term.toString()                   | 7.0  | 2.0     | 4.0   | 4.0  |
| expr.Expon.toString()                  | 6.0  | 1.0     | 4.0   | 4.0  |
| expr.Pow.toString()                    | 16.0 | 10.0    | 8.0   | 10.0 |
| expr.Term.toPoly()                     | 10.0 | 1.0     | 7.0   | 7.0  |
| expr.Expr.toPoly()                     | 3.0  | 1.0     | 3.0   | 3.0  |
|                                        |      |         |       |      |
| poly.Mono.equals(Mono)                 | 4.0  | 5.0     | 4.0   | 5.0  |
| poly.Mono.isSameKind(Mono, Mono)       | 2.0  | 3.0     | 1.0   | 3.0  |
| poly.Mono.derive()                     | 2.0  | 2.0     | 2.0   | 2.0  |
| poly.Mono.processExpPoly(Poly, String) | 25.0 | 3.0     | 15.0  | 16.0 |
| poly.Mono.toString()                   | 30.0 | **8.0** | 17.0  | 18.0 |
| poly.Poly.addMono(Mono)                | 6.0  | 4.0     | 4.0   | 4.0  |
|                                        |      |         |       |      |
| poly.Poly.equals(Poly)                 | 17.0 | 7.0     | 8.0   | 9.0  |
| poly.Poly.addMono(Poly, Mono)          | 8.0  | 4.0     | 6.0   | 6.0  |
| poly.Poly.addPoly(Poly)                | 1.0  | 1.0     | 2.0   | 2.0  |
| poly.Poly.multiplyMono(Mono)           | 1.0  | 1.0     | 2.0   | 2.0  |
| poly.Poly.multiplyPoly(Poly)           | 3.0  | 1.0     | 3.0   | 3.0  |
| poly.Poly.powPoly(BigInteger)          | 2.0  | 2.0     | 3.0   | 3.0  |
| poly.Poly.derive()                     | 1.0  | 1.0     | 2.0   | 2.0  |
| poly.Poly.toString()                   | 21.0 | 5.0     | 8.0   | 11.0 |
|                                        |      |         |       |      |
| Optimizer.optimize()                   | 21.0 | 8.0     | 9.0   | 9.0  |
| Optimizer.toString()                   | 18.0 | 5.0     | 8.0   | 10.0 |

这里主要分析ev(G)指标，基本圈复杂度。下面对几个基本圈复杂度较高的方法提出解决办法：

- Lexer.tokenize()，ev(G)=5

  这里主要是采用了多个if分支判断是什么词法类型，这里可以对于除数字外的其他类型添加一个Char向Token的一个映射，然后直接取对应key的value即可

- Lexer.tokenize()，ev(G)=7

  这里同样也是用到了多个if分支判断是什么因子类型，同样可以建立TokenType向方法的一个映射

- poly.Mono.toString()，ev(G)=8

  这里方法复杂度高的一个重要原因是在其中调用了提取公因式的方法，加上本身的多个对于系数和指数的判断，方法复杂度较高，对此可以采取将toString方法中的几个处理提取方法出来，将功能进行进一步的划分。

这一些方法的复杂度较高，容易导致出现：

1. 使用大量if分支判断，包括可能用到instanceof，不符合开闭原则，没有好的拓展性
2. 容易导致bug难找

## 3 个人bug分析与踩坑经历

### 3.1 个人架构调整

在最开始，我希望通过自己独立的思考来解决表达式解析的过程，于是考虑到不同因子之间可能使用加号或者减号连接起来，如果使用一个ArrayList来将这些因子之间的符号连接起来就很麻烦，于是我想到可以建立一棵表达式树，用运算符作为中间结点讲不同的因子连接起来。也就是下面这种结构

![](https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323191539.png)

&gt; 首先分析自己一下之前的架构的不好的地方，或者说应该是麻烦的地方，有很多地方我没有处理好导致问题不断复杂化

这里两种架构我认为一个重要的区别就是

- 第一种使用表达式树的方法是没有对最外层的`+-`号进行进一步处理，放到下一层去处理，于是需要像个办法把符号存下来，于是自然的想到了树的结构
- 第二种架构实际上是直接将`Expr`看成多个`Term`相加，`Term`里面带有正负号

其实单纯只是说解析时使用表达式树的方法也不是不行，也就是数据结构是能够将我所需要的这个层次结构表达出来，但是麻烦的点在于实现功能结构

&gt; 功能结构包括展开与合并

运算部分我认为最难处理的在于求一个表达式的幂。

在一个树与树的相乘中，需要判断每一个节点的`ExprNodeType`，进行计算时，首先需要`clone`深拷贝一个`result`出来，然后进行相乘时需要递归的处理。

- 由于是树的结构，会得到一个非常巨大的树，更容易爆内存，而且需要合适的内存回收
- 递归是还需要考虑中间的`BinOpNode`是加号还是减号

复杂度++

&gt; 但是总归是可以实现的，只是我确实没能够在这五六天里面完成出来（哭！），多给我几个月肯定可以完成！(bushi)

### 3.2 bug分析

#### 第一次作业

我在第一次作业的过程中本来没有合并同类项，导致我再进行表达式之间的相加和相乘时容易导致内存爆炸。

关于这个炸内存的原因其实还可以仔细分析一下，我在`Expr`和`Term`中来存取`Term`和`Factor`的数据结构都是用到的`HashSet`，我们来看看`HashSet`的扩容机制。

通过查看`HashSet.add()`方法，发现直接调用的是`HashMap.put()`方法

```java
newCap = DEFAULT_INITIAL_CAPACITY;		// 16
newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); 		// 0.75 * 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</code></pre>
</li>
</ul>
</li>
</ol>
<p>这里是初始化长度，也就是new一个HashSet开始使用时会先拓展一个含有16个元素的空间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">// 1 &lt;&lt; 30</span>
    threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span>
         oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>
    newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现扩容时，会判断如果原容量超过了设定的最大值，那么就不会再进行扩容，也就是说理论上（空间足够大），HashSet的容量也只是<code>1&lt;&lt;30</code>个；而没有超过时，是进行翻倍增长。</p>
<p>也就是可能在扩容时会有大量的空间请求，在这个时候是最有可能爆空间的！</p>
<h4><span id="第二次作业">第二次作业</span></h4>
<p>这次作业主要是自己对于Poly的powPoly的实现过程中想要实现快速幂的计算，其中需要出现result.multiplyPoly(result)这种形式，但是我再multiplyPoly的实现里面是认为this和newPoly不一样，也就是本身和需要相乘的数不一样的，但是当相同时，我的处理就会导致在遍历Poly的monos(单项式的HashSet)的时候，会改变自身的值，导致最后的结果不正确。</p>
<p>后来的解决措施就是直接放弃使用快速幂，直接一个个相乘。</p>
<p>同时发现二者速度相差不大，分析认为复杂度主要在于多个多项式相乘时项数过多时候的判断是否为同类项这里消耗了比较多的时间。</p>
<p><strong>优化需谨慎！</strong></p>
<p>在这次作业优化的时候会错误的将<code>exp((-x^2))</code>变为<code>exp(-x^2)</code>这种形式，这要是对于是否去掉括号的判断不够合理。</p>
<p>修改策略为使用正则表达式进行更进一步的判断：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> numRegex <span class="token operator">=</span> <span class="token string">"[-]?\\d+$"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> powRegex <span class="token operator">=</span> <span class="token string">"x(\\^\\d+)?$"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> expRegex <span class="token operator">=</span> <span class="token string">"^exp\\(.*\\)$"</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>expPolyString<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>numRegex<span class="token punctuation">)</span>
    <span class="token operator">||</span> expPolyString<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>powRegex<span class="token punctuation">)</span>
    <span class="token operator">||</span> <span class="token punctuation">(</span>expPolyString<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>expRegex<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> expPoly<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4><span id="第三次作业">第三次作业</span></h4>
<blockquote>
<p>我这多灾多难的表达式化简哇</p>
</blockquote>
<p>这里时因为我在Expr中存取Term，在Term中存取Factor，在Poly中存取Mono时都是使用到的HashSet，但是由于HashSet访问顺序不固定的原因，导致在不同平台的运行结果不一样，而且有一些特殊的情况出现了问题。</p>
<ul>
<li>
<p>解决措施：</p>
<p>将HashSet修改为ArrayList即可</p>
</li>
</ul>
<h2><span id="4-发现别人bug所采用的策略">4 发现别人bug所采用的策略</span></h2>
<ol>
<li>
<p>最常用的方法还是使用评测机来疯狂评测，发现bug后对评测数据进行层层化简，定位到具体的问题所在的地方</p>
<blockquote>
<p>当然这也是我们自己debug的一个重要方法</p>
</blockquote>
</li>
<li>
<p>通过构造一些极端的数据</p>
<p>比如说魔鬼的<code>exp(exp(exp(exp(exp(x)^8)^8)^8)^8)^8</code>这种</p>
<p>还有包括输入一个0是否正确处理，同时还有之后的自定义函数嵌套时，手动构造一些能够满足复杂度，同时会报TLE错误的数据，如</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">3</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span>
<span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span>
<span class="token function">h</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">8</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token function">h</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>最有用的手段应该还是自己跑几组覆盖率较高的数据，对代码逐行用debug模式进行阅读，判断哪里的处理是不完善的。</p>
<p>同时这种手段还可以学习到对方的代码的架构和处理细节上的好的地方</p>
</li>
</ol>
<h2><span id="5-分析自己的优化">5 分析自己的优化</span></h2>
<ol>
<li>
<p>对于<code>a*x^b*exp()</code>中的a和b进行特判</p>
</li>
<li>
<p>对于<code>exp()</code>括号内能否去掉一层括号进行分析，使用正则表达式进行匹配(上文已经提到)</p>
</li>
<li>
<p>对于Mono的输出顺序进行调整，尽量保证正项在最前面，比如<code>-x+1</code>是比<code>1-x</code>要多一个字符的</p>
</li>
<li>
<p>提取公因式处理</p>
<p>在<code>exp((2*x+2*x^2+2*x^3))</code>中提取最大公因式出来得到<code>exp((x+x^2+x^3))^2</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">processExpPoly</span><span class="token punctuation">(</span><span class="token class-name">Poly</span> expPoly<span class="token punctuation">,</span> <span class="token class-name">String</span> expPolyString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BigInteger</span> <span class="token function">getGcd</span><span class="token punctuation">(</span><span class="token class-name">String</span> polyString<span class="token punctuation">,</span>
                                <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pair</span><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> monoStringList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span> <span class="token function">getBigInteger</span><span class="token punctuation">(</span><span class="token class-name">String</span> polyString<span class="token punctuation">,</span> <span class="token keyword">int</span> oleIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">extractGcd</span><span class="token punctuation">(</span><span class="token class-name">String</span> expPolyString<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将处理细节提取函数出来，可以有效简化处理，同时将各部分功能分得更加清晰，同时提高可拓展性，比如<code>extracGcd</code>中，可以不止提取最大公因式，还可以将最大公因式的其他因子进行提出。</p>
</li>
</ol>
<h2><span id="6-心得体会">6 心得体会</span></h2>
<p>首先是学习到了很多关于git的使用技巧，收益匪浅。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240323021905.png" alt></p>
<p>具体使用上：</p>
<ul>
<li>在master分支上是主要部分的commit</li>
<li>在dev上可以commit很多零散的，阶段性完成后，在master段进行merge</li>
<li>当dev分支有问题时，在debug分支进行处理，解决后merge到dev分支</li>
<li>在debug时可以在print分支添加一些print的方法，然后debug修改了需要看结果是否符合是，merge到print分支即可</li>
</ul>
<p>第一次写这么大一个项目，让我在知识层面上学到了很多关于层次化程序设计和递归下降法。学到更多的是自己对于架构的设计以及自己面对一个大工程是debug的一些方法。</p>
<p>同时，我也意识到自己的思考还是非常重要的，自己思考的架构能够有更加清楚的理解，也会有更多的收获！！</p>
<p>整体体验非常好，同时也意识到了自己的部分能力的不足，以后会进一步提升的！！</p>
<h2><span id="7-未来方向">7 未来方向</span></h2>
<p>第一单元整体质量很高！nrjj和lqgg yyds!，让人感受到OO很大的快乐哈哈哈，提升了个人的代码能力。</p>
<p>以下是几点简单的建议</p>
<ol>
<li>可以在博客周将一些架构很好的代码进行分享</li>
<li>第三单元感觉难度骤降有点明显，可以稍微提高一点</li>
<li>感觉还是不太会写评测机，希望可以多多教教</li>
</ol>
<h2><span id="8-reference">8 reference</span></h2>
<p>首先关于如何找到这些优秀的博客，相信大家通过<code>co</code>的学习已经积累了几位优秀的<code>博主</code>(暂且这么称呼罢)，这几位学长的<code>oo</code>博客也非常的好。同时，通过在博客的主页中的<code>友链</code>中可以去发现一些其他友链，这大体上可以把这个往届六系成员组成的图的一个最大的生成子图(<s>离散乱入</s>)</p>
<p><a href="https://volcaxiao.top/2023/02/28/BUAA-OO-Expr-expansion-1-0/">https://volcaxiao.top/2023/02/28/BUAA-OO-Expr-expansion-1-0/</a></p>
<ul>
<li>虽然这个网址不安全，但是也只有这个不安全啊！精品！</li>
<li>学长比较喜欢画<code>uml</code>类图，可以仔细查看类图基本上可以知道整体的架构</li>
</ul>
<p><a href="https://hyggge.github.io/2022/03/24/oo/oo-di-yi-dan-yuan-zong-jie/">https://hyggge.github.io/2022/03/24/oo/oo-di-yi-dan-yuan-zong-jie/</a></p>
<ul>
<li>内容非常简洁，可以直接看出实现</li>
<li>同时对于一些大家可能都会遇到的细节处理上的难题也会提到，即使架构与学长不相同也可以参考阅读</li>
</ul>
<p><a href="https://thysrael.github.io/posts/8da51baf/">https://thysrael.github.io/posts/8da51baf/</a></p>
<ul>
<li><s>按照六系的某些奇奇怪怪的祖辈关系，这位学长都得算我的祖宗辈了</s></li>
<li>文字非常详细的分析的自己的架构以及思路来源</li>
<li>而且能够看出来学长在写之前是没有参考太多的资料的，所以大部分都是学长自己的思考，根据和理由也非常充分</li>
</ul>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>OO 第一单元</tag>
      </tags>
  </entry>
  <entry>
    <title>OO-U2</title>
    <url>/2024/04/24/OO-U2/</url>
    <content><![CDATA[<h1><span id="oo第二单元电梯调度">OO第二单元电梯调度</span></h1>
<h2><span id="0-前言">0 前言</span></h2>
<p>最近读到张嘉佳的《云边有个小卖部》，让我感到一种灵魂的无比契合。在这本书里看到了自己在电梯单元经历的巨大的失败，希望总是会在突如其来的强测和互测中逐渐暗淡。</p>
<h3><span id="作业简介">作业简介</span></h3>
<p>本次作业的目标是模拟<strong>多线程实时电梯系统</strong>，熟悉线程的创建、运行等基本操作，熟悉多线程程序的设计方法。同时对于电梯调度的运行时间和响应时间以及运行时的电量做了要求。</p>
<p>在这个快节奏的时代，多线程似乎已经成为了我们生活的常态。我们在同一时间处理多项任务，试图在复杂的信息洪流中寻找自己的节奏。正如面向对象设计与构造课程的第二单元所展示的那样，多线程编程不仅是一种技术挑战，更是一种思维方式的转变。</p>
<p>电梯，这个看似简单的日常工具，却成为了我们探索并发世界的舞台。在这个单元中，我们不仅仅是编写代码，我们是在设计一个个微型的社会系统，每个线程都是其中的一个成员，它们需要协同工作，却又独立运行，随时准备响应各种未知的请求。</p>
<p>我曾以为，电梯月将是一场激烈的头脑风暴，是一场与bug的殊死较量。然而，当真正身处其中，我却发现，这更像是是一场内心的修行。在每一次的锁与等待中，我学会了耐心；在每一次的死锁与轮询中，我学会了冷静。我开始理解，编程不仅仅是为了解决问题，更是为了在这个过程中，学会与问题共存，甚至是欣赏问题本身。</p>
<p>虽然我不再像U1时那样充满斗志，但这并不意味着我在退步。相反，我正在学习如何在复杂中寻找简单，在不确定中寻找确定。我正在学习如何在不完美的世界中，寻找属于自己的最优解。</p>
<p>电梯月过去了，留给我的是对多线程编程的深刻理解，以及对未来更多挑战的期待。我将继续在这个充满变数和可能性的领域探索，不断优化我的设计，提升我的技能。因为我知道，无论电梯如何上升下降，我的编程之旅，永远在路上。</p>
<p>本次作业主要是多线程设计以及其中生产者消费者模式的使用， 本次作业难度不低，一般来说完成一个项目的难度主要来自于架构设计和debug的难度，架构设计上对于共享对象的选择和设计是难点之一，不合理的共享对象设置会让后绪的代码更难写下去。debug的难度在于多线程的难以复现性。</p>
<h2><span id="1-架构设计体验心得">1 架构设计体验心得</span></h2>
<p>最终架构如下：</p>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420165947.png" style="zoom: 50%;">
<p>这里是代码的主要的几个共享对象。</p>
<ul>
<li>
<p><code>RequestCounter</code>：主要是为了解决可能出现的无法正确结束的问题。</p>
<p>如果还是使用最开始的架构，比如当前输入已经结束，<code>waitTable</code>已经被设置为end，但是电梯有一个reset请求，需要将电梯中的人全部放出去。那么我这里的处理是将所有请求再次放到<code>waitTable</code>中，那么由于<code>Dispatcher</code>在得到<code>waitTable</code>的endFlag后，会给每个<code>dispatchTable</code>设置为<code>end</code>后然后结束<code>run()</code>，那么reset出来的那些请求就无法得到正确处理。</p>
<p>于是这里可以添加一个<code>RequesetCounter</code>来计算当前未完成的请求数，当请求数为0而且<code>waitTable</code>已经end时，<code>Dispatcher</code>就可以结束<code>run()</code>。</p>
</li>
<li>
<p><code>RequestTable</code>:这个是请求的容器。其中包括两个小的List，分别是<code>PersonRequestTable</code>和<code>ResetRequestTable</code>。<code>PersonRequestTable</code>是用来存放<code>PersonRequest</code>的，<code>ResetRequestTable</code>是用来存放<code>ResetRequest</code>的。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420170052.png" style="zoom: 33%;">
<p>这里主要是两个策略类：</p>
<ul>
<li>一个是电梯分派策略。这里使用的调参策略</li>
<li>一个是电梯运行策略。这里使用的是Look策略。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420170135.png" style="zoom:50%;">
<p>这里是几个主要的进程：</p>
<ul>
<li>输入进程</li>
<li>调度器进程</li>
<li>电梯进程</li>
</ul>
<p>这三个进程形成了两个生产者和消费者模式，其中的<code>Dispathcer</code>是一个中间商。</p>
<ul>
<li>
<p>整体上是两个生产者消费者模式：</p>
<p>一个是<code>InputHandler</code>作为生产者，<code>Dispatcher</code>作为消费者。其共享容器为<code>waitTable</code>。</p>
<p>另一个是<code>Dispatcher</code>作为生产者，<code>Elevator</code>作为消费者。其共享容器为<code>dispatchTable</code>。</p>
</li>
<li>
<p>同时这两种生产者消费者模式也构成一种层次化结构。</p>
</li>
<li>
<p>从代码架构的角度，我这里用到了<code>DispatchStrategy</code>和<code>RunStrategy</code>两个接口。分别用于实现电梯分派策略和电梯运行策略。</p>
<p>这里的分派策略在尝试过程中用到了random策略，调参策略，random+调参的策略。最终用到的是调参策略。</p>
<p>电梯运行策略用到的直接就是使用Look策略。Look策略在实际运行中表现良好，能够有效的减少电梯的运行时间。同时在工程中也有很高的使用率，可见Look策略在的实现的简单性和效果性达到了一个很好的平衡，是一个很好的选择。</p>
</li>
</ul>
<h3><span id="11-第一次作业架构">1.1 第一次作业架构</span></h3>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420173753.png" alt></p>
<p>第一次作业不需要进行电梯调度，已经指定了是哪个电梯，因此只需要对于电梯的运行进行处理。这里还是直接使用的简单的Look策略，没有使用过多的优化。</p>
<h3><span id="12-第二次作业架构">1.2 第二次作业架构</span></h3>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420174011.png" alt></p>
<p>这一次作业架构应该是最复杂的一次，我尝试实现了使用影子电梯电梯调度策略和random策略，分别作为两个类来实现了<code>DispatchStrategy</code>接口，然而影子电梯策略由于实现的问题，出现了一些难以解决的bug，于是放弃了（x</p>
<p>同时这里尝试实现了量子电梯，我发现在我的实现中，量子电梯没有什么优化，为了简洁性（主要是因为有其他bug，没有将处理中心放在这里，最终还是没有使用这个量子电梯。</p>
<h2><span id="2-同步块和锁">2 同步块和锁</span></h2>
<p>对于共享对象，我们可以通过设置同步块来是的这个共享对象是一个线程安全的类。比如我的两个共享对象<code>RequestCounter</code>和<code>RequestTable</code>。</p>
<p>以下是两个简单的代码示例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PersonRequest</span><span class="token punctuation">&gt;</span></span> personRequestTable<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResetRequest</span><span class="token punctuation">&gt;</span></span> resetRequestTable<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">RequestTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        personRequestTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        resetRequestTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addPersonRequest</span><span class="token punctuation">(</span><span class="token class-name">PersonRequest</span> personRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        personRequestTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>personRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addResetRequest</span><span class="token punctuation">(</span><span class="token class-name">ResetRequest</span> resetRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        resetRequestTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>resetRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">PersonRequest</span> <span class="token function">getPersonRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> personRequestTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">ResetRequest</span> <span class="token function">getResetRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> resetRequestTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样基本上可以确保一个线程安全。但是还是并不是说所有的共享对象就是无脑加锁就可以w完全确保线程安全的。还需要分析这几个方法的逻辑，是否会出行啊死锁的情况，同时也要分析这个共享对象的使用情况，是否会出现并发问题。</p>
<p>当然考虑实现的优雅性，我们可以使用<code>ReentrantLock</code>来实现锁。</p>
<p>以下是一个简单的代码示例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然也可以选择设置读写锁来提高效率。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> readLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> writeLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时在这里还可以使用<code>Condition</code>来实现更加复杂的同步。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上这些锁的实现在实际测试发现效率其实差不多，（无脑<code>synchronized</code>哈哈哈）</p>
<p>另一方面，除了对于共享对象的同步中可以使用锁来确保外界的访问是线程安全的，在对两个线程进行通信的时候可以手动设置一个<code>Lock</code>类来确保线程的通信是线程安全的。比如在实现双轿厢电梯时就可以使用这么一个锁。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> lock<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        lock <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">isLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> lock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="3-线程与对象设计">3 线程与对象设计</span></h2>
<h3><span id="31-线程协同性">3.1 线程协同性</span></h3>
<blockquote>
<p>今天听戚发韧院士的讲座，讲到了一起协同努力，推动中国航天进步！！！</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420173311.png" style="zoom:50%;">
<p>首先是主线程启动其余几个线程，这里是<code>InputHandler</code>和<code>Dispatcher</code> 以及<code>Elevator</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420182750.png" style="zoom: 50%;">
<p>在<code>InputHandler</code>中，主要是读取输入，然后将输入放到<code>waitTable</code>中。同时会在最后将<code>waitTable</code>设置为<code>end</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420173336.png" style="zoom:50%;">
<p>在调度器<code>Dispatcher</code>中，主要是从<code>waitTable</code>中取出请求，然后根据策略分派给电梯。同时会在最后将<code>dispatchTable</code>设置为<code>end</code>。如果<code>waitTable</code>为空那么就等待，如果<code>waitTable</code>已经end了，而且<code>requestCounter</code>也end，那么才设置为结束<code>run()</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240420182616.png" style="zoom:50%;">
<p>在电梯<code>Elevator</code>中，主要是从<code>dispatchTable</code>中取出请求，然后根据策略运行电梯。这里用到的是Look策略，这里用到一个<code>RunStrategy</code>类，每次从<code>RunStrategy</code>得到一个<code>Advice</code>，电梯根据<code>Advice</code>进行相应的操作。</p>
<h3><span id="32-代码稳定性与易变形分析">3.2 代码稳定性与易变形分析</span></h3>
<p>在三次作业中，主要变化的内容其实都在<code>Elevator</code>类中，电梯每次增加一种行为，电梯里面就要去实现这种操作。同时也需要添加更多的属性来完成这些请求。比如最开始我们设置<code>minFloor</code>和<code>maxFloor</code>，因为这个是固定的，但是由于双轿厢电梯的出现使得我需要对这个进行调整，同时Look策略中也需要进行调整。</p>
<p>还有一个就是共享对象需要不断调整，比如在第三次作业中，我增加了<code>RequestCounter</code>来解决可能出现的无法正确结束的问题。同时还有<code>RequestTable</code>中需要添加不同的请求来进行处理。虽然可以使用更加合适的继承来处理，但是我总认为在外层使用<code>instanceof</code>来判断是不是这个类型是一种不太好的设计，所以我尽量避免使用这个方法，而是使用了两个<code>List</code>来存放不同的请求。当然也可以自己将<code>request</code>中的内容实现一下，使得更加符合自己的需求。</p>
<p>同时这里巧妙的实现接口，使得可以方便尝试不同的调度策略和运行策略。这也是之后代码主要可以修改和优化的地方。但是苦于自己时间优先，在优先尝试相对简单的策略后，其他策略并没有进行尝试了。或者有一些尝试了但是半途而废了。</p>
<h3><span id="33-处理双轿厢电梯">3.3 处理双轿厢电梯</span></h3>
<p>我直接一开始就是实现12个电梯，然后只需要在调度时设置如果一个电梯不是双轿厢而且$id \ge 7$那么就不会分配给这个电梯。这样解决了双轿厢电梯调度的问题。</p>
<p>对于具体运行时，通过设置<code>maxFloor</code>和<code>minFloor</code>可以解决运行的问题。</p>
<p>但是对于双轿厢电梯碰撞的问题，我们可以增加一个Lock的共享对象，通过这个共享对象的状态设置来告诉对方该电梯是否在换乘层,进行相应的<code>wait</code>操作。同时，对于每个电梯，在换乘层完成开门操作后，马上移动到换乘层旁边的一层，避免出现某一个电梯一直占据着换乘层，而另一个电梯一直在<code>wait</code>的情况。</p>
<h2><span id="4-bug分析">4 bug分析</span></h2>
<blockquote>
<p>bug这东西分析分析就行了，de不出来的<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</blockquote>
<h3><span id="41-print大法">4.1 print大法</span></h3>
<p>首先是打印中间变量的方法：</p>
<p>我写了一个<code>Print</code>的类，专门用来打印中间变量。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>oocourse<span class="token punctuation">.</span>elevator3<span class="token punctuation">.</span></span><span class="token class-name">PersonRequest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>oocourse<span class="token punctuation">.</span>elevator3<span class="token punctuation">.</span></span><span class="token class-name">TimableOutput</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Print</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token constant">DEBUG</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printElse</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">DEBUG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAns</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">DEBUG</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>obj2 <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> obj2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj2 <span class="token keyword">instanceof</span> <span class="token class-name">PersonRequest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAns</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TimableOutput</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于正常的选择调用<code>Print.printAns()</code>即可，当我们需要debug时将<code>DEBUG</code>设置为<code>true</code>即可。</p>
<h3><span id="42-断点">4.2 断点</span></h3>
<blockquote>
<p>虽然断点在多线程中不太合适，但是对于一些RTLE的bug还是很好的。</p>
<p>我觉得可能是在debug模式的时候，我们知道idea会自动调用对象的<code>toString()</code>方法，说明开启了别的线程进行操作，那么就更加方便的复现评测机上由于有多个java线程而出现RTLE的概率大大提高的现象了。</p>
<blockquote>
<p>相对更加容易复现</p>
</blockquote>
<p>而且也能够知道RTLE时各个线程wait在哪里了</p>
</blockquote>
<p>断点的策略性使用：在多线程编程中，我学会了如何策略性地使用断点。尤其是在分析复杂逻辑或追踪特定线程的行为时，合理地设置断点可以帮助我快速定位问题。</p>
<ul>
<li>输出日志的巧妙应用：我经常使用System.out.println()来输出关键信息，这不仅帮助我理解程序的运行流程，还能够在不干扰多线程执行的前提下，定位问题所在。通过输出日志，我能够实时监控程序的状态和线程的交互。</li>
<li>自动化测试的充分利用：为了确保代码的健壮性，我充分利用评测机的自动化测试功能。自动化测试不仅帮助我发现错误，还能够确保我的修复是有效的，并且能够在不同的场景下验证程序的正确性。</li>
<li>代码审查的互助合作：与同学一起进行代码审查是非常有效的debug方法。通过互相审查代码，我们能够互相发现潜在的问题，并提供改进的建议。这种合作学习的方式不仅能够提高代码质量，还能够加深对多线程编程的理解。</li>
<li>锁的可视化分析：可以使用jdk自带的分析工具jvisualvm等进行分析。尤其是死锁基本上都能分析出来。</li>
<li>边界条件的充分考虑：在多线程编程中，我学会了不仅要考虑常规情况，还要特别关注边界条件和异常情况。通过充分测试边界条件，我能够发现并修复潜在的问题，提高程序的稳定性和正确性。</li>
</ul>
<h3><span id="43-我咋就这么多bug">4.3 我咋就这么多bug<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></span></h3>
<p>首先是线程安全，由于一些共享对象的设置，动不动就叫不醒了。</p>
<p>后来是通过将<code>PersonRequestTable</code>和<code>ResetRequestTable</code>两个类合并为一个类才处理好。然后<code>RequestCounter</code>由于有三类线程对其进行操作，出现的问题大大增加。</p>
<p>然后是出现6个reset时会出现问题，睡一睡就好了。</p>
<p>还有巨大的hack数据，分配是因为调参不够全面，全都塞到一个电梯去了，添加几个参数就可以了。</p>
<p>还有CTLE问题，检查每个while(true)都还不知道为什么的话，睡一睡就好了。睡了也不行，那就多多print，看到底是哪里搁那轮询。当然也可以开启debug模式，看停在哪里。</p>
<p>至于更多的问题，能跑就行。</p>
<blockquote>
<p>如果还有问题，那就好办，要么退学要么退休。</p>
</blockquote>
<h2><span id="5-心得体会">5 心得体会</span></h2>
<p>面向对象设计与构造课程的第二单元，是一次深入多线程编程的探险。在这个过程中，我深刻体会到了线程安全和层次化设计的重要性，也在实践中逐渐领悟了如何在复杂的多线程环境中构建稳健的软件系统。</p>
<p>在三次作业的磨砺中，我意识到线程安全是构建可靠多线程程序的基础。我学会了在适当的时机使用锁，保护临界区，确保数据的一致性。同时，我也认识到了过度锁定的危害，它可能导致死锁或者降低程序的性能。因此，我学会了在设计时考虑每个模块的职责，通过合理的抽象和封装，减少共享数据，从而降低线程间的耦合，提高系统的可靠性。</p>
<p>层次化设计在这个单元中显得尤为重要。我学会了如何将复杂的系统分解为多个层次，每个层次都有明确的职责和接口。这样的设计不仅使得代码更加清晰，也便于单元测试和维护。在层次化设计中，我还学会了如何处理层次间的数据流动，如何通过方法调用和数据传递，实现层次间的协作。</p>
<p>在实践中，我也遇到了许多挑战。多线程程序的不可预测性让我在调试时倍感困扰。有时，一个看似微小的改动，就会导致程序的行为大变。这让我深刻理解了多线程环境下测试的重要性。我学会了使用各种工具和技术，如日志记录、断言和单元测试，来确保程序的稳定性和正确性。</p>
<p>虽然这一单元的学习过程充满了艰辛，但我认为这是非常宝贵的经验。我不仅掌握了多线程编程的技术，更重要的是，我学会了如何在面对复杂问题时，保持冷静和系统性的思考。我相信，这些经验和技能将对我未来的职业生涯产生深远的影响。</p>
<p>最后，我要感谢所有在这一单元中给予我帮助的人。感谢那些无私分享经验的学长学姐，感谢那些一起讨论问题的同学，感谢那些在讨论区中提供宝贵意见的网友们，还要感谢助教和课程团队的支持和指导。正是因为有了你们，我才能在这一单元中学到如此之多。</p>
<p>总结这一单元的学习，我深感自己在线程安全和层次化设计方面有了质的飞跃。虽然前方的路还很长，但我相信，只要我继续努力，不断学习和实践，我一定能够在面向对象设计与构造的道路上走得更远。</p>
<p>还是加点碎碎念。</p>
<p>看到很多朋友说自己天赋不在代码上，害，哥们又何尝不是呢。看到很多同学说，为了这个OO熬了很多夜，害，我可不觉得整个六系还有谁比我熬夜更多，肝得越多肝越少。害，最终成绩还烂的一批，凭心而论，习惯了就好了。</p>
<p>唉，什么时候才能长大</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>OO 第二单元</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre</title>
    <url>/2023/11/10/OOpre/</url>
    <content><![CDATA[<h1><span id="buaa-oopre总结">BUAA-OOpre总结</span></h1>
<blockquote>
<p>即面向对象先导课程，<strong>绝世好课！！</strong>！</p>
</blockquote>
<p>所有的代码均可以前往我的<a href="https://github.com/hjzts/BUAA_OO">github</a>中获取</p>
<span id="more"></span>
<h2><span id="part1-作业背景">Part1-作业背景</span></h2>
<blockquote>
<p>一个非常经典的冒险类游戏</p>
</blockquote>
<p>你是一个穿越到魔法大陆上的冒险者，在旅途中，你需要收集各种<strong>道具</strong>（药水瓶和事物），使用各种<strong>装备</strong>，招募其他<strong>冒险者</strong>加入队伍，提升自己的<strong>等级</strong>并体验各种<strong>战斗</strong>，你可以雇佣冒险者，雇佣者会在适当的时候向你提供<strong>帮助</strong>。同时加入了商店功能，在这里可以进行各种商品的购买与出售。</p>
<h2><span id="part2-架构设计">Part2-架构设计</span></h2>
<h3><span id="最终的架构设计">最终的架构设计</span></h3>
<p>从<code>Main</code>类出发。</p>
<ul>
<li>对于IO，首先对于输入使用<code>MyScanner</code>进行处理，将结果得到一个<code>ArrayList</code>里面，再对这个进行解析，然后调用Manager类进行具体操作。</li>
</ul>
<p>主要操作在<code>Manager</code>类中，主要的方法也在<code>Manager</code>类中:happy::happy::happy:</p>
<ul>
<li>
<p>对于要求，我主要是三个大的类进行处理，<code>Adventurer，Backpack，FightMode</code>这几个来进行处理。</p>
</li>
<li>
<p>对于每个<code>Adventurer</code>的管理再<code>Manager</code>里面用一个<code>HashMap</code>来实现。对于每个<code>adventurer</code>，在这里面管理<strong>调度<code>Bottle，Food，Equipment</code>等</strong>，同时对于放进背包的则将其<strong>放到<code>Backpack</code>里面</strong>进行管理调度。</p>
</li>
<li>
<p>进入战斗模式则有一个专门<code>FightMode</code>管理进入的<code>adventurer</code>和进行的操作，对于每个<code>adventurer</code>状态的改变都是在<code>Adventurer</code>类里面实现的，实现<strong>高内聚</strong>。同时后续的增加接口和继承也是直接在<code>Bottle</code>的基础上继承，每次调用都只需要在相应的方法里面实现。</p>
</li>
</ul>
<p>总体还是非常<strong>优雅</strong>的，尽可能的实现了高内聚和低耦合，每次修改代码时感觉上是非常方便的，或许能够间接体现比较好的一个架构建造。</p>
<p>（我也是几乎到最后才知道有<code>package</code>这个东西，虽然加上后文件结构会更加好看，但对于代码架构本身帮助不大）</p>
<h3><span id="架构设计中的调整">架构设计中的调整</span></h3>
<blockquote>
<p>主要是学到什么或者看到其他同学有什么好的就思考一下是否比我的好，并进行相关学习后进行调整</p>
</blockquote>
<ul>
<li>IO处理</li>
</ul>
<p>其中一大调整在于输入处理，随着输入变得更加复杂，需要加入正则表达式进行操作处理后（主要是其中某一个功能有不定行输入），我便将输入处理专门用了一个<code>Scanner</code>类进行处理，以下为具体实现细节：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyScanner</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取行数</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInputInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解析后的输入将会存进该容器中, 类似于c语言的二维数组</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> nextLine <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取本行指令</span>
            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> nextLine<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" +"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按空格对行进行分割</span>
            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"14"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">String</span> nextLine1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    operation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextLine1<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// System.out.println(operation);</span>
            inputInfo<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>operation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将指令分割后的各个部分存进容器中</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// System.out.println(inputInfo);</span>
        <span class="token keyword">return</span> inputInfo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>结构调整</li>
</ul>
<p>在老师讲解完不要再Main里面进行 太多具体的操作后，我便将之前大量的属性和方法移动到了<code>Mynager</code>类中，在这个类中进行不同指令的操作处理，以及正则表达式匹配等。具体实现细节如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Adventurer</span><span class="token punctuation">&gt;</span></span> adventurersMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FightMode</span> fightMode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FightMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> printTestFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token function">getShopInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            strings <span class="token operator">=</span> inputInfo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取第i行指令</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 获取第i行指令的第一个部分</span>
                <span class="token keyword">case</span> <span class="token string">"1"</span><span class="token operator">:</span>
                    <span class="token comment">// Adventurer.add();</span>
                    <span class="token function">adventurerAdd</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>接口与继承</li>
</ul>
<p>后面在要求实现对<code>Bottle</code>类和<code>Equipment</code>类进行继承，以及对几个价值体实现接口时都有对结构进行相应的调整，大体上也是正常不过的基于教程的修改<s>感觉大家的应该都大差不差</s></p>
<h3><span id="以下为uml类图">以下为<strong>UML类图</strong></span></h3>
<p><img src="/2023/11/10/OOpre/1.png" alt></p>
<p>各个类的属性</p>
<p><img src="/2023/11/10/OOpre/2.png" alt></p>
<p>各个类的方法概览</p>
<p><img src="/2023/11/10/OOpre/3.png" alt></p>
<h2><span id="part2-使用junit的心得体会">Part2-使用Junit的心得体会</span></h2>
<blockquote>
<p>上一次用到这种模块性检测的还是在matlab里面</p>
</blockquote>
<p>这种模块化的测试确实会方便于去<strong>寻找具体是哪一方面有问题</strong>，但是我自己本人对于这种工程量很大之后如何处理这些测试指令<strong>感到犯难</strong>，不太懂得具体如何使用。</p>
<p>同时我觉得很好的一点是主动去想办法提高测试的覆盖率，会帮助我狠狠地<strong>提高代码的鲁棒性</strong>，增加很多对于特殊情况的考虑。</p>
<h2><span id="part3-学习oopre的心得体会">Part3-学习OOpre的心得体会</span></h2>
<blockquote>
<p>很早之前就已经听6系学长讲过OO这一种编程方法，当时对于所谓的高内聚低耦合方面还不太懂，当时学长讲的大多数是基于C语言如何进行类似的开发的</p>
</blockquote>
<p>当自己真正开始学习之后，面向对象确实是很好的一种编程理念，特别是中间利用到继承这些时更加感受到了一种代码上的很爽的感觉。</p>
<p>当然，Java真的是一种非常接近自然语言的函数语言，用起来很爽！</p>
<h2><span id="part4-对oopre课程的建议">Part4-对OOpre课程的建议</span></h2>
<ol>
<li>感觉可以讲一些java本身的一些高级的语法，我也是后来才了解到一些，感觉用起来真的很爽</li>
<li>我刚开始写Junit和后来写Junit都有点使用取巧的办法，自己也是为了满足测试率去编写的，中间几次甚至是讲几百行的中测数据直接作为输入处理后的二维数组进行处理，或许可以想办法提高Junit的实用性</li>
</ol>
<p>OOpre绝世好课！！真的在这个过程中学到了很多东西，也非常感谢助教、老师、同学给我提供的帮助。</p>
<p>谢谢nrjj！syf大佬！！还有董佬教了我好多新鲜的东西……谢谢各位！</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>OO-U3</title>
    <url>/2024/06/17/OO-U3/</url>
    <content><![CDATA[<h1><span id="oo第三单元jml">OO第三单元JML</span></h1>
<h2><span id="0-前言">0 前言</span></h2>
<p>本单元的重点或者说想要实现的基础点应该是，学会阅读、理解和简单的写一写JML这种契约式编程，做类似工业上的从设计到正确性验证(助教替我们完成了)到写代码到写测试的全流程分析。</p>
<p>对于JML这种语言本身我一向是不喜欢做太多评价的，不喜欢用就不用，未必是它本身的好坏。但是这种从自然语言到JML(认为是一类契约式语言)再到写测试这一个流程，却反倒让我期待以后自然语言编程了（x</p>
<p>另外一点是，除了需要实现的基础点外，我们为了保证性能还会考虑很多的算法设计来减少时间复杂度。</p>
<h2><span id="1-测试过程分析">1 测试过程分析</span></h2>
<h3><span id="11-黑箱白箱测试">1.1 黑箱白箱测试</span></h3>
<p><strong>黑箱测试</strong>又被称为功能测试，是一种不考虑内部结构和实现的软件测试方法，只关注软件的输入和输出，验证软件功能是否符合预期。黑箱测试的主要目是验证软件的功能需求，检查程序是否能正确运行。</p>
<p>黑箱测试是确保软件质量的重要方法，能发现很多设计或需求不明确导致的问题。但同时，由于黑箱测试并不关注代码的具体实现和内部结构，因此有一些问题（例如资源泄漏，难以复现的错误）可能不能通过黑箱测试发现。因此，黑箱测试通常和其他测试方法（例如白箱测试）结合使用。</p>
<p>在本次作业中，我们搭建的评测机，从生成数据到相互比对输出结果，实际上就是一种典型的黑箱测试。但是由于输入的局限性，导致还是有一些bug没有测出来，哭<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p><strong>白箱测试</strong>，又被称为结构测试、透明箱测试或者玻璃盒测试，是一种软件测试方法，它要求测试者理解被测软件的内部工作机制，了解程序的内部结构，包括主要的代码，逻辑判断和程序路径，然后基于这个理解来设计和实施测试用例。</p>
<p>白箱测试可以让你发现一些隐藏的问题，例如死代码（不会被执行到的代码），逻辑错误，漏洞等等。</p>
<p>在本次作用中，每个人在完成互相阅读代码实际上就是一种白箱测试。互测中，如果相互是通过检查代码然后构造特定数据的实际上也是一种白箱测试。</p>
<h3><span id="12-多种测试思路分析">1.2 多种测试思路分析</span></h3>
<p>在软件测试的流程中，需要不同的测试类型相互协同，共同确保软件的质量。在早期阶段，<strong>单元测试和功能测试</strong>帮助我们发现并修复问题；在代码全部整合起来后，我们需要进行<strong>集成测试和系统测试</strong>来确保各个模块可以正确协同工作；在发布前，我们可能需要进行<strong>压力测试</strong>以确保软件在高负荷下依然可靠；在软件的维护阶段，<strong>回归测试</strong>将帮助我们保证修改后的代码不会影响到已有功能。</p>
<h4><span id="121-单元测试">1.2.1 单元测试</span></h4>
<p>单元测试是指对软件中的最小可测试单元进行检查和验证。对于面向对象编程，这个单元就是方法，但也可以是过程或函数。单元测试主要用于开发阶段，确保每个部分都正常工作。它可以帮助检查和修复程序中的早期错误，将大大减少调试的时间。</p>
<p>对于每个小的单元，我们可以再去选择使用黑箱测试和白箱测试的办法来进行测试。比如Junit基本上就是使用的黑箱测试的办法进行测试，通过多次数据生成和结果比对进行测试。假设我们有一个Java程序，其中有一个类<code>MathUtils</code>，它有一个<code>add</code>方法，用来进行两个数的加法运算：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MathUtils</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了进行单元测试，我们可以创建一个测试类，使用JUnit等测试框架来编写测试方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token static">assertEquals</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MathUtilsTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token class-name">MathUtils</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>testAdd</code>方法中，我们测试了<code>MathUtils.add</code>方法，参数是1和2，预期的结果是3。<code>assertEquals</code>是一个断言方法，如果<code>MathUtils.add(1, 2)</code>的结果不等于3，那么这个单元测试就会失败。</p>
<p>这样的单元测试可以大大提高代码质量，因为它允许开发者在早期阶段就发现和修复错误，也可以作为文档来说明代码的预期行为，还可以促进开发者写出更加模块化、可测试的代码。</p>
<h4><span id="122-功能测试">1.2.2 功能测试</span></h4>
<p>功能测试又称为黑盒测试，主要是从用户的角度进行的，关注的是最终结果是否符合预期的功能。它不关心软件内部逻辑和结构，仅通过操作用户界面，验证软件功能是否正常。</p>
<p>在功能测试中，我们要做的往往在于构造数据。构造数据的强度则决定了这个测试的好坏，因此也是后续会提到的如何更好的构造数据来对相应工程或者每个单元(类和方法等)进行测试。</p>
<h4><span id="123-集成测试">1.2.3 集成测试</span></h4>
<p>集成测试是在所有模块逐个测试的基础上，进行联合测试，以便发现模块间的错误和问题。它主要目的是确保各个模块能够正确地协同工作。</p>
<p>在进行集成测试时，我们通常采取增量的方式，每次将一个新的模块添加到一个已经进行过测试的模块组中，并进行测试。</p>
<p>例如：你在开发一个电商网站，网站的主要功能包括用户注册、登录、浏览商品、添加购物车、提交订单等模块。每个模块单独开发完成后，你都会进行单元测试，确保它们的功能实现是正确的。然后，你需要进行集成测试，一步一步的将这些模块组装在一起。</p>
<p>首先，你可能会集成用户注册和登录模块，测试用户注册后能否成功登录；然后再集成商品浏览模块，测试登录后的用户能否正常浏览商品；然后再集成添加购物车模块，测试用户能否将商品添加到购物车中；最后，集成提交订单模块，测试用户从浏览商品到提交订单的整个购物流程是否都能正常进行。</p>
<p>集成测试是软件开发中非常重要的一个步骤，它能帮助你发现各个模块间交互时可能存在的问题，然后针对这些问题进行修复，确保整个系统的稳定性和可靠性。</p>
<p>比如在这次hw11中出现了 <code>qtvs</code>的bug，或许就是因为没做好集成测试，导致后续新加的方法对原先的动态维护产生了影响。</p>
<h4><span id="124-压力测试">1.2.4 压力测试</span></h4>
<p>压力测试是通过模拟大量、超出软件规定的负荷或者测试环境进行测试，以确定其性能的稳定性和可靠性。目的是调整优化系统的性能，以便在高负载环境下正常工作。</p>
<p>在U2的时候或许体会更加深刻，当某一时刻到达多个进行时如何处理。这一单元主要是对于内存和cpu运行时间的挑战，如何应对一些极端数据以及针对极端数据的优化。</p>
<h4><span id="125-回归测试">1.2.5 回归测试</span></h4>
<p>在修改了旧代码或者添加了新代码后，回归测试可以确保软件的原有功能仍然可以正常工作。回归测试的目的是发现在修改和介入新模块后引入的错误或方案中遗漏的错误。</p>
<p>回归测试可以是手动执行，也可以是自动执行。在大型和快速迭代的项目中，自动化的回归测试能大大提高效率。这通常需要一个稳定的，自动化的测试套件和持续集成（Continuous Integration）环境。</p>
<p>比如我们在作业迭代过程中，不能因为迭代影响到了之前的程序，这也和程序设计的方法相关。</p>
<h4><span id="13-数据构造">1.3 数据构造</span></h4>
<p>我们构造数据主要是围绕上面提到的方法进行构造。</p>
<p>针对<strong>黑箱测试</strong>，可以使用数据生成器，随机生成各种数据，来保证能够实现基本的功能。</p>
<p>针对<strong>单元测试</strong>，在本单元不同指令间的关系不是很紧密，我们可以构造以某一类数据为主的数据来进行测试。</p>
<p>针对<strong>压力测试</strong>，可以设计更加极端的数据进行构造。包括数据范围是int，构造接近<code>Integer_MAX、Integer_MIN</code>的数据来进行测试。构造一些很大的数据，确保能够在给定的时间空间内完成要求。</p>
<h2><span id="2-架构设计">2 架构设计</span></h2>
<p>本单元由于已经设计好了JML规格化的描述，我们对于架构的设计也不是重点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hjzts/imgs/img20240518173348.png" alt></p>
<p>除了一些大家都有的，讲一下我自己特色的两个设计，一个是使用了一个<code>MyNetwork</code>里面的一个内置类<code>Edge</code>来存储边，同时改写了<code>hashCode</code>和<code>equals</code>方法，优化了边的存储结构。</p>
<p>同时使用了一个<code>Checker</code>类，它本身也是自己的工厂，这里用到了单例模式的饿汉式加载。专门来处理某些异常的情况。</p>
<h3><span id="21-层次化设计">2.1 层次化设计</span></h3>
<p>本次用到了<code>Network</code>中有很多<code>Person</code>，<code>Person</code>中很多有<code>Tag</code>，每个<code>Tag</code>中又有<code>Person</code>，同时<code>Network</code>中有很多<code>Message</code>，每个人有很多<code>Message</code>这个层次化的结构。</p>
<p>我们在设计时，尽量不要逆层次来进行操作，可能出现奇怪的bug。</p>
<h3><span id="22-图的存储与维护">2.2 图的存储与维护</span></h3>
<p>这里的核心是<code>MyNetwork</code>中的</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>和<code>MyPerson</code>中的</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是这里是一个邻接表的结构。</p>
<p>这里也能够想办法使用邻接矩阵的办法，但是考虑到空间等因素，似乎都不是最优解。</p>
<p>人与人之间的关系通过在某个<code>Person</code>的<code>persons</code>里面<code>put / remove</code>即可。</p>
<p>然后这里还有需要维护的是<code>Edge</code>，其实本不必存储<code>Edge</code>，但是由于后续我用到了并查集，需要在重建并查集时使用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
       <span class="token keyword">private</span> <span class="token keyword">int</span> id1<span class="token punctuation">;</span>
       <span class="token keyword">private</span> <span class="token keyword">int</span> id2<span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>id1 <span class="token operator">=</span> id1<span class="token punctuation">;</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>id2 <span class="token operator">=</span> id2<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token annotation punctuation">@Override</span>
       <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">Edge</span> edge <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
           <span class="token keyword">return</span> <span class="token punctuation">(</span>edge<span class="token punctuation">.</span>id1 <span class="token operator">==</span> id1 <span class="token operator">&amp;&amp;</span> edge<span class="token punctuation">.</span>id2 <span class="token operator">==</span> id2<span class="token punctuation">)</span> <span class="token operator">||</span>
                   <span class="token punctuation">(</span>edge<span class="token punctuation">.</span>id1 <span class="token operator">==</span> id2 <span class="token operator">&amp;&amp;</span> edge<span class="token punctuation">.</span>id2 <span class="token operator">==</span> id1<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token annotation punctuation">@Override</span>
       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>id1<span class="token punctuation">,</span> id2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">31</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>id1<span class="token punctuation">,</span> id2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> id1<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> id2<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里和<code>Pair</code>这个数据结构不同，使得这里的边是实实在在的<strong>无向边</strong>。</p>
<p>这里相关的系数也是调试了几次后选的相对比较好的。（或许能够有更好的。。。</p>
<h3><span id="23-规格与设计分离">2.3 规格与设计分离</span></h3>
<p>规格与设计分离的原则是指在软件开发过程中，我们可以分别独立地描述软件的“什么”和“如何”。即，我们将软件的功能需求或业务逻辑（即规格）与软件的实现细节或内部结构（即设计）显示地分离开。</p>
<p>它的主要思想是：</p>
<ol>
<li>规格（或需求）描述了软件应该做什么，也就是它需要提供哪些功能，如何满足用户的需求。规格通常包括数据校验，业务规则，数据转换和处理，用户界面逻辑等。</li>
<li>设计描述了如何实现这些功能，包括软件的结构，类或函数的设计，选择何种算法等实现细节。</li>
</ol>
<p>在面向对象的设计中，这种原则尤为重要，为了体现这种原则，我们通常把规格抽象出接口，而将设计和实现写在具体的类中。即，接口定义了规格，类提供了设计和实现。这使得我们可以在不改变接口的情况下改变内部实现，也能在不改变内部实现的情况下增加新的接口。</p>
<p>这种分离的好处是：</p>
<ul>
<li>提高了软件的可维护性和可读性，因为更改需求或设计时，只需要关注一部分代码，减少了复杂性。</li>
<li>提高了软件的可扩展性和灵活性，因为可以在不改变已有设计的前提下添加新功能，或者在不改变已有功能的前提下改变内部实现。</li>
<li>增强了模块化，可以更好地实现高内聚低耦合的原则。</li>
<li>方便进行单元测试和集成测试，因为可以分别对规格和设计进行测试。</li>
</ul>
<h2><span id="3-性能与算法">3 性能与算法</span></h2>
<h3><span id="31-数据结构">3.1 数据结构</span></h3>
<ol>
<li>
<p>这里大多数使用的是<code>HashMap</code>这个数据结构，可以快速查找。</p>
<p>这里有个小细节</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是在新建<code>HashMap</code>的时候可以设置开始的容量和负载因子。负载因子说的是当使用的元素超过这个比例后会重新分配一次。可以尝试调参&amp;炼丹</p>
</li>
<li>
<p>在后续添加的<code>message</code>那里，由于涉及头插法，因此建议使用<code>LinkedList</code>这个数据结构，会比<code>ArrayList</code>的效果更好。</p>
<p>在<code>ArrayList</code>中<code>add(0, message1)</code>是会把后面的元素重新复制一遍，复杂度较高。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
                     size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而在<code>LinkedList</code>中只需要处理一下类似指针的操作，复杂度为O(1)。</p>
</li>
</ol>
<h3><span id="32-公式优化">3.2 公式优化</span></h3>
<p><code>queryTagAgeVar</code>指令中，我们需要计算年龄的方差，但是没必要根据JML中的循环来计算，而是可以维护<code>agePowSum</code>和<code>ageSum</code>替换成下面的代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAgeVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>persons<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> ageMean <span class="token operator">=</span> ageSum <span class="token operator">/</span> persons<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 考虑到java向下的负数取整是-1.25 -&gt; -1 (不完全是向下取整),不能将ageMean * ageMean * persons.size()提出去</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>agePowSum <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> ageMean <span class="token operator">*</span> ageSum <span class="token operator">+</span> ageMean <span class="token operator">*</span> ageMean <span class="token operator">*</span> persons<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> persons<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就可以降低时间复杂度。同时这里还需要注意一些细节，比如在注释中提到了不能将<code>ageMean * ageMean * persons.size()</code>提出去。</p>
<h3><span id="33-动态维护">3.3 动态维护</span></h3>
<p>本次作业中，很重要的一个优化方法就是动态维护。动态维护实际上是将一些中间变量进行保存。</p>
<blockquote>
<p>这里还想进一步分析一下。</p>
<p>实际上这种动态维护会发现，比如说我在<code>addRelation</code>的时候，本来只需要添加到对应的<code>HashMap</code>里面就可以了，但是这样我还得要么加到一个缓冲区<code>buffer</code>里面，要么进行多余的计算。单对这一个指令来说无疑是</p>
</blockquote>
<p>在<code>queryBlockSum</code>、<code>queryTripleSum</code>、<code>queryTagValueSum</code>、<code>queryCoupleSum</code>等指令中，如果我们每次查询都是将图遍历一遍，那么时间复杂度大大提高，具体问题可能超过$O(n^3)$，这是我们不能接受的。</p>
<p><strong>对于<code>BlockSum</code>是用到了并查集进行优化。</strong></p>
<p>并查集，也称为不相交集合（Disjoint-Set），是计算机科学中处理一些不交集类问题的一种主要数据结构，它管理一系列不相交的集合，并支持将两个集合合并为一个集合，以及查询元素属于哪个集合的功能。并查集的主要操作包括：</p>
<blockquote>
<p>大体理解就是，每个集合找一个代表，每个人都只认识那个代表，比较的时候只需要进一步比较那两个代表是不是同一个集合或者同一个人即可。</p>
</blockquote>
<ol>
<li><strong>创建并查集</strong>：开始时，每个元素都在只包含自己的集合中，这些集合可以通过一个一维数组来表示，数组的索引表示元素，数组的值表示各个集合的代表元素。</li>
<li><strong>查询操作</strong>（Find）：这个操作可以查找给定元素属于哪个集合，通常通过查找其“代表元素”（或“集合的根”）来完成。在一个集合内的所有元素都链接到该集合的代表元素。</li>
<li><strong>合并操作</strong>（Merge）：这个操作可以将两个集合合并为一个集合，通常通过将一个集合的代表元素链接到另一个集合的代表元素下实现。</li>
</ol>
<p>由于并查集支持非常高效的合并和查询操作，因此在很多含有大量查询和合并操作的问题中，首选使用并查集。</p>
<p>在<code>MyNetwork</code>中维护一个</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> roots <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在<code>addPerson</code>的时候把自己添加进去。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">roots<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同时在添加关系的时候进行<code>merge</code>操作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**********************并查集*************************/</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>roots<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    roots<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token function">find</span><span class="token punctuation">(</span>roots<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> roots<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> root1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> root2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    roots<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>root2<span class="token punctuation">,</span> root1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    blockSum<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reBuild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    blockSum <span class="token operator">=</span> roots<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    roots<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> roots<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    edges<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>edge <span class="token operator">-&gt;</span> <span class="token function">merge</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token function">getId1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edge<span class="token punctuation">.</span><span class="token function">getId2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里有<code>rebuild</code>是因为涉及到并查集的重建。</p>
<blockquote>
<p>这里也正是因为需要重建的关系，可能不如dfs。</p>
<p>也是我在这一小节最开始提到的，不同的算法实际上实际时间分配到了不同的地方，因此都有可行的地方。</p>
</blockquote>
<p>那么有了并查集之后，每次添加一个人，也就是进行<code>addPerson</code>，那就增加一个<code>block</code>。</p>
<p>然后再查询的时候设置了一个是否需要重建的因子，如果涉及到了删除边，那么就需要重建并查集，此时我们可以等到需要查询的时候在重建，实现<strong>懒重建</strong>。</p>
<p>同时在<code>merge</code>的时候如果两个人本来不在一个集合中，那么就需要减少一个<code>block</code>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPerson</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">EqualPersonIdException</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    blockSum<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">queryBlockSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>needReBuild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reBuild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        needReBuild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> blockSum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>对于<code>TripleSum</code>是每次增加一个关系或者删去关系，进行遍历，检查是否需要修改。</strong></p>
<p><code>addRelation</code>和<code>modifyRelation</code>的时候分别重新修改一下<code>tripleSum</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRelation</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	tripleSum <span class="token operator">+=</span> <span class="token function">queryThree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modifyRelation</span><span class="token punctuation">(</span><span class="token keyword">int</span> id1<span class="token punctuation">,</span> <span class="token keyword">int</span> id2<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">PersonIdNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">EqualPersonIdException</span><span class="token punctuation">,</span> <span class="token class-name">RelationNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queryValue</span><span class="token punctuation">(</span>persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tripleSum <span class="token operator">-=</span> <span class="token function">queryThree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**********************检查三角形*************************/</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">queryThree</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span> person1<span class="token punctuation">,</span> <span class="token class-name">MyPerson</span> person2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getPersonSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> person2<span class="token punctuation">.</span><span class="token function">getPersonSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> person1<span class="token punctuation">.</span><span class="token function">queryThree</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> person2<span class="token punctuation">.</span><span class="token function">queryThree</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>对于<code>TagValueSum</code>也是在每次添加关系、修改关系和删去关系时都需要进行调整。</strong></p>
<blockquote>
<p>这里我自己有一个优化(似乎没什么用)，就是添加了一个<code>buffer</code>，每次在tag里面添加一个人，我先不计算新的<code>tagValue</code>，先放到<code>buffer</code>里面。</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
     * 用于为valueSum的求解进行缓冲。
     * 等到需要用到value sum的时候在进行添加。
     */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValueSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> person <span class="token operator">:</span> personBuffer<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 前一部分与后一部分</span>
        persons<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                        valueSum <span class="token operator">+=</span> personBuffer<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> value<span class="token punctuation">.</span><span class="token function">queryValue</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 后一部分之间</span>
        personBuffer<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                             valueSum <span class="token operator">+=</span> value<span class="token punctuation">.</span><span class="token function">queryValue</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    personBuffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> valueSum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时删除的时候进行一下判断。</p>
<blockquote>
<p>其实也就这里会是唯一比不加<code>buffer</code>有优势的地方了！！！</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delPerson</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>personBuffer<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        personBuffer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        persons<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> valueSum <span class="token operator">-=</span>
                        personBuffer<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> value<span class="token punctuation">.</span><span class="token function">queryValue</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>对于<code>CoupleSum</code>这个，可以给每个人维护一个<code>bestId</code>。</strong></p>
<p>这样的话最佳情况就是O(n)，是可以接受的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">queryCoupleSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    coupleSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Person</span> person <span class="token operator">:</span> persons<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPersonSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>persons<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MyPerson</span><span class="token punctuation">)</span> person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBestAcquaintance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">getBestAcquaintance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> person<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            coupleSum<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> coupleSum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里注意在维护的时候要注意数据范围。</p>
<blockquote>
<p>如果明年我当助教肯定要在这里埋个坑。樂（x</p>
</blockquote>
<h3><span id="34-算法优化">3.4 算法优化</span></h3>
<p>包括前面的并查集其实也可以认为是算法优化。</p>
<p>这里主要是指在维护每个人的<code>bestId</code>的时候可以使用优先队列或者堆的思想，可以将$O(n)$变为$O(log(n))$。但是这里的话，从我打超算的角度认为是很好的一个优化，但是从一个做算法题的角度，能过就行。那么从$O(n)$变为$O(log(n))$在这里时间能够运行的情况下是完全没有必要的。</p>
<h2><span id="4-junit测试">4 Junit测试</span></h2>
<h3><span id="利用jml设计junit">利用JML设计Junit</span></h3>
<p>JML，是一种行为界面规范语言，用于详细的说明 Java 中类和接口应该如何表现。它可以用于为 Java 方法和类编写规格。然后，这些规格可以与测试工具（如 JUnit）配合使用，来验证代码是否满足 JML 规格。</p>
<p>在 JML 中，我们可以针对方法的行为进行描述，例如方法的前提条件（requires）、后置条件（ensures）、不变性（invariant）等等。</p>
<p>使用 JML，我们可以根据这些描述生成适合于 JUnit 的测试用例，然后使用 JUnit 来运行这些测试。</p>
<p>关于具体编写，我的Junit测试可以分为这么几步：</p>
<ol>
<li>
<p>首先设计数据规格和对象初始化</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Network</span> network <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Tag</span><span class="token punctuation">&gt;</span></span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> personNum <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> tagNum <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> relationNum <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> emojiNum <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> personPerTag <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> messageNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> emojiMessageNum <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> emojiMessageSendNum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> testNum <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的<code>network</code>实际上就是主要测试对象，而其他的是我们自己存储的拷贝对象。</p>
</li>
<li>
<p>搭建数据生成器，用最开始设计的数据的规模生成大量随机数据；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">genAddPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">genAddRelation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">genAddTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">genStoreEmoji</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们这里其实不需要生成所有类型的指令，只需要其中几个即可。</p>
</li>
<li>
<p>将翻译JML得到的标准答案与执行指令得到的答案进行比较；</p>
</li>
<li>
<p>检查执行指令前后是否符合JML中的ensures等要求。</p>
</li>
<li>
<p>注意需要检查<code>pure</code>这种，包括还有那些<code>not_assigned</code>的值。</p>
</li>
</ol>
<h3><span id="junit与jml的一致性">Junit与JML的一致性</span></h3>
<p>JML（Java Modeling Language）和JUnit都是用于Java程序的工具，但它们解决的问题并保证代码质量的方法是不同的。</p>
<p>JML是一种行为界面规范语言，可以通过注释的形式为Java程序提供规格说明。JML提供了稳定、详细的规格，用于描述程序各部分预期的行为。例如，你可以使用JML为Java类或方法注解一个先决条件（pre-condition）、后置条件（post-condition）或者类不变性（class invariant）。JML规范可以通过静态检查或者运行时断言来进行验证。</p>
<p>再来看JUnit，JUnit是Java的一种单元测试框架，它通过编写测试用例，然后运行这些测试用例，验证程序的实际行为是否符合预期行为。JUnit完全依赖于程序员编写的测试用例，其准确性和覆盖率取决于测试用例的质量。</p>
<p>那么JML和JUnit之间的关系是什么呢？简单来说，一致性来自于它们都是在描述软件应该如何运行。JUnit测试实际行为，而JML描述预期行为。一致性的证明过程则相当于是在比较预期行为与实际行为。例如，当你有一个JML规格的后置条件为@ensures \result &gt;=0，并且你有一个JUnit测试用例没有符合该后置条件（得到的结果为负数），这时一致性就被破坏了。</p>
<p>更深入一步，我们可以利用JML规格自动生成JUnit测试用例，然后通过运行这些用例来验证程序符合JML规格的要求。这使得JML和JUnit可以无缝配合，有效地提高了代码质量的保证和验证效率。</p>
<h2><span id="5-学习体会">5 学习体会</span></h2>
<p>这一单元，对于一个在计院待了差不多一年，经历了大一的磨练的来说应该是不难的。</p>
<p>我在最前面也提到了，本单元的重点应该是学会阅读、理解和简单的写一写JML这种契约式编程。但是不知道是基于什么考量，本单元我们需要关注更多的是怎么去优化，怎么去考虑更好的算法。</p>
<p>这让我联想到了大一上的程序设计的课程，那时我啥都不会，那个课程也是目的是为了让我们学习C语言的基础语法，但是涉及到很多算法层面的内容。</p>
<p>这两者都有一个共同点，就是似乎总是想要通过某种手段分出一个孰优孰劣出来，但是忽略了我们只是需要完成基本的需求即可。</p>
<p>我这里并不是对OO这个课程有任何看法，我始终觉得这个是一个绝世好课。</p>
<p>我只是觉得大学真的有必要通过这个超出基本需求的要求来对学生进行评判吗。</p>
<blockquote>
<p>害，不说了，终究是我太菜了，菜就多练吧</p>
</blockquote>
<p>对于JML本身，我觉得它是一个非常有效的工具，可以大大提高Java程序的质量和可维护性。首先，通过在代码中添加JML注释，我们可以明确规定方法的预期行为，包括前置条件、后置条件、不变性等。这为我们提供了一种非常明确的方式来表达我们的意图，并定义代码应当如何执行。其次，JML可以帮助我们发现代码中的错误，而且能够在非常早的阶段就发现这些错误。当我们编写了JML注释后，可以使用JML的工具来静态检查我们的代码，看看代码是否满足我们的预期。这可以在实际运行代码之前就找出很多潜在的问题。再者，JML也支持运行时检查。通过JML，我们可以生成可以在运行时检查的断言。这对于找出一些难以复现的bug，或者是一些只有在特定情况下才会出现的问题非常有帮助。同时，JML还可以帮助我们自动生成测试用例。只要我们为代码编写了详细的JML注释，就可以通过工具自动产生JUnit的测试用例。这对于保证代码质量，提高测试效率都非常有帮助。综上所述，我认为JML是一个非常强大且有用的工具。它可以帮助我们更好地理解我们的代码，提高代码质量，以及提高我们的开发效率。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>OO 第三单元</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2023/05/25/Trie/</url>
    <content><![CDATA[<blockquote>
<p>Tire树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。</p>
</blockquote>
<span id="more"></span>
<p>说白了，就是一棵大树，这棵树的每个除了根节点的结点都存储了一个字符。</p>
<h2><span id="说在前面">说在前面</span></h2>
<p>字典树有两种实现方式，一种是利用指针实现，也就是一个实实在在的二十六叉树；另一种就是利用数组实现。（在这里分别称之为指针版字典树和数组版字典树）</p>
<p>两种实现方式各有优劣，指针版本的清晰明了，空间占用率相对较小（空间占用小就可以用剩下的空间干其他很多事）；而数组版字典树就是一次性把空间开好了，比较方便。</p>
<h2><span id="指针版字典树">指针版字典树</span></h2>
<p>结构体定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">datatype</span> <span class="token expression"><span class="token keyword">int</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
    bool isEnd<span class="token punctuation">;</span>
    datatype data<span class="token punctuation">;</span>		<span class="token comment">//一般是计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>letter<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>Node<span class="token punctuation">,</span><span class="token operator">*</span>List<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建一个结点的初始化：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，一种更加推荐的方式是使用<code>calloc()</code>函数，<code>malloc()</code>有更多自己操控的空间</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一棵<code>Trie</code>:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span></span></span>
<span class="token keyword">void</span> <span class="token function">createStopTrie</span><span class="token punctuation">(</span>List <span class="token operator">*</span>root<span class="token punctuation">,</span> FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSIZE<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    List end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ch <span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">islower</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            end <span class="token operator">=</span> end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
            depth<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            end<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> true<span class="token punctuation">;</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
            end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> Depth<span class="token punctuation">)</span> Depth <span class="token operator">=</span> depth<span class="token punctuation">;</span>
            depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用前需要</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Root <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">createArticleTrie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Root<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>三个基本性质：</strong></p>
<ul>
<li>根节点不包含字符，除根节点的每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
<p>我觉得这个像是一个26叉树，也有一点想26进制的一个东西。</p>
<p>我们这里存储的都是小写字母，如果包含又大写字母的话可能就是一个52叉树了。一般不会出现这种情况吧，<s>出现了也不怪我</s></p>
<blockquote>
<p>主要实现单词的高效存储与高效查找</p>
</blockquote>
<p>利用<code>cout[i]</code>来记录以<code>i</code>为编号的字符结尾的字符串的个数。</p>
<p>就有两个基本操作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cou<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span>
<span class="token keyword">char</span> str<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
      tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>
    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/forever_dreams/article/details/81009580">https://blog.csdn.net/forever_dreams/article/details/81009580</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">https://zhuanlan.zhihu.com/p/28891541</a></li>
<li><a href="https://blog.csdn.net/weixin_42815609/article/details/102692411">https://blog.csdn.net/weixin_42815609/article/details/102692411</a></li>
<li>用C++讲得很清楚：<a href="https://blog.csdn.net/weixin_44176696/article/details/104716191">https://blog.csdn.net/weixin_44176696/article/details/104716191</a></li>
<li>这个有头文件诶，高级！：<a href="https://blog.csdn.net/A951860555/article/details/108716487">https://blog.csdn.net/A951860555/article/details/108716487</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>bash</title>
    <url>/2024/04/24/bash/</url>
    <content><![CDATA[<h1><span id="shell-script">shell script</span></h1>
<blockquote>
<p>时刻记住这是 一个脚本语言，一个更加彻底的解释型语言</p>
</blockquote>
<h3><span id="introduction">Introduction</span></h3>
<p>命令行最前面的例如<code>git@22373058</code>修改</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"$ "</span><span class="token punctuation">;</span> <span class="token builtin class-name">export</span> <span class="token environment constant">PS1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Hello World脚本程序</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'#!/bin/sh'</span> <span class="token operator">&gt;</span> my-script.sh
$ <span class="token builtin class-name">echo</span> <span class="token string">'echo Hello World'</span> <span class="token operator">&gt;&gt;</span> my-script.sh
$ <span class="token function">chmod</span> <span class="token number">755</span> my-script.sh
$ ./my-script.sh
Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="philosophy">Philosophy</span></h3>
<p>powerful echo!!</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># This is a comment!</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Hello      World"</span>       <span class="token comment"># This is a comment, too!</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Hello * World"</span>
<span class="token builtin class-name">echo</span> Hello * World
<span class="token builtin class-name">echo</span> Hello      World
<span class="token builtin class-name">echo</span> <span class="token string">"Hello"</span> World
<span class="token builtin class-name">echo</span> Hello <span class="token string">"     "</span> World
<span class="token builtin class-name">echo</span> <span class="token string">"Hello "</span>*<span class="token string">" World"</span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span>hello<span class="token variable">`</span></span> world
<span class="token builtin class-name">echo</span> <span class="token string">'hello'</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="variables">Variables</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">MY_MESSAGE</span><span class="token operator">=</span><span class="token string">"Hello World"</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$MY_MESSAGE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Note that there must be no spaces around the “<code>=</code>” sign: <code>VAR=value</code> works; <code>VAR = value</code> doesn’t work. In the first case, the shell sees the “<code>=</code>” symbol and treats the command as a variable assignment. In the second case, the shell assumes that VAR must be the name of a command and tries to execute it.</p>
<p>这里必须要加引号，这是因为一个var只能有一个值</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">6</span>
$ <span class="token function">expr</span> <span class="token variable">$x</span>+1
<span class="token number">6</span>+1
$ <span class="token function">expr</span> <span class="token variable">$x</span> + <span class="token number">1</span>
<span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>program <code>expr</code> only expects numbers.因此这里的必须是数字</p>
<p>We can interactively set variable names using the <code>read</code> command.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token builtin class-name">echo</span> What is your name?
<span class="token builtin class-name">read</span> MY_NAME
<span class="token builtin class-name">echo</span> <span class="token string">"Hello <span class="token variable">$MY_NAME</span> - hope you're well."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>变量的作用域</p>
<ul>
<li>
<p>export</p>
</li>
<li>
<p>source 可以使用<code>.</code>来进行source</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> myvar2.sh
<span class="token comment">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token string">"MYVAR is <span class="token variable">$MYVAR</span>"</span>
<span class="token assign-left variable">MYVAR</span><span class="token operator">=</span><span class="token string">"hi there"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"MYVAR is <span class="token variable">$MYVAR</span>"</span>
$ <span class="token builtin class-name">.</span> ./myvar2.sh
MYVAR is hi there
MYVAR is hi there<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3><span id="loops">Loops</span></h3>
<p>For Loops</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Looping ... number <span class="token variable">$i</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>While Loops</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">INPUT_STRING</span><span class="token operator">=</span>hello
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INPUT_STRING</span>"</span> <span class="token operator">!=</span> <span class="token string">"bye"</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Please type something in (bye to quit)"</span>
  <span class="token builtin class-name">read</span> INPUT_STRING
  <span class="token builtin class-name">echo</span> <span class="token string">"You typed: <span class="token variable">$INPUT_STRING</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意<code>[ ]</code>和中间的语句都要有空格隔开，因为需要把<code>[</code>理解为命令 <code>]</code>理解为参数，所以必须要加空格</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">while</span> <span class="token builtin class-name">:</span>
<span class="token keyword">do</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"please type something (^C to quit)"</span>
        <span class="token builtin class-name">read</span> INPUT_STRING
        <span class="token builtin class-name">echo</span> <span class="token string">"you typed : <span class="token variable">$INPUT_STRING</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意<code>while</code>后面就必须要有空格了</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> input_text
<span class="token keyword">do</span>
  <span class="token keyword">case</span> <span class="token variable">$input_text</span> <span class="token keyword">in</span>
        hello<span class="token punctuation">)</span>          <span class="token builtin class-name">echo</span> English    <span class="token punctuation">;</span><span class="token punctuation">;</span>
        howdy<span class="token punctuation">)</span>          <span class="token builtin class-name">echo</span> American   <span class="token punctuation">;</span><span class="token punctuation">;</span>
        gday<span class="token punctuation">)</span>           <span class="token builtin class-name">echo</span> Australian <span class="token punctuation">;</span><span class="token punctuation">;</span>
        bonjour<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> French     <span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token string">"guten tag"</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> German     <span class="token punctuation">;</span><span class="token punctuation">;</span>
        *<span class="token punctuation">)</span>              <span class="token builtin class-name">echo</span> Unknown Language: <span class="token variable">$input_text</span>
                <span class="token punctuation">;</span><span class="token punctuation">;</span>
   <span class="token keyword">esac</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> myfile.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个是从<code>myfile.txt</code>作为输入流进行处理</p>
<p>A handy Bash (but not Bourne Shell) tip I learned recently from the <a href="http://www.linuxfromscratch.org/">Linux From Scratch</a> project is:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> rc<span class="token punctuation">{</span><span class="token number">0,1</span>,2,3,4,5,6,S<span class="token punctuation">}</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>instead of the more cumbersome:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">runlevel</span> <span class="token keyword">in</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> S
<span class="token keyword">do</span>
  <span class="token function">mkdir</span> rc<span class="token variable">${runlevel}</span>.d
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>And this can be done recursively, too:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /
$ <span class="token function">ls</span> <span class="token parameter variable">-ld</span> <span class="token punctuation">{</span>,usr,usr/local<span class="token punctuation">}</span>/<span class="token punctuation">{</span>bin,sbin,lib<span class="token punctuation">}</span>
drwxr-xr-x    <span class="token number">2</span> root     root         <span class="token number">4096</span> Oct <span class="token number">26</span> 01:00 /bin
drwxr-xr-x    <span class="token number">6</span> root     root         <span class="token number">4096</span> Jan <span class="token number">16</span> <span class="token number">17</span>:09 /lib
drwxr-xr-x    <span class="token number">2</span> root     root         <span class="token number">4096</span> Oct <span class="token number">27</span> 00:02 /sbin
drwxr-xr-x    <span class="token number">2</span> root     root        <span class="token number">40960</span> Jan <span class="token number">16</span> <span class="token number">19</span>:35 usr/bin
drwxr-xr-x   <span class="token number">83</span> root     root        <span class="token number">49152</span> Jan <span class="token number">16</span> <span class="token number">17</span>:23 usr/lib
drwxr-xr-x    <span class="token number">2</span> root     root         <span class="token number">4096</span> Jan <span class="token number">16</span> <span class="token number">22</span>:22 usr/local/bin
drwxr-xr-x    <span class="token number">3</span> root     root         <span class="token number">4096</span> Jan <span class="token number">16</span> <span class="token number">19</span>:17 usr/local/lib
drwxr-xr-x    <span class="token number">2</span> root     root         <span class="token number">4096</span> Dec <span class="token number">28</span> 00:44 usr/local/sbin
drwxr-xr-x    <span class="token number">2</span> root     root         <span class="token number">8192</span> Dec <span class="token number">27</span> 02:10 usr/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="test">Test</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">type</span> <span class="token punctuation">[</span>
<span class="token punctuation">[</span> 是 shell 内建
$ <span class="token function">which</span> <span class="token punctuation">[</span>
/usr/bin/<span class="token punctuation">[</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin/<span class="token punctuation">[</span>
-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">51632</span>  <span class="token number">2</span>月  <span class="token number">8</span>  <span class="token number">2022</span> <span class="token string">'/usr/bin/['</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin/test
-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">43440</span>  <span class="token number">2</span>月  <span class="token number">8</span>  <span class="token number">2022</span> /usr/bin/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>This means that ‘<code>[</code>’ is actually a program, just like <code>ls</code> and other programs, so it must be surrounded by spaces:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token variable">$foo</span> <span class="token operator">=</span> <span class="token string">"bar"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>will not work; it is interpreted as <code>if test$foo = "bar" ]</code>, which is a ‘<code>]</code>’ without a beginning ‘<code>[</code>’. Put spaces around all your operators.</p>
<p>关于条件表达式</p>
<p>Some shells also accept “<code>==</code>” for string comparison; this is not portable, a single “<code>=</code>” should be used for strings, or “<code>-eq</code>” for integers.</p>
<p>The syntax for <code>if...then...else...</code> is:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token punctuation">..</span>. <span class="token punctuation">]</span>
<span class="token keyword">then</span>
  <span class="token comment"># if-code</span>
<span class="token keyword">else</span>
  <span class="token comment"># else-code</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Also, be aware of the syntax - the “<code>if [ ... ]</code>” and the “<code>then</code>” commands must be on different lines. Alternatively, the semicolon “<code>;</code>” can separate them:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token punctuation">..</span>. <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token comment"># do something</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>You can also use the <code>elif</code>, like this:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span>  <span class="token punctuation">[</span> something <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
 <span class="token builtin class-name">echo</span> <span class="token string">"Something"</span>
 <span class="token keyword">elif</span> <span class="token punctuation">[</span> something_else <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"Something else"</span>
 <span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"None of the above"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>example</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token parameter variable">-lt</span> <span class="token string">"0"</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"X is less than zero"</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token parameter variable">-gt</span> <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"X is more than zero"</span>
<span class="token keyword">fi</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token parameter variable">-le</span> <span class="token string">"0"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is less than or equal to  zero"</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token parameter variable">-ge</span> <span class="token string">"0"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is more than or equal to zero"</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is the string or number <span class="token entity" title="\&quot;">\"</span>0<span class="token entity" title="\&quot;">\"</span>"</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X matches the string <span class="token entity" title="\&quot;">\"</span>hello<span class="token entity" title="\&quot;">\"</span>"</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token operator">!=</span> <span class="token string">"hello"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is not the string <span class="token entity" title="\&quot;">\"</span>hello<span class="token entity" title="\&quot;">\"</span>"</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is of nonzero length"</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is the path of a real file"</span> <span class="token operator">||</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"No such file: <span class="token variable">$X</span>"</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-x</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is the path of an executable file"</span>
<span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token parameter variable">-nt</span> <span class="token string">"/etc/passwd"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"X is a file which is newer than /etc/passwd"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Note that we can use the semicolon (<code>;</code>) to join two lines together. This is often done to save a bit of space in simple <code>if</code> statements.<br>
The backslash (<code>\</code>) serves a similar, but opposite purpose: it tells the shell that this is not the end of the line, but that the following line should be treated as part of the current line. This is useful for readability. It is customary to indent the following line after a backslash (<code>\</code>) or semicolon (<code>;</code>).</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">X</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span> <span class="token comment"># 表示X不为空</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Enter some text (RETURN to quit)"</span>
  <span class="token builtin class-name">read</span> X
  <span class="token builtin class-name">echo</span> <span class="token string">"You said: <span class="token variable">$X</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Note that running this script will end untidily:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./test2.sh
Enter some text <span class="token punctuation">(</span>RETURN to quit<span class="token punctuation">)</span>
fred
You said: fred
Enter some text <span class="token punctuation">(</span>RETURN to quit<span class="token punctuation">)</span>
wilma
You said: wilma
Enter some text <span class="token punctuation">(</span>RETURN to quit<span class="token punctuation">)</span>

You said:
$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>This can be tidied up with another test within the loop:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">X</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Enter some text (RETURN to quit)"</span>
  <span class="token builtin class-name">read</span> X
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">$X</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"You said: <span class="token variable">$X</span>"</span>
  <span class="token keyword">fi</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="case">Case</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>

<span class="token builtin class-name">echo</span> <span class="token string">"Please talk to me ..."</span>
<span class="token keyword">while</span> <span class="token builtin class-name">:</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">read</span> INPUT_STRING
  <span class="token keyword">case</span> <span class="token variable">$INPUT_STRING</span> <span class="token keyword">in</span>
	hello<span class="token punctuation">)</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"Hello yourself!"</span>
		<span class="token punctuation">;</span><span class="token punctuation">;</span>
	bye<span class="token punctuation">)</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"See you again!"</span>
		<span class="token builtin class-name">break</span>
		<span class="token punctuation">;</span><span class="token punctuation">;</span>
	*<span class="token punctuation">)</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"Sorry, I don't understand"</span>
		<span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token keyword">esac</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> 
<span class="token builtin class-name">echo</span> <span class="token string">"That's all folks!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="variables-part2">Variables-Part2</span></h3>
<p>The first set of variables we will look at are <code>$0 .. $9</code> and <code>$#</code>.<br>
The variable <code>$0</code> is the <em>basename</em> of the program as it was called.<br>
<code>$1 .. $9</code> are the first 9 additional parameters the script was called with.<br>
The variable <code>$@</code> is all parameters <code>$1 .. whatever</code>. The variable <code>$*</code>, is similar, but does not preserve any whitespace, and quoting, so “File with spaces” becomes “File” “with” “spaces”. This is similar to the <code>echo</code> stuff we looked at in <a href="https://www.shellscript.sh/first.html">A First Script</a>. As a general rule, use <code>$@</code> and avoid <code>$*</code>.<br>
<code>$#</code> is the number of parameters the script was called with.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token builtin class-name">echo</span> <span class="token string">"I was called with <span class="token variable">$#</span> parameters"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"My name is <span class="token variable">$0</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"My first parameter is <span class="token variable">$1</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"My second parameter is <span class="token variable">$2</span>"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"All parameters are <span class="token variable">$@</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Another interesting variable is <code>IFS</code>. This is the <em>Internal Field Separator</em>. The default value is <code>SPACE TAB NEWLINE</code>, but if you are changing it, it’s easier to take a copy, as shown:</p>
<hr>
<p><a href="https://www.shellscript.sh/eg/var5.sh.txt">var5.sh</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">old_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
<span class="token builtin class-name">echo</span> <span class="token string">"Please input some data separated by colons ..."</span>
<span class="token builtin class-name">read</span> x y z
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token variable">$old_IFS</span>
<span class="token builtin class-name">echo</span> <span class="token string">"x is <span class="token variable">$x</span> y is <span class="token variable">$y</span> z is <span class="token variable">$z</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>This script runs like this:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./ifs.sh
Please input some data separated by colons <span class="token punctuation">..</span>.
hello:how are you:today
x is hello y is how are you z is today<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Note that if you enter: “hello:how are you:today:my:friend” then the output would be:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./ifs.sh
Please input some data separated by colons <span class="token punctuation">..</span>.
hello:how are you:today:my:friend
x is hello y is how are you z is today:my:friend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="function">Function</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># A simple script with a function...</span>

<span class="token function-name function">add_a_user</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token variable">$1</span>
  <span class="token assign-left variable">PASSWORD</span><span class="token operator">=</span><span class="token variable">$2</span>
  <span class="token builtin class-name">shift</span><span class="token punctuation">;</span> <span class="token builtin class-name">shift</span><span class="token punctuation">;</span>
  <span class="token comment"># Having shifted twice, the rest is now comments ...</span>
  <span class="token assign-left variable">COMMENTS</span><span class="token operator">=</span><span class="token variable">$@</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Adding user <span class="token environment constant">$USER</span> ..."</span>
  <span class="token builtin class-name">echo</span> <span class="token function">useradd</span> <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable">$COMMENTS</span>"</span> <span class="token environment constant">$USER</span>
  <span class="token builtin class-name">echo</span> <span class="token function">passwd</span> <span class="token environment constant">$USER</span> <span class="token variable">$PASSWORD</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Added user <span class="token environment constant">$USER</span> (<span class="token variable">$COMMENTS</span>) with pass <span class="token variable">$PASSWORD</span>"</span>
<span class="token punctuation">}</span>

<span class="token comment">###</span>
<span class="token comment"># Main body of script starts here</span>
<span class="token comment">###</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Start of script..."</span>
add_a_user bob letmein Bob Holness the presenter
add_a_user fred badpassword Fred Durst the singer
add_a_user bilko worsepassword Sgt. Bilko the role model
<span class="token builtin class-name">echo</span> <span class="token string">"End of script..."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="recursion">Recursion</span></h2>
<p>Functions can be recursive - here’s a simple example of a factorial function:</p>
<hr>
<p><a href="https://www.shellscript.sh/eg/factorial.sh.txt">factorial.sh</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>

<span class="token function-name function">factorial</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token parameter variable">-gt</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 - <span class="token number">1</span><span class="token variable">`</span></span>
    <span class="token assign-left variable">j</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>factorial $i<span class="token variable">`</span></span>
    <span class="token assign-left variable">k</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $1 <span class="token punctuation">\</span>* $j<span class="token variable">`</span></span>
    <span class="token builtin class-name">echo</span> <span class="token variable">$k</span>
  <span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token number">1</span>
  <span class="token keyword">fi</span>
<span class="token punctuation">}</span>


<span class="token keyword">while</span> <span class="token builtin class-name">:</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Enter a number:"</span>
  <span class="token builtin class-name">read</span> x
  factorial <span class="token variable">$x</span>
<span class="token keyword">done</span>                  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>As promised, we will now briefly discuss using libraries between shell scripts. These can also be used to define common variables, as we shall see.</p>
<hr>
<p><a href="https://www.shellscript.sh/eg/common.lib.txt">common.lib</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># common.lib</span>
<span class="token comment"># Note no #!/bin/sh as this should not spawn </span>
<span class="token comment"># an extra shell. It's not the end of the world </span>
<span class="token comment"># to have one, but clearer not to.</span>
<span class="token comment">#</span>
<span class="token assign-left variable">STD_MSG</span><span class="token operator">=</span><span class="token string">"About to rename some files..."</span>

<span class="token function-name function">rename</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment"># expects to be called as: rename .txt .bak </span>
  <span class="token assign-left variable">FROM</span><span class="token operator">=</span><span class="token variable">$1</span>
  <span class="token assign-left variable">TO</span><span class="token operator">=</span><span class="token variable">$2</span>

  <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> *<span class="token variable">$FROM</span>
  <span class="token keyword">do</span>
    <span class="token assign-left variable">j</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $i $FROM<span class="token variable">`</span></span>
    <span class="token function">mv</span> <span class="token variable">$i</span> <span class="token variable">${j}</span><span class="token variable">$TO</span>
  <span class="token keyword">done</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><a href="https://www.shellscript.sh/eg/function2.sh.txt">function2.sh</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># function2.sh</span>
<span class="token builtin class-name">.</span> ./common.lib
<span class="token builtin class-name">echo</span> <span class="token variable">$STD_MSG</span>
<span class="token function">rename</span> .txt .bak<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><a href="https://www.shellscript.sh/eg/function3.sh.txt">function3.sh</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># function3.sh</span>
<span class="token builtin class-name">.</span> ./common.lib
<span class="token builtin class-name">echo</span> <span class="token variable">$STD_MSG</span>
<span class="token function">rename</span> .html .html-bak<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="hints-and-tips">Hints and tips</span></h3>
<blockquote>
<p>You may have heard it said, that, with *nix, “everything is a file” - it’s true.</p>
</blockquote>
<ul>
<li>强大的文本分析工具</li>
</ul>
<p><strong><code>grep</code></strong></p>
<p><strong><code>wc</code></strong> &amp;&amp; <strong><code>awk</code></strong></p>
<p>Consider <code>wc</code>, which counts the number of characters, lines, and words in a text file. Its output is:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wc</span> hello.c
<span class="token number">5</span>  <span class="token number">8</span> <span class="token number">67</span> hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>If we want to get the number of lines into a variable, simply using:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">NO_LINES</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">wc</span> <span class="token parameter variable">-l</span> hello.c<span class="token variable">`</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$NO_LINES</span>
<span class="token number">5</span> hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Because the output is space-padded, we can’t reliably get the number <code>102</code> into the string. Instead, we use the fact that <code>awk</code> works similarly to <code>scanf</code> in C - it strips unwanted whitespace. It puts these into variables <code>$1 $2 $3</code> etc. So we use this construct:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">NO_LINES</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">wc</span> <span class="token parameter variable">-l</span> hello.c <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{ print $1 }'</span> <span class="token variable">`</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$NO_LINES</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong><code>sed</code></strong></p>
<p>we can quickly use the <code>s/from/to/g</code> construct by invoking <code>sed</code>.For example:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> s/eth0/eth1/g file1 <span class="token operator">&gt;</span>  file2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>changes every instance of <code>eth0</code> in file1 to <code>eth1</code> in file2.</p>
<p>If we were only changing a single character, <code>tr</code> would be the tool to use, being smaller and therefore faster to load.<br>
Another thing that <code>tr</code> can’t do, is remove characters from a file:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">${SOMETHING}</span> <span class="token operator">|</span> <span class="token function">sed</span> s/<span class="token string">"bad word"</span>//g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This removes the phrase “bad word” from the variable <code>${SOMETHING}</code>. It may be tempting to say, “But <code>grep</code> can do that!” - grep only deals with whole lines. Consider the file:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This line is okay.
This line contains a bad word. Treat with care.
This line is fine, too.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Grep would remove the whole second line, leaving only a two-line file; sed would change the file to read:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This line is okay.
This line contains a <span class="token builtin class-name">.</span> Treat with care.
This line is fine, too.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="quick-referrence">quick referrence</span></h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>Run the previous command in the background</td>
<td><code>ls &amp;</code></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Logical AND</td>
<td><code>if [ "$foo" -ge "0" ] &amp;&amp; [ "$foo" -le "9"]</code></td>
</tr>
<tr>
<td>||</td>
<td>Logical OR</td>
<td>`if [ “$foo” -lt “0” ]</td>
</tr>
<tr>
<td>^</td>
<td>Start of line</td>
<td><code>grep "^foo"</code></td>
</tr>
<tr>
<td>$</td>
<td>End of line</td>
<td><code>grep "foo$"</code></td>
</tr>
<tr>
<td>=</td>
<td>String equality (cf. -eq)</td>
<td><code>if [ "$foo" = "bar" ]</code></td>
</tr>
<tr>
<td>!</td>
<td>Logical NOT</td>
<td><code>if [ "$foo" != "bar" ]</code></td>
</tr>
<tr>
<td>$$</td>
<td>PID of current shell</td>
<td><code>echo "my PID = $$"</code></td>
</tr>
<tr>
<td>$!</td>
<td>PID of last background command</td>
<td><code>ls &amp; echo "PID of ls = $!"</code></td>
</tr>
<tr>
<td>$?</td>
<td>exit status of last command</td>
<td><code>ls ; echo "ls returned code $?"</code></td>
</tr>
<tr>
<td>$0</td>
<td>Name of current command (as called)</td>
<td><code>echo "I am $0"</code></td>
</tr>
<tr>
<td>$1</td>
<td>Name of current command’s first parameter</td>
<td><code>echo "My first argument is $1"</code></td>
</tr>
<tr>
<td>$9</td>
<td>Name of current command’s ninth parameter</td>
<td><code>echo "My ninth argument is $9"</code></td>
</tr>
<tr>
<td>$@</td>
<td>All of current command’s parameters (preserving whitespace and quoting)</td>
<td><code>echo "My arguments are $@"</code></td>
</tr>
<tr>
<td>$*</td>
<td>All of current command’s parameters (not preserving whitespace and quoting)</td>
<td><code>echo "My arguments are $*"</code></td>
</tr>
<tr>
<td>-eq</td>
<td>Numeric Equality</td>
<td><code>if [ "$foo" -eq "9" ]</code></td>
</tr>
<tr>
<td>-ne</td>
<td>Numeric Inquality</td>
<td><code>if [ "$foo" -ne "9" ]</code></td>
</tr>
<tr>
<td>-lt</td>
<td>Less Than</td>
<td><code>if [ "$foo" -lt "9" ]</code></td>
</tr>
<tr>
<td>-le</td>
<td>Less Than or Equal</td>
<td><code>if [ "$foo" -le "9" ]</code></td>
</tr>
<tr>
<td>-gt</td>
<td>Greater Than</td>
<td><code>if [ "$foo" -gt "9" ]</code></td>
</tr>
<tr>
<td>-ge</td>
<td>Greater Than or Equal</td>
<td><code>if [ "$foo" -ge "9" ]</code></td>
</tr>
<tr>
<td>-z</td>
<td>String is zero length</td>
<td><code>if [ -z "$foo" ]</code></td>
</tr>
<tr>
<td>-n</td>
<td>String is not zero length</td>
<td><code>if [ -n "$foo" ]</code></td>
</tr>
<tr>
<td>-nt</td>
<td>Newer Than</td>
<td><code>if [ "$file1" -nt "$file2" ]</code></td>
</tr>
<tr>
<td>-d</td>
<td>Is a Directory</td>
<td><code>if [ -d /bin ]</code></td>
</tr>
<tr>
<td>-f</td>
<td>Is a File</td>
<td><code>if [ -f /bin/ls ]</code></td>
</tr>
<tr>
<td>-r</td>
<td>Is a readable file</td>
<td><code>if [ -r /bin/ls ]</code></td>
</tr>
<tr>
<td>-w</td>
<td>Is a writable file</td>
<td><code>if [ -w /bin/ls ]</code></td>
</tr>
<tr>
<td>-x</td>
<td>Is an executable file</td>
<td><code>if [ -x /bin/ls ]</code></td>
</tr>
<tr>
<td>( … )</td>
<td>Function definition</td>
<td><code>function myfunc() { echo hello }</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>debian12</title>
    <url>/2024/04/24/debian12/</url>
    <content><![CDATA[<h1><span id="debian12">debian12</span></h1>
<h2><span id="查看linux内核">查看linux内核</span></h2>
<ol>
<li>
<pre><code class="language-bash">uname -r
uname -a
<pre class="line-numbers language-none"><code class="language-none">
分别得到以下输出

```bash
6.1.0-17-amd64
Linux debianfj 6.1.0-17-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.69-1 (2023-12-30) x86_64 GNU/Linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

`6.1.0-17-amd64`是内核版本号，`x86_64`是系统架构，`Debian`是操作系统类型，`6.1.69-1 (2023-12-30)`是发行版信息

</code></pre>
</li>
<li>
<pre><code class="language-bash">cat /proc/version
<pre class="line-numbers language-none"><code class="language-none">
3. ```bash
   dmesg | less
   dmesg | grep linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

如果报错显示`dmesg: read kernel buffer failed: Operation not permitted`，可以使用`sudo sysctl -w kernel.dmesg_restrict=0`

但是我在这个debian12 上没有版本信息的输出，不清楚原因

</code></pre>
</li>
</ol>
<h2><span id="查看debian版本">查看debian版本</span></h2>
<p>对于debian而言，直接使用这个即可，在我的debian12 上输出的是<code>12.4</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/debian_version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然还有其他的，但是只会输出到<code>debian 12</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hostnamectl
<span class="token function">cat</span> /etc/issue
<span class="token function">cat</span> /etc/os-release
lsb_release <span class="token parameter variable">-crid</span>
<span class="token function">uname</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="静态ip设置">静态ip设置</span></h2>
<h3><span id="ip-a">ip a</span></h3>
<p>在Linux中，使用<code>ip a</code>命令可以查看网络接口的配置信息。以下是<code>ip a</code>输出的一些常见字段及其含义：</p>
<ol>
<li><strong><code>1: lo</code></strong>
<ul>
<li><code>1</code>: 接口编号或索引。</li>
<li><code>lo</code>: 接口的名称，这里是lo表示Loopback接口。</li>
</ul>
</li>
<li><strong><code>2: eth0</code></strong>
<ul>
<li><code>2</code>: 接口编号或索引。</li>
<li><code>eth0</code>: 接口的名称，这里是以太网接口。</li>
</ul>
</li>
<li><strong><code>inet 192.168.1.2/24</code></strong>
<ul>
<li><code>inet</code>: 表示IPv4地址。</li>
<li><code>192.168.1.2</code>: 接口的IPv4地址。</li>
<li><code>/24</code>: 表示<strong>子网掩码</strong>，这里是24位，表示前24位是网络部分。（255.255.255.0）</li>
</ul>
</li>
<li><strong><code>inet6 fe80::a00:27ff:fe8e:716f/64</code></strong>
<ul>
<li><code>inet6</code>: 表示IPv6地址。</li>
<li><code>fe80::a00:27ff:fe8e:716f</code>: 接口的IPv6地址。</li>
<li><code>/64</code>: 表示IPv6地址的前64位是网络部分。</li>
</ul>
</li>
<li><strong><code>link/ether 08:00:27:8e:71:6f</code></strong>
<ul>
<li><code>link/ether</code>: 表示物理地址。</li>
<li><code>08:00:27:8e:71:6f</code>: 接口的MAC地址。</li>
</ul>
</li>
<li><strong><code>brd ff:ff:ff:ff:ff:ff</code></strong>
<ul>
<li><code>brd</code>: 表示广播地址。</li>
<li><code>ff:ff:ff:ff:ff:ff</code>: 广播地址。</li>
</ul>
</li>
<li><strong><code>scope global</code></strong>
<ul>
<li><code>scope global</code>: 表示地址的作用域是全局可见的。</li>
</ul>
</li>
<li><strong><code>valid_lft forever preferred_lft forever</code></strong>
<ul>
<li><code>valid_lft</code>: 表示地址的有效期。</li>
<li><code>forever</code>: 表示永久有效。</li>
<li><code>preferred_lft</code>: 表示地址的首选有效期。</li>
</ul>
</li>
</ol>
<p>以上是<code>ip a</code>输出中常见的一些字段及其含义。具体的输出可能因系统和网络配置而异。</p>
<h3><span id="配置静态ip">配置静态ip</span></h3>
<p><strong>插好网线后</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>找到其中<code>&lt;&gt;</code>中带有<code>UP LOWER_UP</code>的<strong>以太网接口</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ens44f0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个就是我们在后面添加静态ip的接口</p>
<p>固定ip在<code>/etc/network/interfaces</code>里调整</p>
<p>调整后的例子</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">auto eth0
iface eth0 inet static
	address <span class="token number">192.168</span>.1.100
	netmask <span class="token number">255.255</span>.255.0
	gateway <span class="token number">192.168</span>.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解释：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">auto <span class="token operator">&lt;</span>interface_name<span class="token operator">&gt;</span>
iface <span class="token operator">&lt;</span>interface_name<span class="token operator">&gt;</span> inet static
address <span class="token operator">&lt;</span>desired_ip_address<span class="token operator">&gt;</span>
netmask <span class="token operator">&lt;</span>netmask_address<span class="token operator">&gt;</span>
gateway <span class="token operator">&lt;</span>default_gateway_address<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>编辑网络配置文件</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/network/interfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">auto enp0s31f6
iface enp0s31f6 inet static     <span class="token comment"># 网卡的名称(enp2s316)要写正确，否则配置无效</span>
  address <span class="token number">192.168</span>.0.3/24
  broadcast <span class="token number">192.168</span>.0.255
  network <span class="token number">192.168</span>.0.0
  gateway <span class="token number">192.168</span>.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>修改DNS服务器</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/resolv.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#nameserver 192.168.1.1    #注释存在的条目</span>
nameserver <span class="token number">8.8</span>.8.8         <span class="token comment">#添加新的dns条目</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>重启network服务</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart networking.service             <span class="token comment"># 重启网络服务</span>
<span class="token function">sudo</span> systemctl status networking.service              <span class="token comment"># 查看网络服务状态</span>
<span class="token function">sudo</span> <span class="token function">ifup</span> enp0s31f6                                   <span class="token comment"># 激活网络接口（debian12重启服务后，需要激活接口）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>测试网络连通性</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个可借鉴的脚本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">set</span> <span class="token parameter variable">-x</span>
<span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>



<span class="token comment"># 检查是否以 root 权限运行</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token environment constant">$EUID</span> <span class="token parameter variable">-ne</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">"请以 root 用户身份运行此脚本"</span> 
   <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>

<span class="token comment"># 设置网络接口名字，通常是 eth0 或 ens33</span>
<span class="token assign-left variable">interface</span><span class="token operator">=</span><span class="token string">"eno1"</span>

<span class="token comment"># 配置静态 IP 地址</span>
<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOL<span class="token bash punctuation"> <span class="token operator">&gt;</span> /etc/network/interfaces</span>
auto lo
iface lo inet loopback

auto <span class="token variable">$interface</span>
iface <span class="token variable">$interface</span> inet static
    address 10.254.46.25
    netmask 255.255.255.0
    gateway 10.254.46.254
EOL</span>

<span class="token comment"># 重启网络服务使更改生效</span>
<span class="token function">sudo</span> systemctl restart networking.service
<span class="token comment"># 检查 IP 地址是否配置成功</span>
<span class="token function">sudo</span> systemctl status networking.service
<span class="token function">sudo</span> <span class="token function">ifup</span> enp0s31f6

<span class="token builtin class-name">echo</span> <span class="token string">"IP 地址配置完成。"</span>


<span class="token builtin class-name">set</span> +x
<span class="token builtin class-name">set</span> +e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>debian12</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2024/04/24/docker/</url>
    <content><![CDATA[<p>linux上面docke安装：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> <span class="token parameter variable">-s</span> <span class="token function">docker</span> <span class="token parameter variable">--mirror</span> Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>自动化一件安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>un使用这个指令进行验证是否成功安装docker，也可以使用pull helloworld来验证</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull hello-world
<span class="token function">docker</span> run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>有的时候可能pull不成功，需要换一下国内源</p>
<p>编辑<code>/etc/docker/daemon.json</code>，可能没有这个文件，就直接<code>vim</code>创建就行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">{</span>
    <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span>,<span class="token string">"http://hub-mirror.c.163.com"</span><span class="token punctuation">]</span>,
    <span class="token string">"live-restore"</span><span class="token builtin class-name">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后重启<code>docker</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>添加用户至docker用户组，这样就可以不用每次都sudo了，docker的使用是需要docker权限的</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加docker用户组，一般已存在，不需要执行</span>
<span class="token function">sudo</span> <span class="token function">groupadd</span> <span class="token function">docker</span>
<span class="token comment"># 将登陆用户加入到docker用户组中</span>
<span class="token function">sudo</span> gpasswd <span class="token parameter variable">-a</span> <span class="token environment constant">$USER</span> <span class="token function">docker</span>
<span class="token comment"># 添加读写权限</span>
<span class="token function">chmod</span> o+rw /var/run/docker.sock
<span class="token comment"># 更新用户组</span>
newgrp <span class="token function">docker</span>
<span class="token comment"># 测试docker命令是否可以使用sudo正常使用</span>
<span class="token function">docker</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以直接</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">usermod</span> <span class="token parameter variable">-aG</span> <span class="token function">docker</span> hj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>docker 拉取ubuntu镜像</p>
<p>首先去官网找对应的版本</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https://hub.docker.com/_/ubuntu/tags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后运行pull</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull ubuntu:jammy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>运行镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span> ubuntu-test ubuntu：jammy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进入一个容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器名或容器id /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除已经运行的容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">rm</span> 容器名或容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token punctuation">[</span>option<span class="token punctuation">]</span> 镜像吗 <span class="token punctuation">[</span>向容器中传入的命令<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>常用参数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-i</span> 表示以“交互模式”运行容器
<span class="token parameter variable">-t</span> 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。
<span class="token parameter variable">--name</span> 为创建的容器命名
<span class="token parameter variable">-v</span> 表示目录映射关系<span class="token punctuation">(</span>前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录<span class="token punctuation">)</span>，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。
<span class="token parameter variable">-d</span> 在run后面加上-d参数,则会创建一个守护式容器在后台运行<span class="token punctuation">(</span>这样创建容器后不 会自动登录容器，如果只加-i <span class="token parameter variable">-t</span> 两个参数，创建后就会自动进去容器<span class="token punctuation">)</span>。
<span class="token parameter variable">-p</span> 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射
<span class="token parameter variable">-e</span> 为容器设置环境变量
<span class="token parameter variable">--network</span><span class="token operator">=</span>host 表示将主机的网络环境映射到容器中，容器的网络与主机相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一个交互式容器，并命名为myUbuntu</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>myUbuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在容器中可以随意执行linux命令，就是一个ubuntu的环境，当执行exit命令退出时，该容器也随之停止。</p>
<p>创建一个守护式容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>myUbuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建一个守护式容器:如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。</p>
<p>进入已经运行的容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>myUbuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看容器</p>
<p>列出本机正在运行的容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出本机所有容器，包括已经终止运行的</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">ls</span> <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>停止容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container stop 容器名或容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动一个已经停止的容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container start 容器名或容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>kill掉一个已经在运行的容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">kill</span> 容器名或容器y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> container <span class="token function">rm</span> 容器名或容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将容器保存为镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit 容器名 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>镜像备份与迁移</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> save <span class="token parameter variable">-o</span> 保存的文件名 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对方拿到镜像文件后，将镜像文件加载到bendi</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> load <span class="token parameter variable">-i</span> ./centos.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi 镜像名或者镜像id
<span class="token function">docker</span> image <span class="token function">rm</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所有容器都会和宿主机共享同一个内核，但它们在操作系统层面相互隔离，相当于在同一个内核上运行多个隔离的用户空间。</p>
<p>所以<code>uname -r</code>的结果是一样的，乐。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>conda和pip</title>
    <url>/2024/04/24/conda%E5%92%8Cpip/</url>
    <content><![CDATA[<h2><span id="conda和pip">conda和pip</span></h2>
<blockquote>
<p>其实就是一个虚拟环境</p>
</blockquote>
<p><code>conda</code>安装</p>
<p>找到对应的版本，具体哪个镜像得看网络链接情况</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.bfsu.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh --no-check-certificate
<span class="token function">wget</span> https://repo.anaconda.com/archive/Anaconda3-2024.02-1-Linux-x86_64.sh
<span class="token function">bash</span> Anaconda3-2023.03-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>重新加载会自动添加<code>.bashrc</code>文件，也可以手动添加</p>
<p>升级<code>conda</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda update <span class="token parameter variable">-n</span> base <span class="token parameter variable">-c</span> defaults conda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一次使用的时候需要激活<code>conda base</code>环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后状态栏开头用户名前出现了<code>(base)</code>表示当前的是<code>base</code>环境</p>
<p>查看当前的虚拟环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda info <span class="token parameter variable">-e</span>
conda <span class="token function">env</span> list
conda info <span class="token parameter variable">--envs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> env_name <span class="token assign-left variable">python</span><span class="token operator">=</span>versioon <span class="token comment"># -n name</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda remove env_name <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>clone环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clone create <span class="token parameter variable">-n</span> new_env_name <span class="token parameter variable">--clone</span> old_env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进入环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda activate env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>退出环境</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为环境添加/删除包</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> package
conda <span class="token function">install</span> <span class="token assign-left variable">package</span><span class="token operator">=</span>version

conda uninstall package<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>更新库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda update <span class="token parameter variable">--all</span>

conda update python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>依据<code>requirements.txt</code>批量安装包</p>
<p><code>pip</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token parameter variable">-r</span> path_to_requirements_file/requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>conda</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda isntall --yes--file path_to_requirements_file/requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>导出环境配置</p>
<p><code>pip</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip freeze <span class="token operator">&gt;</span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>conda</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda list <span class="token parameter variable">-e</span> <span class="token operator">&gt;</span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>conda 和 pip</tag>
      </tags>
  </entry>
  <entry>
    <title>java多版本管理</title>
    <url>/2024/04/24/java%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1><span id="java多版本管理">java多版本管理</span></h1>
<blockquote>
<p>适用于ubuntu</p>
</blockquote>
<p>检查可用的apt中的openjdk源</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> --names-only search <span class="token string">"openjdk-.*jre$"</span>
Sorting<span class="token punctuation">..</span>. Done
Full Text Search<span class="token punctuation">..</span>. Done
openjdk-11-jre/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">11.0</span>.22+7-0ubuntu2~20.04.1 amd64
  OpenJDK Java runtime, using Hotspot JIT

openjdk-13-jre/focal-updates,focal-updates,focal-updates <span class="token number">13.0</span>.7+5-0ubuntu1~20.04 amd64
  OpenJDK Java runtime, using Hotspot JIT

openjdk-16-jre/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">16.0</span>.1+9-1~20.04 amd64
  OpenJDK Java runtime, using Hotspot JIT

openjdk-17-jre/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">17.0</span>.10+7-1~20.04.1 amd64
  OpenJDK Java runtime, using Hotspot JIT

openjdk-21-jre/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates,now <span class="token number">21.0</span>.2+13-1~20.04.1 amd64 <span class="token punctuation">[</span>installed<span class="token punctuation">]</span>
  OpenJDK Java runtime, using Hotspot JIT

openjdk-8-jre/focal-security,focal-security,now 8u402-ga-2ubuntu1~20.04 amd64 <span class="token punctuation">[</span>installed<span class="token punctuation">]</span>
  OpenJDK Java runtime, using Hotspot JIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装jre</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-21-jre
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-8-jre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用<code>update-alternatives</code>管理多个版本</p>
<ul>
<li>
<p>查看linux服务器是否拥有JDK的软链接</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">update-alternatives <span class="token parameter variable">--config</span> <span class="token function">java</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>如果没有，那就使<code>update-alternatives --install</code>选项创建软链接</p>
</li>
<li>
<p>修改java版本配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> update-alternatives <span class="token parameter variable">--config</span> <span class="token function">java</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>选择相应的版本即可</p>
</li>
</ul>
<p>同理安装jdk</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> --names-only search <span class="token string">"openjdk-.*jdk*$"</span>
Sorting<span class="token punctuation">..</span>. Done
Full Text Search<span class="token punctuation">..</span>. Done
openjdk-11-jdk/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">11.0</span>.22+7-0ubuntu2~20.04.1 amd64
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span>

openjdk-13-jdk/focal-updates,focal-updates,focal-updates <span class="token number">13.0</span>.7+5-0ubuntu1~20.04 amd64
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span>

openjdk-16-jdk/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">16.0</span>.1+9-1~20.04 amd64
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span>

openjdk-17-jdk/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates <span class="token number">17.0</span>.10+7-1~20.04.1 amd64
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span>

openjdk-21-jdk/focal-updates,focal-security,focal-updates,focal-security,focal-security,focal-updates,now <span class="token number">21.0</span>.2+13-1~20.04.1 amd64 <span class="token punctuation">[</span>installed<span class="token punctuation">]</span>
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span>

openjdk-8-jdk/focal-security,focal-security 8u402-ga-2ubuntu1~20.04 amd64
  OpenJDK Development Kit <span class="token punctuation">(</span>JDK<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装jdk</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-21-jdk
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-8-jdk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用<code>update-alternatives</code>管理多个版本，记得sudo</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ update-alternatives <span class="token parameter variable">--config</span> javac
There are <span class="token number">2</span> choices <span class="token keyword">for</span> the alternative javac <span class="token punctuation">(</span>providing /usr/bin/javac<span class="token punctuation">)</span>.

  Selection    Path                                          Priority   Status
------------------------------------------------------------
  <span class="token number">0</span>            /usr/lib/jvm/java-21-openjdk-amd64/bin/javac   <span class="token number">2111</span>      auto mode
  <span class="token number">1</span>            /usr/lib/jvm/java-21-openjdk-amd64/bin/javac   <span class="token number">2111</span>      manual mode
* <span class="token number">2</span>            /usr/lib/jvm/java-8-openjdk-amd64/bin/javac    <span class="token number">1081</span>      manual mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置<code>JAVA_HOME</code>等环境变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/lib/jvm/java-1.8.0-openjdk-amd64
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这个在用到的时候还是得自己手动修改</p>
</blockquote>
<p>安装oracle家的java，先本地下载再scp上去</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> *jdk*
jdk-8u101-linux-x64.tar.gz
$ <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8u101-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>设置环境变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>这里在自己根目录下面设置，可以避免影响系统环境</p>
</blockquote>
<p>在最后面添加：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/home/hj/jdk1.8.0_101
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>
<span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar
<span class="token builtin class-name">export</span> JAVA_HOME
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>
<span class="token builtin class-name">export</span> CLASSPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后<code>source ~/.profile</code>即可。当然写到<code>.bashrc</code>也行，不同功能罢了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter</title>
    <url>/2024/04/24/jupyter/</url>
    <content><![CDATA[<h1><span id="jupyter">jupyter</span></h1>
<h2><span id="安装配置">安装配置</span></h2>
<h3><span id="ipython-安装">ipython 安装</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用时直接在命令行输入<code>ipython</code>即可</p>
<blockquote>
<p>这里还有一些ipython的基本用法和常用快捷键，留个坑</p>
</blockquote>
<h3><span id="jupyter-安装">jupyter 安装</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> jupyter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装完成后使用时直接在命令行输入<code>jupyter notebook</code>即可</p>
<h3><span id="jupyter-简单配置">jupyter 简单配置</span></h3>
<ul>
<li>设置密码</li>
</ul>
<p>打开ipython：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">from</span> jupyter_server<span class="token punctuation">.</span>auth <span class="token keyword">import</span> passwd

In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> passwd<span class="token punctuation">(</span><span class="token punctuation">)</span>
Enter password<span class="token punctuation">:</span> 
Verify password<span class="token punctuation">:</span> 
Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'...'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Out[2]后面的字符即为加密后的密码，新建<code>jupyter_config.py</code>文件，输入一下内容</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 加密后的密码：</span>
c<span class="token punctuation">.</span>NotebookApp<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">u'argon2:$argon2id$v=19$m=10240,t=10,p=8$3EmERi7e2EI60W3NzYQWsg$hZZas4aucibWghcucqSFYiRu1Mt8JdiGpnZFiPvZCvM'</span>

<span class="token comment"># :: 绑定所有ip地址，包括IPv4/IPv6地址</span>
<span class="token comment"># 如果只想绑定某个ip地址，改成对应的ip即可</span>
c<span class="token punctuation">.</span>NotebookApp<span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">'::'</span>

<span class="token comment"># 绑定的端口号，如果该端口已经被占用</span>
<span class="token comment"># 会自动使用下一个端口号10000</span>
c<span class="token punctuation">.</span>NotebookApp<span class="token punctuation">.</span>port <span class="token operator">=</span> <span class="token number">9999</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动时使用<code>jupyter notebook --config=jupyter_config.py</code><br>
然后再浏览器进入网址：<code>http://127.0.0.1:9999/tree</code>即可</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>hammingDistance</title>
    <url>/2023/05/25/hammingDistance/</url>
    <content><![CDATA[<p>分享一下大作业优化的技巧</p>
<span id="more"></span>
<h1><span id="__uint128_t_"><code>__uint128_t_</code></span></h1>
<p>最近越来越多的协议会定义 16 字节长的整形，gcc 在 4.6 以上版本就可以使用 __int128_t &amp; __uint128_t 了。</p>
<p>但需要注意的是，_uint128_t &amp; __int128_t 仅对 64 位程序才有定义，因此如果编译选项中加入了 -m32，会出现找不到定义的编译错误。</p>
<p>另外 _uint128_t &amp; __int128_t  并非 c/c++ 标准，所以 gcc 目前只支持基本运算符的操作，printf 这些都需要另外实现。</p>
<h1><span id="快速计算汉明距离">快速计算汉明距离</span></h1>
<blockquote>
<p>在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p>
<p>汉明距离是以<strong>理查德・卫斯里・汉明</strong>的名字命名的。在通信传输过程中，累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明距离在包括信息论、编码理论、密码学等领域都有应用。</p>
</blockquote>
<p>对于两个字符串计算汉明距离，那肯定也就只能是逐位比较</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//s1,s2为两个字符串，M为这两个字符串的长度</span>
<span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> l1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l1 <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么这样肯定是很慢的，如果可以转化两个整型的数，我们很容易想到利用到异或运算。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__uint128_t fingerprint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sumsignedweight <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样可以转换最高128位的两个01字符串。</p>
<p>那么就可以利用<code>^</code>运算来就算汉明距离了,由于异或运算的性质，得到的c的数位上为1说明ab的对应位不相同，反之则相同，那么我们就之需要计算c的二进制表示中数位为1的数目。这里可以按位采取<code>&amp;</code>运算。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        c <span class="token operator">=</span> c <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>布莱恩·克尼根算法</strong></p>
<p>我们先观察如下一个现象：对于任意一个非零的二进制数 <code>a</code>（将其看作无符号数），考虑 <code>a</code> 和 <code>a-1</code> 的关系。由于 <code>a</code> 非零，那么 <code>a</code> 中总有一些位为 <code>1</code>。假设 <code>a</code> 中最低位的 <code>1</code> 处于从右向左数的第 <code>N</code> 位。那么，<code>a</code> 的第 <code>N</code> 位以及第 <code>N</code> 位以后的每一位的值和 <code>a-1</code> 的第 <code>N</code> 位及第 <code>N</code> 位以后的每一位的值均不同。</p>
<p>举个例子就很容易理解了。我们以 8 位数来描述。假设 <code>a=10010000</code>，根据上述描述，从右往左数的第一个 <code>1</code> 出现在第 <code>5</code> 位，那么有 <code>N=5</code>。同时可以计算出 <code>a-1=10001111</code>，可以看到，从第 <code>N</code> 位开始，<code>a</code> 的后缀是 <code>10000</code>，而 <code>a-1</code> 的后缀是 <code>01111</code>。满足上述描述的现象。</p>
<p>进一步地，我们可以发现，如果对 <code>a</code> 和 <code>a-1</code> 进行与操作，就会直接消去位于最后一位，也就是第 <code>N</code> 位的 <code>1</code>。还以上面的 <code>a</code> 为例，<code>a &amp; (a-1)=10000000</code>。可以看到，我们不需要遍历，而是通过一次运算，就可以把 <code>a</code> 中的最后一个 <code>1</code> 消掉。如果我们一直重复这项操作，那么 <code>a</code> 里有多少个 <code>1</code>，我们就仅需要多少次 <code>a &amp; (a-1)</code> 的操作，就能把 <code>a</code> 化为 <code>0</code> 了。而这个操作的次数正是我们所要求的。</p>
<p>那么计算汉明距离就可以改进为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大作业优化</tag>
      </tags>
  </entry>
  <entry>
    <title>mariadb</title>
    <url>/2024/04/24/mariadb/</url>
    <content><![CDATA[<h2><span id="mariadb升级">mariadb升级</span></h2>
<blockquote>
<p>官网</p>
<p><a href="https://mariadb.com/kb/en/upgrading-from-mariadb-10-11-to-mariadb-11-0/">Upgrading from MariaDB 10.11 to MariaDB 11.0 - MariaDB Knowledge Base</a></p>
</blockquote>
<h3><span id="备份数据库">备份数据库</span></h3>
<p>备份数据库数据</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> --all-databases <span class="token operator">&gt;</span> /home/alldb.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>备份配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /etc/mysql/my.cnf /etc/mysql/my.cnf.bak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>停止数据库运行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> mysql stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>如果service 命令找不到，直接/sbin/service</p>
</blockquote>
<h3><span id="删除数据库">删除数据库</span></h3>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> purge mariadb-server
<span class="token function">apt</span> purge mariadb-client

<span class="token function">apt</span> remove mariadb*
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> mariadb.list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="安装新版本数据库">安装新版本数据库</span></h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-LsS</span> <span class="token parameter variable">-O</span> https://downloads.mariadb.com/MariaDB/mariadb_repo_setup
<span class="token function">sudo</span> <span class="token function">bash</span> mariadb_repo_setup --mariadb-server-version<span class="token operator">=</span><span class="token number">11.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>11.2为希望更新到的版本</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> update
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> mariadb-server mariadb-client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="数据恢复">数据恢复</span></h3>
<ul>
<li>恢复配置</li>
</ul>
<p>查看配置是否丢失,如果出现丢失，拿最开始备份的配置恢复</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /etc/mysql/my.cnf.bak /etc/mysql/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>恢复用户和数据</li>
</ul>
<p>登录查看用户、存储过程、数据等，出现丢失，用户可以重新创建、数据拿最初的备份恢复</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>/home/alldb.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="测试">测试</span></h3>
<p>首先给数据库中添加一些数据</p>
<ol>
<li>
<p><strong>登录 MariaDB：</strong> 使用以下命令登录到 MariaDB：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后系统将提示您输入密码。</p>
</li>
<li>
<p><strong>创建数据库：</strong> 在 MariaDB 中创建一个新的数据库。替换 <code>your_database</code> 为您想要创建的数据库名称。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> your_database<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><strong>选择数据库：</strong> 选择您刚创建的数据库。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> your_database<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><strong>创建表：</strong> 创建您需要的表结构。以下是一个简单的例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> users <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请根据您的需求创建相应的表。</p>
</li>
<li>
<p><strong>插入数据：</strong> 插入一些初始数据。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> email<span class="token punctuation">)</span> <span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'user1'</span><span class="token punctuation">,</span> <span class="token string">'user1@example.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'user2'</span><span class="token punctuation">,</span> <span class="token string">'user2@example.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>替换这些值为您实际希望插入的数据。</p>
</li>
<li>
<p><strong>查看数据：</strong> 可以运行 <code>SELECT</code> 查询来确保数据已成功插入。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<ul>
<li>最后备份完成后进行验证：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> your_database<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mariadb升级</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab0实验报告</title>
    <url>/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab0">lab0</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-01">Thinking 0.1</span></h3>
<ul>
<li>
<p>在前述已初始化的 <code>~/learnGit </code>目录下，创建一个名为 <code>README.txt</code> 的文件。执 行命令 <code>git status &gt; Untracked.txt</code>（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313183854380.png" alt="image-20240313183854380"></p>
</li>
<li>
<p>在<code>README.txt</code>文件中添加任意文件内容，然后使用 <code>add</code> 命令，再执行命令<code> git status &gt; Stage.txt</code>。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184010190.png" alt="image-20240313184010190"></p>
</li>
<li>
<p>提交 <code>README.txt</code>，并在提交说明里写入自己的学号</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184040344.png" alt="image-20240313184040344"></p>
</li>
<li>
<p>执行命令 <code>cat Untracked.txt</code> 和 <code>cat Stage.txt</code>，对比两次运行的结果，体会 <code>README.txt</code> 两次所处位置的不同。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184130590.png" alt="image-20240313184130590"></p>
<p>不一样。第一次是在工作区添加了文件，没有提交的暂存区。而第二次提交到了暂存区，只是没有commit到HEAD。而由于都没有进行commit ，因此都没有跟踪，于是提示是为跟踪的文件。</p>
</li>
</ul>
<h3><span id="thinking-02">Thinking 0.2</span></h3>
<ul>
<li>
<p>仔细看看0.10，思考一下箭头中的 add the file 、 stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314115041772.png" alt="image-20240314115041772"></p>
<p>add the file : 对应<code>git add</code></p>
<p>stage the file : 对应<code>git commit</code></p>
<p>commit : 对应<code>git checkout</code></p>
</li>
</ul>
<h3><span id="thinking-03">Thinking 0.3</span></h3>
<ul>
<li>
<p>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314121507355.png" alt="image-20240314121507355"></p>
<blockquote>
<p>使用 <code>git restore print.c</code>即可</p>
</blockquote>
</li>
<li>
<p>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314142825497.png" alt="image-20240314142825497"></p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> restore <span class="token parameter variable">--staged</span> print.c
<span class="token function">git</span> restore print.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
</li>
<li>
<p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314143326431.png" alt="image-20240314143326431"></p>
<blockquote>
<p>使用<code>git restore --staged hello.txt</code>即可</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-04">Thinking 0.4</span></h3>
<ul>
<li>
<p>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件</p>
</li>
<li>
<p>在文件里加入 Testing 1， git add， git commit，提交说明记为 1。</p>
</li>
<li>
<p>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160243954.png" alt="image-20240314160243954"></p>
</li>
<li>
<p>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为3 的哈希值</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160309950.png" alt="image-20240314160309950"></p>
<blockquote>
<p>进行操作后可以看到确实有了三次提交的记录</p>
</blockquote>
</li>
<li>
<p>进行版本回退。执行命令 git reset --hard HEAD^ 后，再执行 git log，观察其变化</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160417333.png" alt="image-20240314160417333"></p>
<blockquote>
<p>此时git log的第一项是2，相当于撤销了第三次提交</p>
</blockquote>
</li>
<li>
<p>找到提交说明为 1 的哈希值，执行命令 git reset --hard <hash> 后，再执行 git log，观察其变化。</hash></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160510381.png" alt="image-20240314160510381"></p>
<blockquote>
<p>强制撤销到1时候的版本，因此git log只能看到1的提交记录</p>
</blockquote>
</li>
<li>
<p>现在已经回到了旧版本，为了再次回到新版本，执行 git reset --hard <hash>，再执行 git log，观察其变化。</hash></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314161613264.png" alt="image-20240314161613264"></p>
<blockquote>
<p>可以看到又恢复了原样，也就是回到了新版</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-05">Thinking 0.5</span></h3>
<ul>
<li>
<p>执行如下命令，并查看结果</p>
<ul>
<li>echo first</li>
<li>echo second &gt; output.txt</li>
<li>echo third &gt; output.txt</li>
<li>echo forth &gt;&gt; output.txt</li>
</ul>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314161945989.png" alt="image-20240314161945989"></p>
<blockquote>
<p><code>&gt;</code>是覆盖写入</p>
<p><code>&gt;&gt;</code>是追加指令</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-06">Thinking 0.6</span></h3>
<ul>
<li>
<p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手） . 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo <code>echo Shell Start</code> 效果是否有区别; echo echo $c&gt;file1与 echo <code>echo $c&gt;file1</code> 效果是否有区别</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314162443513.png" alt="image-20240314162443513"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314162939850.png" alt="image-20240314162939850"></p>
<blockquote>
<p>前两条指令的效果是有区别的，而后两条指令的效果是没有区别</p>
<p>加上反引号相当于将反引号的内容重定向作为参数</p>
<p>因此</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Shell Start <span class="token comment"># 标准输出为Shell Start</span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> Shell Start<span class="token variable">`</span></span> <span class="token comment"># 后面指令的标准输出为Shell Start ，作为echo的参数，因此输出还是Shell Start</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token operator">&gt;</span>file1 <span class="token comment"># 相当于是echo指令输出了echo $c,其中$c 为 3，然后重定向到文件中</span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $c<span class="token operator">&gt;</span>file1<span class="token variable">`</span></span><span class="token comment"># 相当于是首先`echo $c&gt;file1` ,将$c的值重定向到了file1中，标准输出为空，将标准输出作为前面的echo的参数，因此输出为空，但是echo会默认添加一个换行符，因此还有一个换行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</blockquote>
</li>
</ul>
<h2><span id="难点分析">难点分析</span></h2>
<h3><span id="cli">CLI</span></h3>
<blockquote>
<p>第一个难点在于如果之前习惯了使用<code>GUI</code>界面，刚开始接触这种命令行界面是不够熟悉的。</p>
<p>依稀记得自己第一次接触<code>ubuntu</code>时探索了好久好久，当时使用的还是图形化界面。</p>
</blockquote>
<p>命令行界面(CLI)是基于文本的界面，可以在其中输入与计算机操作系统交互的命令。CLI在默认Shell的帮助下运行，该Shell位于操作系统和用户之间。</p>
<p>Shell负责处理各种任务，例如命令解析、环境管理和流程执行等。</p>
<p>此外还可以自定义Shell环境。为此，可以设置环境变量、定义别名(较长命令的快捷方式等)以及为自动化或重复任务创建Shell脚本。</p>
<ul>
<li>命令的工作原理</li>
</ul>
<p>在CLI中输入命令是，系统会执行以下步骤：</p>
<ol>
<li>Shell命令行解释器解析输入的命令以了解其结构，并且分离命令名称、选项和参数</li>
<li>Shell在其可用命令列表中查找命令名称。命令名称代表用户希望操作系统执行的操作</li>
<li>Shell搜索系统的PATH变量(系统文件所在的目录列表)，以查找与该命令关联的相应文件</li>
<li>CLI Shell会调用相应的文件，并且传递任何指定的选项和参数作为输入。</li>
<li>操作系统执行所需的操作</li>
<li>此操作可能会生成输出，例如信息性消息、错误消息、请求的数据或操作结果</li>
<li>CLI Shell会显示输出，因此可以看到命令的结果</li>
</ol>
<p>CLI Shell循环运行，等待输入另一条指令。</p>
<h3><span id="linux">Linux</span></h3>
<p>Linux与Windows命令行的一些指令的差异可能会让人感到措手不及。比如<code>bash</code>的指令和<code>powershell</code>以及<code>cmd</code>的指令是有比较大的差异的可能让人感到不熟悉。</p>
<p>同时也不熟练的使用Linux的一些基本操作。包括<code>sudo</code>等</p>
<h3><span id="vim">Vim</span></h3>
<p>由于使用<code>CLI</code>的缘故，我们没有很好的图形化文本编辑器，于是需要使用<code>Vim</code>或者<code>emacs</code>等文本编辑工具。</p>
<p>对于Vim的快捷键以及工作模式不熟悉会带来比较大的难点。</p>
<blockquote>
<p>对此我强烈推荐跟着<code>vimtutor</code>走一遍，基本上可以熟悉大多数的操作，以及基本的几个vim模式</p>
</blockquote>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174337175.png" alt="image-20240314174337175"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174412381.png" alt="image-20240314174412381"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174441142.png" alt="image-20240314174441142"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174505883.png" alt="image-20240314174505883"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174529894.png" alt="image-20240314174529894"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174700133.png" alt="image-20240314174700133"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174717116.png" alt="image-20240314174717116"></p>
<p>其实简单的用法也只有</p>
<ul>
<li>输入<code>i</code>进入编辑模式</li>
<li>点击<code>Esa</code>退出编辑模式</li>
<li>输入<code>:w</code>保存，<code>:wq</code>保存并退出</li>
</ul>
<p>基本上可以完成最基本的使用，甚至上下左右可以直接使用箭头键，都不需要使用到<code>hjkl</code>。</p>
<h3><span id="gcc">GCC</span></h3>
<p>对于<code>gcc</code>的基本使用指令不够了解。</p>
<blockquote>
<p><code>tldr</code>是个非常好用的命令用法查询工具，狠狠种草</p>
</blockquote>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314175039544.png" alt="image-20240314175039544"></p>
<p>可以看到<code>gcc</code>的基本用法</p>
<ul>
<li><code>gcc</code>是一个C语言编译器</li>
<li><code>g++</code>是一个C++语言编译器</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：gcc <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span class="token punctuation">..</span>.
选项：
<span class="token parameter variable">-c</span> 仅编译，不链接
<span class="token parameter variable">-o</span> 指定输出文件
<span class="token parameter variable">-E</span> 预处理
<span class="token parameter variable">-S</span> 汇编
<span class="token parameter variable">-l</span> 指定库文件
<span class="token parameter variable">-L</span> 指定库文件路径
<span class="token parameter variable">-I</span> Path/to/head/file 指定头文件路径
<span class="token parameter variable">-D</span> 定义宏
<span class="token parameter variable">-wall</span> 显示所有警告
<span class="token parameter variable">-g</span> 生成调试信息
<span class="token parameter variable">-std</span><span class="token operator">=</span>c99 指定C语言标准
参数：
file.c 源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world.o目标文件</span>
gcc <span class="token parameter variable">-E</span> hello_world.c  <span class="token comment">#预处理hello_world.c文件</span>
gcc <span class="token parameter variable">-S</span> hello_world.c  <span class="token comment">#汇编hello_world.c文件</span>
gcc <span class="token parameter variable">-o</span> hello_world hello_world.c <span class="token parameter variable">-lm</span>  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件，并链接数学库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时编译多个文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world.o和hello_world2.o目标文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-o用于指定要生成的结果文件，后面跟的就是结果文件名字。o是output的意思，不是目标的意思。结果文件可能是预处理文件、汇编文件、目标文件或者最终可执行文件。</p>
</blockquote>
<h3><span id="git">Git</span></h3>
<blockquote>
<p>git真是一个非常好用的版本管理工具，发明者太强了没办法！</p>
</blockquote>
<p>相信同学们经过<code>oopre</code>后基本上对于<code>git</code>的基本用法已经了如指掌了，这里包括</p>
<ul>
<li>git add .	添加修改文件到暂存区</li>
<li>git commit -m “message”提交文件到版本库</li>
<li>git push 提交到远程仓库</li>
</ul>
<p>同时还包括一些基本的分支的操作</p>
<ul>
<li>git checkout -b new_branch</li>
</ul>
<p>但是<code>git</code>的更多高阶的用法其实还是不够熟悉，大多数还是需要查询相关资料进行使用。</p>
<p>这里推荐一个可视化git学习网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>
<blockquote>
<p>同时我这里整理了一下一些git 常用的指令</p>
</blockquote>
<p><strong>基本操作</strong></p>
<ul>
<li><code>git init</code>初始化一个仓库</li>
<li><code>git clone</code>克隆一个仓库</li>
<li><code>git add</code>添加文件到暂存区</li>
<li><code>git commit</code>提交文件到仓库</li>
<li><code>git status</code>查看仓库状态</li>
<li><code>git diff</code>查看文件差异</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git reset</code>重置仓库</li>
<li><code>git rm</code>删除文件</li>
<li><code>git mv</code>移动文件</li>
<li><code>git branch</code>查看分支</li>
</ul>
<p><strong>分支操作</strong></p>
<ul>
<li><code>git branch</code>查看分支</li>
<li><code>git checkout</code>切换分支</li>
<li><code>git merge</code>合并分支</li>
<li><code>git rebase</code>变基分支</li>
<li><code>git cherry-pick</code>挑选提交</li>
<li><code>git tag</code>标记提交</li>
<li><code>git stash</code>暂存工作区</li>
<li><code>git fetch</code>获取远程分支</li>
<li><code>git pull</code>拉取远程分支</li>
<li><code>git push</code>推送远程分支</li>
<li><code>git remote</code>管理远程仓库</li>
<li><code>git submodule</code>管理子模块</li>
<li><code>git worktree</code>管理工作树</li>
<li><code>git reflog</code>查看引用日志</li>
<li><code>git bisect</code>二分查找</li>
<li><code>git blame</code>查看文件作者</li>
<li><code>git grep</code>查找文件内容</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git show</code>查看提交详情</li>
</ul>
<p><strong>高级操作</strong></p>
<ul>
<li><code>git filter-branch</code>过滤分支</li>
<li><code>git subcommand</code>子命令</li>
<li><code>git rerere</code>重用冲突解决</li>
<li><code>git gc</code>垃圾回收</li>
<li><code>git fsck</code>检查仓库</li>
<li><code>git prune</code>删除无用对象</li>
</ul>
<p><strong>git 版本回退</strong></p>
<ul>
<li><code>git reset --hard HEAD^</code>回退到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>回退到上上一个版本</li>
<li><code>git reset --hard HEAD~100</code>回退到上100个版本</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reflog</code>查看命令历史</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reset --hard HEAD@{n}</code>回退到指定版本</li>
<li><code>git reset --hard ORIG_HEAD</code>回退到上一个版本</li>
<li><code>git reset --hard</code>回退到上一个版本</li>
</ul>
<p><strong>配置</strong></p>
<ul>
<li><code>git config --global user.name "Your Name"</code>设置用户名</li>
<li>`git config --global user.email "</li>
<li><code>git config --global core.editor "vim"</code>设置编辑器</li>
<li><code>git config --global merge.tool "vimdiff"</code>设置合并工具</li>
<li><code>git config --global color.ui true</code>设置颜色</li>
<li><code>git config --global alias.st status</code>设置别名</li>
<li><code>git config --global alias.co checkout</code>设置别名</li>
<li><code>git config --global alias.ci commit</code>设置别名</li>
<li><code>git config --global alias.br branch</code>设置别名</li>
<li><code>git config --global alias.unstage "reset HEAD"</code>设置别名</li>
</ul>
<h3><span id="shell脚本">Shell脚本</span></h3>
<blockquote>
<p>这个对于我自己来说也是一个比较大的难点！！主要对于一些特殊字符的用法不了解，其中包括小括号，中括号，大括号，单引号，反引号，双引号</p>
<p>我觉得把这个讲清楚真的非常重要，其次就是了解一些基本的变量、控制结构(条件结构，循环结构)基本上就能够懂得基本的用法了</p>
<p>其中稍微高阶一点，也是shell作为一个脚本型语言的特色就是其参数传递了</p>
<p>同时还有一些比较困难的指令的使用，包括<code>grep awk sed</code></p>
<p>虽然可以通过<code>man</code>来了解大部分</p>
</blockquote>
<h3><span id="shell脚本">shell脚本</span></h3>
<blockquote>
<p>shell脚本是一个用于执行命令的脚本文件</p>
</blockquote>
<ul>
<li>在脚本中在第一行添加<code>#!/bin/bash</code>可以指定脚本使用的shell</li>
<li>运行脚本
<ul>
<li>通过<code>chmod +x script.sh</code>添加执行权限后，<code>./script.sh</code>运行脚本</li>
<li><code>sh script.sh</code>运行脚本</li>
<li><code>./script.sh</code>运行脚本</li>
<li><code>source script.sh</code>运行脚本</li>
</ul>
</li>
<li>参数
<ul>
<li><code>$0</code>脚本名</li>
<li><code>$1</code>第一个参数</li>
<li><code>$2</code>第二个参数</li>
<li><code>$#</code>参数个数</li>
<li><code>$*</code>所有参数，所有参数都是一个字符串</li>
<li><code>$@</code>所有参数，每个参数都是一个独立的字符串</li>
<li><code>$$</code>脚本的进程号</li>
<li><code>$?</code>上一个命令的返回值</li>
<li><code>$!</code>后台运行的最后一个进程的进程号</li>
</ul>
</li>
<li>函数
<ul>
<li><code>function_name(){...}</code>定义函数</li>
<li><code>function_name</code>调用函数</li>
<li><code>return</code>返回值</li>
</ul>
</li>
<li>控制结构
<ul>
<li><code>if...then...fi</code>条件语句</li>
<li><code>case...esac</code>多条件语句</li>
<li><code>for...do...done</code>循环语句</li>
<li><code>while...do...done</code>循环语句</li>
<li><code>until...do...done</code>循环语句</li>
<li><code>break</code>跳出循环</li>
<li><code>continue</code>跳过本次循环</li>
<li><code>exit</code>退出脚本</li>
<li><code>trap</code>捕获信号</li>
<li><code>eval</code>执行命令</li>
<li><code>exec</code>执行命令</li>
<li><code>let</code>执行算术运算</li>
<li><code>select</code>选择语句</li>
<li><code>shift</code>移动参数</li>
<li><code>source</code>执行脚本</li>
<li><code>test</code>测试语句</li>
<li><code>time</code>计时</li>
<li><code>type</code>查找命令</li>
<li><code>ulimit</code>设置资源限制</li>
</ul>
</li>
<li>关系运算符
<ul>
<li><code>-eq</code>等于</li>
<li><code>-ne</code>不等于</li>
<li><code>-gt</code>大于</li>
<li><code>-lt</code>小于</li>
<li><code>-ge</code>大于等于</li>
<li><code>-le</code>小于等于</li>
<li><code>=</code>字符串相等</li>
<li><code>!=</code>字符串不相等</li>
<li><code>-z</code>字符串为空</li>
<li><code>-n</code>字符串不为空</li>
<li><code>-e</code>文件存在</li>
<li><code>-f</code>文件存在且是普通文件</li>
<li><code>-d</code>文件存在且是目录</li>
<li><code>-s</code>文件存在且不为空</li>
<li><code>-r</code>文件存在且可读</li>
</ul>
</li>
</ul>
<p><strong>grep</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180342701.png" alt="image-20240314180342701"></p>
<p><strong>awk</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180412634.png" alt="image-20240314180412634"></p>
<p><strong>sed</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180442171.png" alt="image-20240314180442171"></p>
<h2><span id="实验体会">实验体会</span></h2>
<p>我觉得通过本次实验自己对于一些工具包括<code>vim tmux</code>更加熟悉了，同时对于<code>shell</code>脚本的撰写也更加熟悉了。学到了很多东西！！！</p>
<p>当然还有一点体会就是对于命令的细节还是要更加了解一点，比如<code>echo</code>会自动加入换行符，真的被狠狠背刺了啊啊啊啊！！</p>
<p>前面没有提到，这里分享一下自己学习<code>tmux</code>的经验</p>
<blockquote>
<p>tmux is terminal multiplexer</p>
</blockquote>
<blockquote>
<p>虽然你可以打开多个终端，但是tmux帅啊！！</p>
</blockquote>
<p>创建会话 <code>creating tmux sessions</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样会打开一个新的页面也该窗口</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144341753.png" alt="image-20240308144341753"></p>
<p>退出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>增加一个命名：</p>
<pre class="line-numbers language-none"><code class="language-none">tmux new -s test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144443438.png" alt="image-20240308144443438"></p>
<p>创建新的tmux窗口<code>creating new tmux windows</code></p>
<pre class="line-numbers language-none"><code class="language-none">Ctrl-b c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>Ctrl-b</code>在tmux里面相当于是一个命令前缀</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144816204.png" alt="image-20240308144816204"></p>
<p>在两个tmux窗口之间切换 s<code>witching between tmux windows</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样会顺序遍历已经创建的窗口</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>你可以注意到这个窗口的名字叫做bash，是因为目前是正在运行进程，如果你某一个窗口运行<code>htop</code>，那么那个窗口的名字就是<code>htop</code></p>
<p>如果你想要设置一个不会改变的窗口命名</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b ,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150121933.png" alt="image-20240308150121933"></p>
<p>离开一个会话<code>detaching from a tmux session</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>连接一个会话<code>attaching to a tmus session</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要重新新建一个任务可以</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b new <span class="token parameter variable">-s</span> coding
// 也就是前面的新建一个session的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150456377.png" alt="image-20240308150456377"></p>
<p>列举所有tmux会话<code>listing tmux sessions</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果想要连接某一个<code>session</code>，可以</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux a <span class="token parameter variable">-t</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150641122.png" alt="image-20240308150641122"></p>
<p>可以再几个<code>session</code>之间切换</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150751219.png" alt="image-20240308150751219"></p>
<p>窗格操作</p>
<p>划分窗格</p>
<p><code>tmux split-window</code>命令用来划分窗格。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 划分上下两个窗格</span>
$ tmux split-window

<span class="token comment"># 划分左右两个窗格</span>
$ tmux split-window <span class="token parameter variable">-h</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>移动光标</p>
<p><code>tmux select-pane</code>命令用来移动光标位置。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 光标切换到上方窗格</span>
$ tmux select-pane <span class="token parameter variable">-U</span>

<span class="token comment"># 光标切换到下方窗格</span>
$ tmux select-pane <span class="token parameter variable">-D</span>

<span class="token comment"># 光标切换到左边窗格</span>
$ tmux select-pane <span class="token parameter variable">-L</span>

<span class="token comment"># 光标切换到右边窗格</span>
$ tmux select-pane <span class="token parameter variable">-R</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>交换窗格位置</p>
<p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前窗格上移</span>
$ tmux swap-pane <span class="token parameter variable">-U</span>

<span class="token comment"># 当前窗格下移</span>
$ tmux swap-pane <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>窗格快捷键</p>
<p>下面是一些窗格操作的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b %</code>：划分左右两个窗格。</li>
<li><code>Ctrl+b "</code>：划分上下两个窗格。</li>
<li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li>
<li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li>
<li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li>
<li><code>Ctrl+b {</code>：当前窗格与上一个窗格交换位置。</li>
<li><code>Ctrl+b }</code>：当前窗格与下一个窗格交换位置。</li>
<li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>
<li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>
<li><code>Ctrl+b x</code>：关闭当前窗格。</li>
<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>
<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>
<li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li>
<li><code>Ctrl+b q</code>：显示窗格编号。</li>
</ul>
</blockquote>
<p>获取帮助<code>getting help with tmux</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b ?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> tmux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150851773.png" alt="image-20240308150851773"></p>
<p><strong>reference</strong></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p>
<p><a href="https://www.linuxtrainingacademy.com/tmux-tutorial/">https://www.linuxtrainingacademy.com/tmux-tutorial/</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab0</tag>
      </tags>
  </entry>
  <entry>
    <title>llama.cpp</title>
    <url>/2024/05/11/llama-cpp/</url>
    <content><![CDATA[<h1><span id="llamacpp">llama.cpp</span></h1>
<blockquote>
<p>详见 <a href="https://anakin.ai/blog/how-to-install-llama-cpp/#running-llamacpp">https://anakin.ai/blog/how-to-install-llama-cpp/#running-llamacpp</a></p>
</blockquote>
<h2><span id="简介">简介</span></h2>
<p>llama.cpp是一个大模型部署工具</p>
<p>大模型的研究分为训练和推理两个部分。</p>
<ul>
<li>
<p>训练的过程，实际上就是寻找模型参数，是的模型的损失函数最小化，推理结果最优化的过程</p>
<p>训练完成后，模型的参数就固定了，这时候就可以使用模型进行推理，对外提供服务</p>
</li>
</ul>
<p>llama.cpp主要解决的是推理过程的性能问题，一个能用python写的东西，用cpp来写多半是为了性能。主要有两点优化：</p>
<ol>
<li>llama.cpp使用的是C语言实现的机器学习张量库ggml</li>
<li>llama.cpp提供了模型量化的工具</li>
</ol>
<p>计算类Python库的优化手段之一就是使用C语言重新实现，这部分性能提升非常明显。另外一个是量化，量化是通过牺牲模型参数的精度来换取模型的推理速度。</p>
<p>llama.cpp提供了大模型量化的工具，可以将模型参数从32位浮点数转换为16位浮点数，甚至是8、4位整数。</p>
<p>同时llama.cpp提供了服务化组件，可以直接对外提供模型的API。</p>
<h2><span id="安装">安装</span></h2>
<p>克隆仓库</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/ggerganov/llama.cpp
cd llama.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>下载模型，参见后面</p>
</blockquote>
<p>编译构建项目</p>
<p>仅使用CPU：</p>
<pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用<code>nvidia gpu</code>：请确保自己安装了<code>CUDA</code>驱动</p>
<pre class="line-numbers language-none"><code class="language-none">make clean &amp;&amp; LLAMA_CUBLAS=1 make -j<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置python环境</p>
<pre class="line-numbers language-none"><code class="language-none">conda create -n llama-cpp python=3.10
conda activate llama-cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>运行模型</p>
<p><code>--n-gpu-layers</code> ==》 GPU’s VRAM capacity for optimal performance.</p>
<pre class="line-numbers language-none"><code class="language-none">./main --model your_model_path.ggml --n-gpu-layers 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看一下目录：</p>
<ul>
<li>main：使用模型进行推理</li>
<li>quantize：量化模型</li>
<li>server：提供模型 API 服务</li>
<li>…</li>
</ul>
<h2><span id="模型下载">模型下载</span></h2>
<blockquote>
<p>这里以llama3为例</p>
</blockquote>
<p>llama.cpp 支持转换的模型格式有 <code>PyTorch</code> 的 <code>.pth</code> 、<code>huggingface</code> 的 <code>.safetensors</code> 、还有之前 llamma.cpp 采用的 ggmlv3。</p>
<blockquote>
<p>这里我下载的是llama3 的中文模型，也可以自己找自己想下载的</p>
</blockquote>
<p>要么直接去<code>huggingface</code>下载，要么<code>clone</code>仓库(这个得在终端挂梯子)</p>
<p>直接下载：</p>
<p><a href="https://huggingface.co/shenzhi-wang/Llama3-8B-Chinese-Chat-GGUF-4bit/tree/main">https://huggingface.co/shenzhi-wang/Llama3-8B-Chinese-Chat-GGUF-4bit/tree/main</a></p>
<p>clone:</p>
<pre class="line-numbers language-none"><code class="language-none">git clone git@hf.co:shenzhi-wang/Llama3-8B-Chinese-Chat-GGUF-4bita<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果下载的不是<code>gguf</code>格式的需要先进行转换</p>
<ul>
<li>
<p>安装依赖</p>
<p>在<code>llama.cpp</code>项目根目录下有<code>requirements.txt</code>文件，直接安装依赖即可</p>
<pre class="line-numbers language-none"><code class="language-none">pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>转换模型</p>
<pre class="line-numbers language-none"><code class="language-none">python convert.py ./models/*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>*</code>表示模型的位置</p>
<p><code>vocabtype</code>指定分词算法，默认是<code>spm</code>，如果是<code>bpe</code>，需要显示指定</p>
</li>
</ul>
<h3><span id="量化模型">量化模型</span></h3>
<ul>
<li>
<p>使用<code>quantize</code>量化模型</p>
<p><code>quantize</code>提供了各种精度的量化</p>
<p>直接运行可以查看选项和用法</p>
<pre class="line-numbers language-none"><code class="language-none">./quantize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h3><span id="大模型推理">大模型推理</span></h3>
<p>在项目根目录下执行</p>
<pre class="line-numbers language-none"><code class="language-none">./main -m ./models/llama3-8B/Llama3-8B-Chinese-Chat-q4_0-v2_1.gguf -p "What color is the sun?" -n 1024<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用上面量化的模型进行推理，我这里本来就是下载的量化后的模型，直接就是使用的量化后的模型。</p>
<p>main 命令有一系列参数可选，其中比较重要的参数有：</p>
<p><code>-ins</code> 交互模式，可以连续对话，上下文会保留 <code>-c</code>控制上下文的长度，值越大越能参考更长的对话历史（默认：512） <code>-n</code>控制回复生成的最大长度（默认：128） <code>–temp</code> 温度系数，值越低回复的随机性越小</p>
<p>在交互模型下使用</p>
<pre class="line-numbers language-none"><code class="language-none">./main -m ./models/llama3-8B/Llama3-8B-Chinese-Chat-q4_0-v2_1.gguf -ins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>交互模式下，以对话的形式，有上下文的连续使用大模型。</p>
<blockquote>
<p>感觉还是有点慢的（</p>
</blockquote>
<h3><span id="提供模型api服务">提供模型API服务</span></h3>
<p>这里有两种方法，使用项目中的server或者第三方工具包。不得不感叹，ai方面的社区是真的丰富！！</p>
<ul>
<li>使用llama.cpp server提供的API服务</li>
</ul>
<p>前面编译之后，会在 llama.cpp 项目的根目录下生成一个 server 可执行文件，执行下面的命令，启动 API 服务。</p>
<pre class="line-numbers language-none"><code class="language-none">./server -m ./models/llama3-8B/Llama3-8B-Chinese-Chat-q4_0-v2_1.gguf --host 0.0.0.0 --port 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就启动了一个 API 服务，可以使用 curl 命令进行测试。</p>
<pre class="line-numbers language-none"><code class="language-none">curl --request POST \
    --url http://localhost:8080/completion \
    --header "Content-Type: application/json" \
    --data '{"prompt": "What color is the sun?","n_predict": 512}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>使用第三方工具包提供API服务</li>
</ul>
<p>在 llamm.cpp 项目的首页 <a href="https://github.com/ggerganov/llama.cpp">https://github.com/ggerganov/llama.cpp</a> 中有提到各种语言编写的第三方工具包，可以使用这些工具包提供 API 服务，包括 Python、Go、Node.js、Ruby、Rust、C#/.NET、Scala 3、Clojure、React Native、Java 等语言的实现。</p>
<p>以python为例</p>
<h2><span id="在os服务器上使用">在os服务器上使用</span></h2>
<p>首先将clone的项目传上去-&gt; 慢</p>
<p>然后将下载的模型传上去-&gt; 更慢</p>
<p>然后就可以运行了</p>
<pre class="line-numbers language-none"><code class="language-none">./main -m ./models/llama3-8B/Llama3-8B-Chinese-Chat-q4_0-v2_1.gguf -ins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>os_lab0笔记</title>
    <url>/2024/04/24/os-lab0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="操作系统lab0">操作系统lab0</span></h1>
<h2><span id="1linux操作">1.Linux操作</span></h2>
<h3><span id="11-查看文件">1.1 查看文件</span></h3>
<blockquote>
<p>ls<br>
用法: ls [选项]… [文件]…<br>
选项（常用）：<br>
-a 不隐藏任何以 . 开始的项目<br>
-l 每行只列出一个文件</p>
</blockquote>
<p>示例：<code>ls -al</code></p>
<h3><span id="12-创建一个新的空文件">1.2 创建一个新的空文件</span></h3>
<blockquote>
<p>touch<br>
用法: touch [选项]… 文件…</p>
</blockquote>
<p>示例：<code>touch hello_world.c</code>成功创建一个新的文件</p>
<h3><span id="13-创建并打开一个文件">1.3 (创建并打开一个文件)</span></h3>
<blockquote>
<p>vim [文件名]</p>
</blockquote>
<h3><span id="14-创建文件目录">1.4 创建文件目录</span></h3>
<blockquote>
<p>mkdir<br>
用法：mkdir [选项]… 目录…</p>
</blockquote>
<p>示例：<code>mkdir newdir</code>在目录下创建了一个名为<code>newdir</code>的目录</p>
<h3><span id="15-进入目录">1.5 进入目录</span></h3>
<blockquote>
<p>cd<br>
用法：cd [目录]</p>
</blockquote>
<p>示例：<code>cd newdir</code>进入<code>newdir</code>目录，<code>cd ..</code>返回上一级目录,<code>cd</code>返回主目录,<code>cd -</code>返回上一次所在的目录<br>
输入<code>pwd</code>可以查看当前所在的绝对路径。</p>
<h3><span id="16-删除一个空目录">1.6 删除一个空目录</span></h3>
<blockquote>
<p>rmdir<br>
用法：rmdir [选项]… 目录…</p>
</blockquote>
<p>示例：<code>rmdir newdir</code>删除<code>newdir</code>目录</p>
<h3><span id="17-删除">1.7 删除</span></h3>
<blockquote>
<p>rm<br>
用法：rm [选项]… 文件…<br>
选项：<br>
-r 递归删除目录及其内容<br>
-f 强制删除。忽略不存在的文件，不给出提示</p>
</blockquote>
<p>示例：<code>rm -rf newdir</code>删除<code>newdir</code>目录及其内容</p>
<p>rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删<br>
除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。 rm命令还有-i选项，这个选项在使用文<br>
件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求逐一确定是否要删除。这时，必须输入Y并<br>
按回车键，才能删除文件。 示例：rm -rf /-可强制递归删除全盘文件！！！</p>
<blockquote>
<p>可以考虑在家目录下创建回收站目录，删除文件时先移动到回收站，再删除</p>
</blockquote>
<h3><span id="18-复制文件">1.8 复制文件</span></h3>
<blockquote>
<p>cp<br>
用法：cp [选项]… 源文件 目标文件<br>
选项：<br>
-r 递归复制目录及其内容</p>
</blockquote>
<p>示例：<code>cp hello_world.c hello_world2.c</code>复制<code>hello_world.c</code>文件为<code>hello_world2.c</code><br>
该命令的第一个参数为原文件路径，命令的第二个参数为目标文件路径。如果目标文件路径不存在，则会创建一个新的文件。</p>
<h3><span id="19-移动文件">1.9 移动文件</span></h3>
<blockquote>
<p>mv<br>
用法：mv [选项]… 源文件 目标文件<br>
选项：<br>
-i 若目标文件已经存在，询问是否覆盖</p>
</blockquote>
<p>示例：<code>mv hello_world2.c newdir</code>将<code>hello_world2.c</code>移动到<code>newdir</code>目录下<br>
<code>mv oldname newname</code>可以重命名文件</p>
<h3><span id="110-回显">1.10 回显</span></h3>
<blockquote>
<p>echo</p>
</blockquote>
<p>示例：<code>echo "hello world"</code>输出<code>hello world</code></p>
<h3><span id="111-查看文件内容">1.11 查看文件内容</span></h3>
<blockquote>
<p>cat<br>
用法：cat [选项]… [文件]…<br>
选项：<br>
-n 显示行号<br>
-b 显示行号，空行不显示<br>
-A 显示所有字符，包括控制字符<br>
-E 显示行尾的$<br>
-T 显示制表符<br>
-v 显示不可见字符<br>
-s 合并多个空行为一个空行<br>
-e 显示行尾的$</p>
</blockquote>
<p>示例：<code>cat hello_world.c</code>查看<code>hello_world.c</code>文件内容<br>
<code>cat -n file1 &gt; file2</code> 将file1的内容输出到file2中，并且在每一行前加上行号<br>
<code>cat -b file1 file2 &gt;&gt; file3</code> 将file1和file2的内容输出附加到file3中，并且在每一行前加上行号</p>
<p>###　1.12 帮助</p>
<blockquote>
<p>man -manual<br>
用法：man [选项]… [命令]…<br>
选项：<br>
-f 显示命令的简短说明</p>
</blockquote>
<p>示例：<code>man ls</code>查看<code>ls</code>命令的帮助<br>
通过man命令可以查看命令的详细用法和参数说明</p>
<h3><span id="113-查找">1.13 查找</span></h3>
<blockquote>
<p>find<br>
用法：find [选项]… [路径]… [表达式]…<br>
选项：<br>
-name 按文件名查找<br>
-type 按文件类型查找<br>
-size 按文件大小查找<br>
-exec 对查找到的文件执行命令</p>
</blockquote>
<ul>
<li><code>find</code>当前目录下递归查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上</li>
</ul>
<p>示例：<code>find . -name "hello_world.c"</code>查找当前目录下的<code>hello_world.c</code>文件</p>
<blockquote>
<p>grep<br>
用法：grep [选项]… 模式 [文件]…<br>
选项：<br>
-n 显示行号<br>
-v 显示不包含模式的行<br>
-i 忽略大小写<br>
-r 递归查找<br>
-l 只显示文件名<br>
-c 显示匹配行数<br>
-w 匹配整个单词<br>
-A 显示匹配行及后面的n行</p>
</blockquote>
<ul>
<li><code>grep</code>使用正则表达式匹配文件内容，并把匹配的行输出至屏幕上。可以从文件中查找包含<code>pattern</code>部分字符串的行，并将该文件的路径和该行输出值屏幕</li>
</ul>
<p>示例：<code>grep "hello" hello_world.c</code>查找<code>hello_world.c</code>文件中包含<code>hello</code>的行</p>
<blockquote>
<p>tree<br>
用法：tree [选项]… [目录]…<br>
选项：<br>
-d 只显示目录<br>
-L 显示目录的深度<br>
-a 显示所有文件<br>
-f 显示完整路径</p>
</blockquote>
<ul>
<li><code>tree</code>可以以树状图的形式显示目录结构</li>
</ul>
<p>示例：<code>tree</code>显示当前目录的树状图</p>
<h3><span id="114-权限">1.14 权限</span></h3>
<blockquote>
<p>chmod<br>
用法：chmod [选项]… 模式 文件…<br>
选项：<br>
-R 递归修改<br>
模式：<br>
u 用户<br>
g 用户组<br>
o 其他用户<br>
a 所有用户<br>
‘+’ 添加权限<br>
‘-’ 减少权限<br>
= 设置权限<br>
r 读权限<br>
w 写权限<br>
x 执行权限<br>
s 设置用户ID<br>
t 粘滞位</p>
</blockquote>
<p>示例：<code>chmod u+x hello_world.c</code>给<code>hello_world.c</code>文件的用户添加执行权限<br>
<code>chmod 777 hello_world.c</code>给<code>hello_world.c</code>文件的所有用户添加读写执行权限<br>
<code>chmod 755 hello_world.c</code>给<code>hello_world.c</code>文件的用户添加读写执行权限，用户组和其他用户添加读执行权限(对应二进制111b=7, 101b=5)<br>
<code>chmod -w hello_world.c</code>删除<code>hello_world.c</code>文件的写权限</p>
<blockquote>
<p>chown<br>
用法：chown [选项]… 用户:用户组 文件…<br>
选项：<br>
-R 递归修改<br>
用户：文件的所有者<br>
用户组：文件的所属用户组<br>
文件：要修改的文件<br>
该命令可以修改文件的所有者和所属用户组</p>
</blockquote>
<p>示例：<code>chown root:root hello_world.c</code>将<code>hello_world.c</code>文件的所有者和所属用户组修改为<code>root</code></p>
<h3><span id="115-比较文件差异">1.15 比较文件差异</span></h3>
<blockquote>
<p>diff<br>
用法：diff [选项]… 文件1 文件2<br>
选项：<br>
-c 以上下文的方式显示差异<br>
-u 以统一的方式显示差异<br>
-r 递归比较目录<br>
-b 忽略空格<br>
-B 忽略空行<br>
-q 只显示是否有差异</p>
</blockquote>
<p>该命令可以比较两个文件的差异</p>
<h3><span id="116-文件处理">1.16 文件处理</span></h3>
<blockquote>
<p>sed<br>
用法：sed [选项]… [脚本]… [文件]…<br>
选项：<br>
-n 安静模式，只显示脚本处理后的结果<br>
-e 多个脚本处理<br>
-f 从文件中读取脚本<br>
脚本：</p>
<ul>
<li>s/old/new/g 替换old为new</li>
<li>d 删除匹配行</li>
<li>p 打印匹配行</li>
<li>a 在匹配行后添加</li>
<li>i 在匹配行前添加</li>
<li>c 替换匹配行</li>
<li>r 从文件中读取</li>
<li>w 写入文件</li>
<li>q 退出</li>
</ul>
<p>-i 直接修改文件，而不是输出到屏幕。否则，只输出不编辑</p>
</blockquote>
<p>示例：<code>sed -i 's/old/new/g' hello_world.c</code>将<code>hello_world.c</code>文件中的<code>old</code>替换为<code>new</code></p>
<blockquote>
<p>[行号]a[内容] 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理<br>
[行号]c[内容] 取代。用内容取代相应行的文本<br>
[行号]i[内容] 插入。在当前行的上面插入一行文本<br>
[行号]d 删除当前行的内容<br>
[行号]p 输出选择的内容。通常与选项-n一起使用<br>
s/re/string 将 re（正则表达式）匹配的内容替换为 string</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a\hello'</span> hello_world.c   <span class="token comment">#在第一行后添加hello</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1,3d'</span> hello_world.c      <span class="token comment">#删除第一行到第三行</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1,3p'</span> hello_world.c     <span class="token comment">#输出第一行到第三行</span>
<span class="token comment"># 输出 my.txt 的第三行</span>
<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'3p'</span> my.txt
<span class="token comment"># 删除 my.txt 文件的第二行</span>
<span class="token function">sed</span> <span class="token string">'2d'</span> my.txt
<span class="token comment"># 删除 my.txt 文件的第二行到最后一行（$ 符号表示到最末尾）</span>
<span class="token function">sed</span> <span class="token string">'2,$d'</span> my.txt
<span class="token comment"># 在整行范围内把 str1 替换为 str2</span>
<span class="token comment"># 如果没有 g 标记，则只有每行第一个匹配的 str1 被替换成 str2</span>
<span class="token function">sed</span> <span class="token string">'s/str1/str2/g'</span> my.txt
<span class="token comment"># -e 选项允许在同一行里执行多条命令。例子的第一条是第四行后添加一个 str, 第二个命令是将</span>
str 替换为 aaa。命令的执行顺序对结果有影响。
<span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'4a\str'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/str/aaa/'</span> my.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>awk<br>
用法：awk [选项]… [脚本]… [文件]…<br>
选项：<br>
-F 指定分隔符<br>
脚本：</p>
<ul>
<li>print 打印</li>
<li>printf 格式化打印</li>
<li>NR 行号</li>
<li>NF 列数</li>
<li>$1 第一列</li>
<li>$0 整行</li>
<li>$NF 最后一列</li>
<li>$NR 最后一行</li>
<li>BEGIN{…} 开始时执行</li>
<li>END{…} 结束时执行</li>
<li>FS 分隔符</li>
<li>OFS 输出分隔符</li>
<li>RS 输入行分隔符</li>
<li>ORS 输出行分隔符</li>
<li>FILENAME 文件名</li>
<li>FNR 当前文件的行号</li>
<li>ARGIND 当前文件的序号</li>
<li>ARGV 当前文件的名字</li>
<li>ENVIRON 环境变量</li>
<li>length() 字符串长度</li>
<li>substr() 截取字符串</li>
<li>index() 查找字符串</li>
<li>match() 匹配字符串</li>
<li>split() 分割字符串</li>
<li>tolower() 转小写</li>
<li>toupper() 转大写</li>
<li>system() 执行系统命令</li>
<li>getline 读取下一行</li>
<li>close 关闭文件</li>
<li>delete 删除数组</li>
<li>next 跳过当前行</li>
<li>exit 退出</li>
</ul>
<p>-f 从文件中读取脚本<br>
-v 定义变量</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'{print $1}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列 </span>
<span class="token function">awk</span> -F: <span class="token string">'{print $1}'</span> /etc/passwd  <span class="token comment">#以:为分隔符输出/etc/passwd的第一列</span>
<span class="token function">awk</span> <span class="token string">'{print $1,$2}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列和第二列</span>
<span class="token function">awk</span> <span class="token string">'{print $1,$2}'</span> <span class="token assign-left variable">OFS</span><span class="token operator">=</span><span class="token string">":"</span> my.txt  <span class="token comment">#输出 my.txt 的第一列和第二列，以:为分隔符</span>
<span class="token function">awk</span> <span class="token string">'$1&gt;2 {print$1,$3}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列大于2的行的第一列和第三列</span>
<span class="token variable">$n</span> 代表每一行中用空格分隔后的第n项
<span class="token function">awk</span> <span class="token parameter variable">-F</span> , <span class="token string">'{print $2}'</span> my.txt  <span class="token comment">#以,为分隔符输出 my.txt 的第二列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="117-压缩解压">1.17 压缩解压</span></h3>
<blockquote>
<p>tar<br>
用法：tar [选项]… [文件]…<br>
选项：<br>
-c 创建压缩文件<br>
-x 解压文件<br>
-z 使用gzip压缩<br>
-j 使用bzip2压缩<br>
-v 显示详细信息<br>
-f 指定文件名<br>
-C 指定目录<br>
-t 显示压缩文件内容<br>
-r 向压缩文件中添加文件<br>
-u 更新压缩文件<br>
-d 从压缩文件中删除文件<br>
-A 合并压缩文件<br>
-W 确认压缩文件<br>
-p 保留文件权限<br>
-P 保留绝对路径<br>
-m 不保留文件修改时间<br>
-l 保留符号链接<br>
-k 保留已存在文件<br>
-N 指定时间<br>
-X 指定排除文件<br>
-T 指定文件列表<br>
-U 更新压缩文件<br>
-M 多卷压缩文件<br>
-h 显示帮助</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> file.tar file1 file2  <span class="token comment">#将file1和file2打包成file.tar</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> file.tar  <span class="token comment">#解压file.tar</span>
<span class="token function">tar</span> <span class="token parameter variable">-zcvf</span> file.tar.gz file1 file2  <span class="token comment">#将file1和file2打包成file.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="118-管道">1.18 管道</span></h3>
<blockquote>
<p>管道符号<code>|</code>可以将一个命令的输出作为另一个命令的输入</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command1 <span class="token operator">|</span> command2 <span class="token operator">|</span> command3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-al</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"hello"</span>  <span class="token comment">#查找当前目录下包含hello的文件</span>
<span class="token comment"># 为将my.sh的内容输出给grep命令，grep在其中查找字符串</span>
<span class="token function">cat</span> my.sh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Hello"</span>
<span class="token comment"># 将 my.sh 的内容作为 cat 命令参数，cat 命令 stdout 发给 grep 命令的 stdin，grep 在其</span>
中查找字符串，最后将结果输出到 output.txt
<span class="token function">cat</span> <span class="token operator">&lt;</span> my.sh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Hello"</span> <span class="token operator">&gt;</span> output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="119-重定向">1.19 重定向</span></h3>
<ul>
<li>标准输入(stdin)：0</li>
<li>标准输出(stdout)：1</li>
<li>标准错误(stderr)：2</li>
</ul>
<blockquote>
<p>重定向符号<code>&gt;</code>可以将命令的输出重定向到文件中<br>
重定向符号<code>&gt;&gt;</code>可以将命令的输出追加到文件中<br>
重定向符号<code>&lt;</code>可以将文件的内容作为命令的输入<br>
重定向符号<code>2&gt;</code>可以将错误输出重定向到文件中<br>
重定向符号<code>&amp;&gt;</code>可以将标准输出和错误输出重定向到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中<br>
重定向符号<code>&amp;&gt;&gt;</code>可以将标准输出和错误输出追加到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中<br>
重定向符号<code>&amp;&gt;&gt;</code>可以将标准输出和错误输出追加到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中</p>
</blockquote>
<h3><span id="120-环境变量">1.20 环境变量</span></h3>
<blockquote>
<p>环境变量是一些系统的配置信息，可以通过环境变量来控制系统的行为</p>
</blockquote>
<ul>
<li><code>PATH</code>环境变量：用于指定系统的可执行文件的路径</li>
<li><code>HOME</code>环境变量：用于指定用户的家目录</li>
<li><code>USER</code>环境变量：用于指定当前用户的用户名</li>
<li><code>SHELL</code>环境变量：用于指定当前用户的shell</li>
<li><code>PWD</code>环境变量：用于指定当前用户的工作目录</li>
<li><code>LANG</code>环境变量：用于指定当前用户的语言</li>
<li><code>TERM</code>环境变量：用于指定当前用户的终端类型</li>
<li><code>EDITOR</code>环境变量：用于指定当前用户的编辑器</li>
<li><code>PS1</code>环境变量：用于指定当前用户的命令提示符</li>
<li><code>PS2</code>环境变量：用于指定当前用户的命令提示符的续行符</li>
<li><code>PS3</code>环境变量：用于指定当前用户的选择提示符</li>
<li><code>PS4</code>环境变量：用于指定当前用户的调试提示符</li>
<li><code>HISTSIZE</code>环境变量：用于指定当前用户的历史记录的大小</li>
<li><code>HISTFILESIZE</code>环境变量：用于指定当前用户的历史记录文件的大小</li>
<li><code>HISTCONTROL</code>环境变量：用于指定当前用户的历史记录的控制</li>
<li><code>HISTIGNORE</code>环境变量：用于指定当前用户的历史记录的忽略</li>
</ul>
<blockquote>
<p><code>export</code>命令可以将一个变量导出为环境变量<br>
<code>unset</code>命令可以将一个环境变量删除<br>
<code>env</code>命令可以查看当前的环境变量<br>
<code>set</code>命令可以查看当前的所有变量<br>
<code>echo $变量名</code>可以查看变量的值<br>
<code>echo $PATH</code>可以查看<code>PATH</code>环境变量的值</p>
</blockquote>
<h3><span id="121-常用快捷键">1.21 常用快捷键</span></h3>
<ul>
<li><code>Ctrl+C</code>中断当前命令</li>
<li><code>Ctrl+D</code>退出当前shell,相当于<code>exit</code></li>
<li><code>Ctrl+L</code>清屏</li>
<li><code>Ctrl+Z</code>挂起当前命令,使用<code>fg</code>命令恢复</li>
</ul>
<h3><span id="122-通配符">1.22 通配符</span></h3>
<ul>
<li><code>*</code>匹配任意多个字符,<code>ls *.txt</code>匹配所有以<code>.txt</code>结尾的文件</li>
<li><code>?</code>匹配一个字符,<code>ls ?.txt</code>匹配所有以一个字符加<code>.txt</code>结尾的文件</li>
<li><code>[]</code>匹配指定范围内的字符,<code>ls [a-z].txt</code>匹配所有以一个小写字母加<code>.txt</code>结尾的文件</li>
<li><code>!</code>取反,排除匹配的文件,<code>ls !(*.txt)</code>匹配所有不以<code>.txt</code>结尾的文件</li>
<li><code>{}</code>,<code>ls {*.txt,*.c}</code>匹配所有以<code>.txt</code>或<code>.c</code>结尾的文件</li>
<li><code>()</code>可以改变优先级,<code>ls (a|b).txt</code>匹配所有以<code>a.txt</code>或<code>b.txt</code>结尾的文件</li>
<li><code>|</code>或,<code>ls a.txt|b.txt</code>匹配所有以<code>a.txt</code>或<code>b.txt</code>结尾的文件</li>
<li><code>^</code>匹配行首,<code>ls ^a.txt</code>匹配所有不以<code>a.txt</code>开头的文件</li>
<li><code>$</code>匹配行尾,<code>ls a.txt$</code>匹配所有以<code>a.txt</code>结尾的文件</li>
<li><code>\&lt;</code>匹配单词开头,<code>\&gt;</code>匹配单词结尾,<code>ls \&lt;a.txt</code>匹配所有以<code>a.txt</code>开头的文件</li>
<li><code>**</code>,递归匹配,<code>ls **/*.txt</code>匹配所有以<code>.txt</code>结尾的文件</li>
</ul>
<h3><span id="123-tmux">1.23 tmux</span></h3>
<blockquote>
<p>tmux是一个终端复用工具，可以在一个终端中同时运行多个终端<br>
详情看另一个文件</p>
</blockquote>
<h2><span id="2-使用工具">2. 使用工具</span></h2>
<h3><span id="21-编译器">2.1 编译器</span></h3>
<ul>
<li><code>gcc</code>是一个C语言编译器</li>
<li><code>g++</code>是一个C++语言编译器</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：gcc <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span class="token punctuation">..</span>.
选项：
<span class="token parameter variable">-c</span> 仅编译，不链接
<span class="token parameter variable">-o</span> 指定输出文件
<span class="token parameter variable">-E</span> 预处理
<span class="token parameter variable">-S</span> 汇编
<span class="token parameter variable">-l</span> 指定库文件
<span class="token parameter variable">-L</span> 指定库文件路径
<span class="token parameter variable">-I</span> Path/to/head/file 指定头文件路径
<span class="token parameter variable">-D</span> 定义宏
<span class="token parameter variable">-wall</span> 显示所有警告
<span class="token parameter variable">-g</span> 生成调试信息
<span class="token parameter variable">-std</span><span class="token operator">=</span>c99 指定C语言标准
参数：
file.c 源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world.o目标文件</span>
gcc <span class="token parameter variable">-E</span> hello_world.c  <span class="token comment">#预处理hello_world.c文件</span>
gcc <span class="token parameter variable">-S</span> hello_world.c  <span class="token comment">#汇编hello_world.c文件</span>
gcc <span class="token parameter variable">-o</span> hello_world hello_world.c <span class="token parameter variable">-lm</span>  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件，并链接数学库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时编译多个文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world.o和hello_world2.o目标文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-o用于指定要生成的结果文件，后面跟的就是结果文件名字。o是output的意思，不是目标的意思。结果文件可能是预处理文件、汇编文件、目标文件或者最终可执行文件。</p>
</blockquote>
<h3><span id="makefile">Makefile</span></h3>
<blockquote>
<p>Makefile是一个用于编译程序的工具，可以自动化编译程序<br>
基本格式</p>
</blockquote>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target</span><span class="token punctuation">:</span> dependencies
    command 1
    command 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>target</code>是要生成的目标文件</li>
<li><code>dependencies</code>是生成<code>target</code>所需要的依赖文件</li>
<li><code>command</code>是生成<code>target</code>所需要执行的命令</li>
</ul>
<p>示例</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello_world</span><span class="token punctuation">:</span> hello_world.c
    gcc -o hello_world hello_world.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="shell脚本">shell脚本</span></h3>
<blockquote>
<p>shell脚本是一个用于执行命令的脚本文件</p>
</blockquote>
<ul>
<li>在脚本中在第一行添加<code>#!/bin/bash</code>可以指定脚本使用的shell</li>
<li>运行脚本
<ul>
<li>通过<code>chmod +x script.sh</code>添加执行权限后，<code>./script.sh</code>运行脚本</li>
<li><code>sh script.sh</code>运行脚本</li>
<li><code>./script.sh</code>运行脚本</li>
<li><code>source script.sh</code>运行脚本</li>
</ul>
</li>
<li>参数
<ul>
<li><code>$0</code>脚本名</li>
<li><code>$1</code>第一个参数</li>
<li><code>$2</code>第二个参数</li>
<li><code>$#</code>参数个数</li>
<li><code>$*</code>所有参数，所有参数都是一个字符串</li>
<li><code>$@</code>所有参数，每个参数都是一个独立的字符串</li>
<li><code>$$</code>脚本的进程号</li>
<li><code>$?</code>上一个命令的返回值</li>
<li><code>$!</code>后台运行的最后一个进程的进程号</li>
</ul>
</li>
<li>函数
<ul>
<li><code>function_name(){...}</code>定义函数</li>
<li><code>function_name</code>调用函数</li>
<li><code>return</code>返回值</li>
</ul>
</li>
<li>控制结构
<ul>
<li><code>if...then...fi</code>条件语句</li>
<li><code>case...esac</code>多条件语句</li>
<li><code>for...do...done</code>循环语句</li>
<li><code>while...do...done</code>循环语句</li>
<li><code>until...do...done</code>循环语句</li>
<li><code>break</code>跳出循环</li>
<li><code>continue</code>跳过本次循环</li>
<li><code>exit</code>退出脚本</li>
<li><code>trap</code>捕获信号</li>
<li><code>eval</code>执行命令</li>
<li><code>exec</code>执行命令</li>
<li><code>let</code>执行算术运算</li>
<li><code>select</code>选择语句</li>
<li><code>shift</code>移动参数</li>
<li><code>source</code>执行脚本</li>
<li><code>test</code>测试语句</li>
<li><code>time</code>计时</li>
<li><code>type</code>查找命令</li>
<li><code>ulimit</code>设置资源限制</li>
</ul>
</li>
<li>关系运算符
<ul>
<li><code>-eq</code>等于</li>
<li><code>-ne</code>不等于</li>
<li><code>-gt</code>大于</li>
<li><code>-lt</code>小于</li>
<li><code>-ge</code>大于等于</li>
<li><code>-le</code>小于等于</li>
<li><code>=</code>字符串相等</li>
<li><code>!=</code>字符串不相等</li>
<li><code>-z</code>字符串为空</li>
<li><code>-n</code>字符串不为空</li>
<li><code>-e</code>文件存在</li>
<li><code>-f</code>文件存在且是普通文件</li>
<li><code>-d</code>文件存在且是目录</li>
<li><code>-s</code>文件存在且不为空</li>
<li><code>-r</code>文件存在且可读</li>
</ul>
</li>
</ul>
<h3><span id="ctags">ctags</span></h3>
<blockquote>
<p>ctags是一个用于生成代码索引的工具</p>
</blockquote>
<ul>
<li><code>ctags -R</code>生成当前目录的代码索引</li>
<li><code>ctags -R /path/to/dir</code>生成指定目录的代码索引</li>
<li><code>ctags -R /path/to/dir/*</code>生成指定目录的代码索引</li>
<li>vim 下使用<code>Ctrl+]</code>跳转到定义处,<code>Ctrl+t</code>返回</li>
<li>vim 下使用<code>:ts</code>查找定义处,<code>:tn</code>下一个,<code>:tp</code>上一个</li>
</ul>
<h2><span id="git">Git</span></h2>
<h3><span id="31-基本操作">3.1 基本操作</span></h3>
<ul>
<li><code>git init</code>初始化一个仓库</li>
<li><code>git clone</code>克隆一个仓库</li>
<li><code>git add</code>添加文件到暂存区</li>
<li><code>git commit</code>提交文件到仓库</li>
<li><code>git status</code>查看仓库状态</li>
<li><code>git diff</code>查看文件差异</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git reset</code>重置仓库</li>
<li><code>git rm</code>删除文件</li>
<li><code>git mv</code>移动文件</li>
<li><code>git branch</code>查看分支</li>
</ul>
<h3><span id="32-分支操作">3.2 分支操作</span></h3>
<ul>
<li><code>git branch</code>查看分支</li>
<li><code>git checkout</code>切换分支</li>
<li><code>git merge</code>合并分支</li>
<li><code>git rebase</code>变基分支</li>
<li><code>git cherry-pick</code>挑选提交</li>
<li><code>git tag</code>标记提交</li>
<li><code>git stash</code>暂存工作区</li>
<li><code>git fetch</code>获取远程分支</li>
<li><code>git pull</code>拉取远程分支</li>
<li><code>git push</code>推送远程分支</li>
<li><code>git remote</code>管理远程仓库</li>
<li><code>git submodule</code>管理子模块</li>
<li><code>git worktree</code>管理工作树</li>
<li><code>git reflog</code>查看引用日志</li>
<li><code>git bisect</code>二分查找</li>
<li><code>git blame</code>查看文件作者</li>
<li><code>git grep</code>查找文件内容</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git show</code>查看提交详情</li>
</ul>
<h3><span id="33-高级操作">3.3 高级操作</span></h3>
<ul>
<li><code>git filter-branch</code>过滤分支</li>
<li><code>git subcommand</code>子命令</li>
<li><code>git rerere</code>重用冲突解决</li>
<li><code>git gc</code>垃圾回收</li>
<li><code>git fsck</code>检查仓库</li>
<li><code>git prune</code>删除无用对象</li>
</ul>
<h3><span id="git-版本回退">git 版本回退</span></h3>
<ul>
<li><code>git reset --hard HEAD^</code>回退到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>回退到上上一个版本</li>
<li><code>git reset --hard HEAD~100</code>回退到上100个版本</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reflog</code>查看命令历史</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reset --hard HEAD@{n}</code>回退到指定版本</li>
<li><code>git reset --hard ORIG_HEAD</code>回退到上一个版本</li>
<li><code>git reset --hard</code>回退到上一个版本</li>
</ul>
<h3><span id="配置">配置</span></h3>
<ul>
<li><code>git config --global user.name "Your Name"</code>设置用户名</li>
<li>`git config --global user.email "</li>
<li><code>git config --global core.editor "vim"</code>设置编辑器</li>
<li><code>git config --global merge.tool "vimdiff"</code>设置合并工具</li>
<li><code>git config --global color.ui true</code>设置颜色</li>
<li><code>git config --global alias.st status</code>设置别名</li>
<li><code>git config --global alias.co checkout</code>设置别名</li>
<li><code>git config --global alias.ci commit</code>设置别名</li>
<li><code>git config --global alias.br branch</code>设置别名</li>
<li><code>git config --global alias.unstage "reset HEAD"</code>设置别名</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab0</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab1实验报告</title>
    <url>/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab1实验报告">Lab1实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-11">Thinking 1.1</span></h3>
<blockquote>
<p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具 链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数 的含义</p>
</blockquote>
<p>首先是gcc的几个重要的选项</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-E</span>                       Preprocess only<span class="token punctuation">;</span> <span class="token keyword">do</span> not compile, assemble or link.      
<span class="token parameter variable">-S</span>                       Compile only<span class="token punctuation">;</span> <span class="token keyword">do</span> not assemble or link.                   
<span class="token parameter variable">-c</span>                       Compile and assemble, but <span class="token keyword">do</span> not link.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>objdump的几个重要的选项</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-D, --disassemble-all    Display assembler contents of all sections
	 <span class="token parameter variable">--disassemble</span><span class="token operator">=</span><span class="token operator">&lt;</span>sym<span class="token operator">&gt;</span>  Display assembler contents from <span class="token operator">&lt;</span>sym<span class="token operator">&gt;</span>
-S,  <span class="token parameter variable">--source</span>             Intermix <span class="token builtin class-name">source</span> code with disassembly
	 --source-comment<span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span>txt<span class="token operator">&gt;</span><span class="token punctuation">]</span> Prefix lines of <span class="token builtin class-name">source</span> code with <span class="token operator">&lt;</span>txt<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327155605072.png" alt="image-20240327155605072"></p>
<p>使用不同的gcc，如使用MIPS交叉编译工具链的gcc，得到的文件类型是不一样的</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161230861.png" alt="image-20240327161230861"></p>
<p>那么对比具体内容呢，我们分别使用只进行预处理后的文本进行比较</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161546394-1711527348582-1.png" alt="image-20240327161546394"></p>
<p>发现不相同的地方还是很多的。</p>
<p>在进行编译后发现得到的文本类型也不相同</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161721152.png" alt="image-20240327161721152"></p>
<p>那么显然使用diff后区别会非常大，毕竟一个x86，一个mips</p>
<p>这里有意思的一点是</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327162651923.png" alt="image-20240327162651923"></p>
<p>如果我使用x86的objdump去反汇编用交叉编译器得到的文件会报错。</p>
<blockquote>
<p>这里我也有点不懂，objdump不是支持多个架构吗，难道说在什么架构确定了objdump对硬件的接口，只是说objdump有不同硬件架构的的接口吗.</p>
<blockquote>
<p>因为不支持mips，樂</p>
</blockquote>
</blockquote>
<h3><span id="thinking-12">Thinking 1.2</span></h3>
<blockquote>
<p>思考下述问题：</p>
<ul>
<li>
<p>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文 件。</p>
</li>
<li>
<p>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚 才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</p>
</li>
</ul>
</blockquote>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327163822161.png" alt="image-20240327163822161"></p>
<p>关于为什么不能够解析自己，首先我们查看一下<code>readel</code>f和<code>hello</code>的文件头</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git@22373058 ~/2/t/readelf <span class="token punctuation">(</span>lab2<span class="token punctuation">)</span><span class="token operator">&gt;</span> readelf <span class="token parameter variable">-h</span> readelf
ELF 头：
  Magic：   7f <span class="token number">45</span> 4c <span class="token number">46</span> 02 01 01 00 00 00 00 00 00 00 00 00
  类别:                              ELF64
  数据:                              <span class="token number">2</span> 补码，小端序 <span class="token punctuation">(</span>little endian<span class="token punctuation">)</span>
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - System V
  ABI 版本:                          <span class="token number">0</span>
  类型:                              DYN <span class="token punctuation">(</span>Position-Independent Executable <span class="token function">file</span><span class="token punctuation">)</span>
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x1180
  程序头起点：          <span class="token number">64</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">14488</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  标志：             0x0
  Size of this header:               <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">56</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">13</span>
  Size of section headers:           <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">31</span>
  Section header string table index: <span class="token number">30</span>
git@22373058 ~/2/t/readelf <span class="token punctuation">(</span>lab2<span class="token punctuation">)</span><span class="token operator">&gt;</span> readelf <span class="token parameter variable">-h</span> hello
ELF 头：
  Magic：   7f <span class="token number">45</span> 4c <span class="token number">46</span> 01 01 01 03 00 00 00 00 00 00 00 00
  类别:                              ELF32
  数据:                              <span class="token number">2</span> 补码，小端序 <span class="token punctuation">(</span>little endian<span class="token punctuation">)</span>
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - GNU
  ABI 版本:                          <span class="token number">0</span>
  类型:                              EXEC <span class="token punctuation">(</span>可执行文件<span class="token punctuation">)</span>
  系统架构:                          Intel <span class="token number">80386</span>
  版本:                              0x1
  入口点地址：               0x8049600
  程序头起点：          <span class="token number">52</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">746280</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  标志：             0x0
  Size of this header:               <span class="token number">52</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">32</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">8</span>
  Size of section headers:           <span class="token number">40</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">35</span>
  Section header string table index: <span class="token number">34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到<code>readelf</code>的ELF类别是ELF64，而<code>hello</code>的ELF的类别是ELF32。可以知道我们的<code>readelf</code>只能解析ELF32类别的ELF文件，我们可以自己手动得到一个ELF32的<code>myReadelf</code>使得可以解析自身</p>
<p>在Makefile中做如下修改</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">myReadelf</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c main.c -m32
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c readelf.c -m32
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> main.o readelf.o -o <span class="token variable">$@</span> -m32 -static -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现可以解析自身了~</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327173712186.png" alt="image-20240327173712186"></p>
<h3><span id="thinking-13">Thinking 1.3</span></h3>
<blockquote>
<p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）</p>
</blockquote>
<p>操作系统设计人员一般会将硬件初始化的相关工作作为“bootloader”程序放在非易失存储器中，而将操作系统内核放在磁盘中。从操作系统的角度来看，bootloader是为了正确找到内核并加载执行。同时这个启动过程分为两个阶段。</p>
<p>在stage1中，进行初始化硬件设备，同时加载stage2到RAM空间，并且设置堆栈最后跳转到stage2的入口函数。</p>
<p>在stage2中，初始化这一阶段需要用到的硬件设备以及其他功能，然后将内核镜像从存储器读到RAM中，并为内核设置启动参数，最后将CPU指令寄存器的内容设置为内核入口函数的地址，并将控制权转交给系统内核，这时就已经保证了内核地址被正确跳转到。</p>
<p>在我们的qemu中，在stage2阶段：</p>
<p>由 Linker Script (控制加载地址)完成。Linker Script 可以控制各节的加载地址。我们在 kernel.lds 中设置了程序各个生成地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SECTIONS <span class="token punctuation">{</span>
	<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80010000<span class="token punctuation">;</span>
	.text <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.text<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	.data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.data<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	.bss <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.bss<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	bss_end <span class="token operator">=</span> <span class="token builtin class-name">.</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80400000<span class="token punctuation">;</span>
	end <span class="token operator">=</span> <span class="token builtin class-name">.</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这个控制，生成的程序各个 section 的位置就被调整到了我们所指定的地址上。 segment 是由 section组合而成的，section 的地址被调整了，那么最终 segment 的地址也会相应地被调整。 至此，我们通过 lds 文件控制各段(包括内核)被加载到我们预期的位置。与此同时kernel.lds规定了 ENTRY(_start) ，即把内核入口定为 _start 这个函数。</p>
<p>我们通过对 /init/start.S 中 _start 函数的设置，就可以正确的跳转至 mips_init 函数:</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">EXPORT(_start)
.set at
.set reorder
	mtc0    zero, CP0_STATUS
	li	sp, 0x80400000
	jal mips_init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="难点分析">难点分析</span></h2>
<h3><span id="qemu模拟器">QEMU模拟器</span></h3>
<p>qemu（Quick Emulator）是一个硬件模拟器，刚开始接触的话我感觉还是会不太懂得这个的运行流程。</p>
<p>通过观察Makefile文件可以看到一些QUME的功劳</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">QEMU_FLAGS              <span class="token operator">+=</span> -cpu 4Kc -m 64 -nographic -M malta \<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到QUME为我们指定了使用的使用的CPU模型为<code>MIPS 4Kc</code>，同时<code>-m 64</code>指定了虚拟机内存为64MB，<code>-nographic</code>指定QEMU以无图形界面模式运行，<code>-M malta</code>指定QEMU使用"MIPS Malta"模拟器模型，这是一种MIPS架构的开发板。</p>
<p>同时与QEMU一起出现的交叉编译也很有意思</p>
<p>比如<code>mips-kubyx-gnu-gcc</code>与<code>gcc</code>的区别，不同架构的编译器的使用还是很有意思的。</p>
<p><a href="https://github.com/qemu/qemu">QUME源代码</a></p>
<h3><span id="操作系统内核启动流程">操作系统内核启动流程</span></h3>
<p>这里主要是指操作系统引导内核启动的过程。</p>
<p>首先计算机的存储部分主要包括ROM和RAM，RAM是易失存储器，刚开始RAM应该是空的，而ROM的内存又是有限的，因此操作系统需要在ROM中找到将内核部分的</p>
<p>这个过程的主要目的是将内核定位并加载到主存中，那么操作系统适配在不同的架构中启动的过程主要包括以下几个流程。</p>
<ol>
<li>打开电源，加载BIOS</li>
<li>BIOS进行开机自检，其中启动程序会对计算机的硬件进行初始化，同时会对计算机的主存、磁盘、I/O设备进行检查。</li>
<li>加载引导程序。BIOS或这UEFI会根据Boot Sequence的内容，同时将控制权交给启动顺序第一位的存储设备(这个如果本机装了多个操作系统比较明显，在我们进入BIOS后可以选择进入哪个操作系统，实际上就是CPU知道有哪几个操作系统，然后选择操作系统并将相应位置的扇区内容进行加载，根据 老师上课说的一切管理都需要数据结构可以推断出，CPU中有某个数据结构专门存储了操作系统类型、扇区地址和扇区大小等数据)，然后CPU将存储设备中的引导扇区的内容加载到内存中。</li>
<li>加载MBR，CPU可以知道在哪个主分区寻找操作系统。</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含活动分区和非活动分区，找到活动分区后，加载活动分区并将控制权交给活动分区。</li>
<li>加载PBR，读取活动分区的第一个分区（分区引导记录PBR），寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）</li>
<li>加载启动管理器</li>
<li>加载操作系统。将操作系统的初始化程序加载到内存中执行。</li>
</ol>
<blockquote>
<p>之前装debian的时候经常会遇到找不到系统的问题，推断是第3步出现了问题，BIOS找不到磁盘中debian的启动分区在哪里。</p>
</blockquote>
<h3><span id="linker-script">Linker Script</span></h3>
<blockquote>
<p>这里是因为感觉对于Linker Script的语法不够理解</p>
</blockquote>
<p>链接器脚本实际上就是是一个文本文件，使用链接器脚本编写一系列的命令，每个命令要么是一个关键字，后面可能跟有参数，要么是对符号的赋值。</p>
<ul>
<li>
<p>一个简单的Linker Script脚本</p>
<p>实际上大多数的链接器脚本都是相对比较简单的，最简单脚本通常为</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SECTIONS
<span class="token punctuation">{</span>
<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x10000<span class="token punctuation">;</span>
.text <span class="token builtin class-name">:</span> <span class="token punctuation">{</span>*<span class="token punctuation">(</span>.text<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80000000<span class="token punctuation">;</span>
.data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span>*<span class="token punctuation">(</span>.data<span class="token punctuation">)</span><span class="token punctuation">}</span>
.bss :<span class="token punctuation">{</span>*<span class="token punctuation">(</span>.bss<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而其他复杂的语法包括<br>
一些简单的赋值符号</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">symbol <span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">+=</span> expression <span class="token punctuation">;</span>
symbol -<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol *<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol /<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&lt;&lt;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&amp;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">|</span><span class="token operator">=</span> expression <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>给出另外一个例子</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">floating_point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
SECTIONS
<span class="token punctuation">{</span>
  .text:
    <span class="token punctuation">{</span>
      *<span class="token punctuation">(</span>.text<span class="token punctuation">)</span>
      .etext <span class="token operator">=</span> <span class="token builtin class-name">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _bdata <span class="token operator">=</span> <span class="token punctuation">(</span>. + <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> ~ <span class="token number">4</span><span class="token punctuation">;</span>
    .data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.data<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的<code>_bdata</code>是一个符号，它的值是当前位置加3，然后向下取整4的结果。</p>
<h3><span id="printk">printk</span></h3>
<p>在本次实验中我们实现了一个简单的<code>printk</code>函数，其中很多关于C语言的一些用法还是很有难度的。</p>
<p>首先是梳理一下代码架构</p>
<ul>
<li>最外层是printk()函数，其用法与我们通常使用的printf()函数有很大的相似性，可能没有那么智能的正则匹配等功能</li>
<li>printk()函数中的主要功能由vprintfmt(outputk, NULL, fmt, ap)函数实现，其中outputk是一个函数指针，fmt是一个字符串，ap是一个va_list类型的变量，这个函数的主要功能是将fmt中的内容输出到串口</li>
<li>vprintfmt()中主要部分在解析fmt这个字符串，解析到%后判断其后面的内容，然后直接调用如num = va_arg(ap, int)来得到参数，然后根据读取到的%后的内容将相应的结果进行格式化输出，这里调用了三个主要的函数，分别是print_char(),print_str(),print_num()，这里print_char和print_str实质上就是直接调用out(data,&amp;c,1)或者out(data, s, len)，但是由于考虑到左对齐右对齐等需要补充一些空格的情况，因此这里的print_char和print_str函数还是有一些复杂的。而print_num()可以看到是直接将数字转化为字符串，然后调用out(data,buf,len)函数输出。</li>
</ul>
<p>其中va_list和va_start,va_end这几个的含义也是很难理解的一部分，这里简单的说一下，va_list是一个指向参数的指针，va_start是将这个指针指向第一个参数，va_end是将这个指针指向最后一个参数。</p>
<ul>
<li>va_list 变长参数表的变量类型</li>
<li>va_start(va_list, ap ,lastarg)用于初始化边长参数表的宏</li>
<li>va_arg(va_list, type)用于获取变长参数表中的参数。这里的类型有很多种，比如int，double，char等</li>
<li>va_end(va_list,ap) 结束使用边长参数表的宏</li>
</ul>
<blockquote>
<p>但是由于这个不太了解，还是太难啦！</p>
</blockquote>
<h2><span id="实验体会">实验体会</span></h2>
<p>主要是关于<code>printf</code>中的几个细节有了更多的了解。但是我觉得对于其中的va_*那几个函数还是不太能够理解，就是一个变长参数表到底是个什么东西还是不太清楚，这也导致我extra没做出来，哭！</p>
<p>其中对于启动引导的学习让自己对于操作系统有了更深的认识，完成了从计算机组成原理中学习到的底层计算机硬件架构到操作系统的过渡，同时也对于活动分区等这些有了更深的认识，起码对于自己电脑上的多系统的了解更深了一分。</p>
<p>同时还有readelf也让自己对于文件的结构更加了解了，包括认识学习到了之前一直苦恼的一些有关.so文件缺失的报错，对于文件头这个数据结构也懂了很多！</p>
<p>总体而言还是觉得自己需要加强对于操作系统的学习啊！！C语言真是博大精深啊！</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab1</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab1笔记</title>
    <url>/2024/04/24/os-lab1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>os-lab2实验报告</title>
    <url>/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab2实验报告">Lab2实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-21">Thinking 2.1</span></h3>
<blockquote>
<p>请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？ MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</p>
</blockquote>
<p>都是<strong>虚拟地址</strong>。c程序是虚拟地址比较显然，一方面是因为需要链接许多文件，在地址空间重新排列。而mips中的地址也是虚拟地址主要是因为，我们在计算机组成原理中自己搭的cpu其实是没有mmu这个内存管理单元的，也就没有虚拟内存与物理内存的转换，实际上这里我们的<strong>4Kc CPU是有MMU的</strong>，因此也是虚拟地址。</p>
<h3><span id="thinking-22">Thinking 2.2</span></h3>
<blockquote>
<p>请思考下述两个问题：</p>
<ul>
<li>从可重用性的角度，阐述用宏来实现链表的好处。</li>
<li>查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li>
</ul>
</blockquote>
<p>c语言没有模板这一语法功能，于是使用宏可以使得链表可以实现不同的类型的链表，只需要将相应的类型结构作为参数传入宏函数即可。</p>
<p>比如从定义一个链表的角度说，使用宏是这样的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span>                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>                                  </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> le_next<span class="token punctuation">;</span> </span><span class="token comment">/* next element */</span>                      <span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span><span class="token operator">*</span> le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直接可以选择相应的name和type，当定义另一个链表时修改其中的name和type即可。同时，这样我们还能够实现后面的可复用性高的宏函数，比如链表的遍历，插入等。</p>
<ul>
<li>
<p>甚至让我在想会不会c++的模板用的也是类似的方法了。</p>
<ul>
<li>
<blockquote>
<p>简单查了一下：总的来说，C++ 模板的底层实现是通过编译器进行的，包括模板的实例化和代码的生成。这个过程是在编译期完成的，可以提高程序的性能。</p>
</blockquote>
</li>
<li>
<p>虽然这个说法像是啥也没说（</p>
</li>
</ul>
</li>
<li>
<p>单向链表：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SLLIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> 		  </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>sle_next<span class="token punctuation">;</span>		  </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于插入，只能够方便的实现在某一元素之后插入，删除操作和在某一项之前插入都需要从头开始遍历列表。</p>
</li>
<li>
<p>循环链表：</p>
<p>这里的循环链表的定义和单向链表基本一致，只是多了一个将链表最后的元素指向了头指针。因此对于删除操作，在某一项之前插入，在某一项之后插入这几种操作都和单向链表相同，不过对于在尾部插入可以直接进行，是o(1)的复杂度</p>
</li>
<li>
<p>双向链表：</p>
<p>双向链表的删除操作、在某一项之前插入、在某一项之后插入都可以通过o(1)的时间开销搞定。但是比起循环链表在尾部插入还是需要进行遍历。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>链表类型</th>
<th>在某个位置操作（删除，插入）</th>
<th>删除某个元素</th>
<th>在某个元素前插入</th>
<th>在某个元素后插入</th>
</tr>
</thead>
<tbody>
<tr>
<td>单向链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>循环链表</td>
<td>O(n)，当在尾部插入时为O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="thinking-23">Thinking 2.3</span></h3>
<blockquote>
<p>请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">A<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">B<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">C<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>结合</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span>                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>                                  </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>和</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> le_next<span class="token punctuation">;</span> </span><span class="token comment">/* next element */</span>                      <span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span><span class="token operator">*</span> le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然可得。</p>
<h3><span id="thinking-24">Thinking 2.4</span></h3>
<blockquote>
<p>请思考下面两个问题：</p>
<ul>
<li>
<p>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</p>
</li>
<li>
<p>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’sManual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc</p>
<p>中可容纳不同的地址空间的最大数量。</p>
</li>
</ul>
</blockquote>
<p>TLB事实上构建了一个映射$&lt;VPN, ASID&gt; \stackrel{TLB}{\longrightarrow}&lt;PFN,N,D,V,G&gt;$</p>
<p>其中的ASID是用于区分不同的地址空间，，同一虚拟地址在不同地址空间中通常映射到不同的物理地址。</p>
<p>操作系统给每一个进程分配一个页表，每个页表都有自己的虚拟地址空间，而同一地址空间通常映射到不同的物理地址，如果没有ASID来区分当前虚拟地址是在哪个进程中使用，则可能将该虚拟地址映射到错误的物理地址。</p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411195402243.png" alt="image-20240411195402243"></p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411195351085.png" alt="image-20240411195351085"></p>
<p>ASID有八位，因此可以容纳不同地址空间的数量为256个。</p>
<h3><span id="thinking-25">Thinking 2.5</span></h3>
<blockquote>
<p>请回答下述三个问题：</p>
<ul>
<li>tlb_invalidate 和 tlb_out 的调用关系？</li>
<li>请用一句话概括 tlb_invalidate 的作用。</li>
<li>逐行解释 tlb_out 中的汇编代码。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tlb_invalidate</span><span class="token punctuation">(</span>u_int asid<span class="token punctuation">,</span> u_long va<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">tlb_out</span><span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token function">GENMASK</span><span class="token punctuation">(</span>PGSHIFT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>asid <span class="token operator">&amp;</span> <span class="token punctuation">(</span>NASID <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>课件<code>tlb_invalidate</code>在调用<code>tlb_out</code></p>
<ul>
<li><code>tlb_invalidate</code>作用：
<ul>
<li>实现删除特定虚拟地址在 TLB中的旧表项</li>
</ul>
</li>
</ul>
<p>​</p>
<pre class="line-numbers language-ass" data-language="ass"><code class="language-ass">LEAF(tlb_out)								# 叶子函数
.set noreorder								# 不雅重新排列指令顺序
	mfc0    t0, CP0_ENTRYHI					# 从CP0寄存器CP0_ENTRYHI中的值读取到t0种
	mtc0    a0, CP0_ENTRYHI					# 将a0的值保存到CP0寄存器CP0_ENTRYHI中
	nop
	/* Step 1: Use 'tlbp' to probe TLB entry */
	/* Exercise 2.8: Your code here. (1/2) */
	tlbp									# 查询虚拟地址的物理地址映射
	nop
	/* Step 2: Fetch the probe result from CP0.Index */
	mfc0    t1, CP0_INDEX					# 将CP0寄存器CP0_INDEX寄存器中的值读取到t1中
.set reorder								# 指示汇编器重新排列指令顺序
	bltz    t1, NO_SUCH_ENTRY				# 跳转，如果t1小于0,则跳转到NO_SUCH_ENTRY处
.set noreorder
	mtc0    zero, CP0_ENTRYHI				# 将CP0寄存器CP0_ENTRYHI清空
	mtc0    zero, CP0_ENTRYLO0				# 将CP0寄存器CP0_ENTRYLO0清空
	mtc0    zero, CP0_ENTRYLO1				# 将CP0寄存器CP0_ENTRYLO1清空
	nop
	/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */
	/* Exercise 2.8: Your code here. (2/2) */
	tlbwi									# 将CP0.ENTRYHI/LO 写入tlb的CP0。INDEX处
.set reorder

NO_SUCH_ENTRY:
	mtc0    t0, CP0_ENTRYHI					# 将t0重新赋值到CP0寄存器CP0_ENTRYHI中
	j       ra
END(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="thinking-26">Thinking 2.6</span></h3>
<blockquote>
<p>从下述三个问题中任选其一回答：</p>
<ul>
<li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别</li>
</ul>
</blockquote>
<p>Q1:</p>
<p>两者主要有以下三点区别：</p>
<ul>
<li>
<p>内存管理机制上，MIPS为页式管理系统，x86位段页式</p>
</li>
<li>
<p>TLB不命中的处理时，MIPS会触发TLB Refill异常，内核的<code>tlb_refiil_handler</code>会以<code>pgd_current</code>为当前进程的<code>PG0</code>基址，索引获得转换失败的虚拟地址对应的<code>PTE</code>，并将其填入TLB，然后CPU用刚刚转换失败的虚拟地址重新访问TLB</p>
<p>x86在TLB不命中时，有硬件MMU以<code>CR3</code>为当前进程的<code>PG0</code>基址，索引获得PFN后，直接输出PA。同时MMU填充TLB以加快下次转换的速度。</p>
</li>
<li>
<p>转换失败的虚拟地址，MIPS使用<code>BadVAddr</code>寄存器存放，x86使用<code>CR2</code>存放</p>
</li>
</ul>
<p>Q2：</p>
<ul>
<li>TLB 条目格式上，MIPS 的 TLB 条目格式可能会有所不同，具体取决于 MIPS 处理器的架构。而 RISC-V 则有一种统一的页表格式，称为 Sv39，用于支持 39 位的虚拟地址空间。</li>
<li>异常处理机制上，MIPS 和 RISC-V 在异常处理机制上有一些差异。MIPS 使用异常号来区分不同类型的异常，而 RISC-V 使用不同的异常代码来区分异常类型。</li>
<li>特权模式上，RISC-V 的特权模式相对于 MIPS 更加灵活，支持更多的特权级别，例如 U 模式（用户模式）、S 模式（监管者模式）、M 模式（机器模式）等。这使得 RISC-V 能够更好地支持多任务操作系统和虚拟化环境。</li>
</ul>
<p>Q3：</p>
<ul>
<li><strong>页表结构</strong>：LoongArch 使用了三级页表结构，而 MIPS 在某些情况下可能使用两级页表结构。这使得 LoongArch 能够更灵活地管理大内存空间。</li>
<li><strong>TLB 缓存</strong>：LoongArch 的 TLB 结构可能与 MIPS 略有不同，具体取决于 LoongArch 处理器的架构。不过，两者都利用 TLB 来加速地址转换。</li>
<li><strong>特权模式</strong>：LoongArch 可能支持更多的特权模式，例如用户模式、管理模式、超级模式等。这使得 LoongArch 能够更好地支持不同级别的特权操作。</li>
<li><strong>异常处理</strong>：LoongArch 和 MIPS 在异常处理机制上可能有一些差异，例如异常号的定义和异常处理程序的调用方式。</li>
</ul>
<h2><span id="难点分析">难点分析</span></h2>
<p>我觉得本次作业的难点主要在于<code>List</code>数据结构的理解和<code>Page</code>存储结构的理解。</p>
<h3><span id="数据结构与存储结构">数据结构与存储结构</span></h3>
<p>前面已经提到Page_list的结构为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个给我带来了比较大的困扰，这到底是个什么结构。</p>
<ul>
<li>LIST又是啥呢？这也好难，让我感觉自己的数据结构又是白学的<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
</ul>
<p>首先要坚信这个List就是我们学的那个链表，是一个双向链表。</p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411203312741.png" alt="image-20240411203312741"></p>
<p>这里的链表是有一个专门的头指针的，在ds中也有地方会这么用。(有一些好像还会有一些头发指针，头指针的前一个元素)这几个都是让链表的处理更加方便，也可以认为是大家认为链表的比较优雅的实现方式。</p>
<p>头指针：</p>
<p><code>LIST_HEAD(name, type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上是定义了一个结构体，给这个结构提一个名字比如head，实际上就是<code>LIST_HEAD(name, int) head;</code></p>
<p>宏替换后实际上就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">int</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么相应的一些与链表头指针的一些操作：</p>
<p><code>LIST_HEAD_INITIALIZER(head)</code></p>
<p>具体用法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_HRAD</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
head <span class="token operator">=</span> LIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于每个结点的指针部分实际上就是</p>
<p><code>LIST_ENTRY(type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里le_next可以理解，但是这个le_prev呢，这个给的注释也很奇怪，<code>address of previous next element</code>。这么来看，实际上就是将每个next指针作为一个element，那么prev就是前一个元素的这个指针。也就是一个<strong>指向指向自己的指针的指针</strong>。</p>
<p>这样并不是双向链表那种，双向链表是多了一个指向前一个结点的大结点的地址的指针，也就是说可以通过这个指针直接访问前一个结点。而这个le_prev仅仅只是前一个元素的next这个元素的地址。</p>
<blockquote>
<p>那么这里为什么要这么样呢，我们应该从功能的角度来理解，我们遍历页表是不需要从后往前的，因此理论上使用单向链表即可，但是我们又有很多对于某个元素的删除和前后插入元素的操作，使用这种类似的双向链表的结构，可以更加方便的进行删除和插入的操作。</p>
</blockquote>
<p>那么到这里其实就懂了，一个结点分为data和field。filed实际上就是优化版的next，包括next和prev两个元素。data的数据格式为struct type, next是struct type*，prev是struct type**;</p>
<p>那么我们简单总结一下这个链表的结构。首先是head，head是个头指针，里面包含有第一个元素的指针。每个结点包含data和field两个部分。</p>
<p>就可以很好理解<code>LIST_NEXT(elm, field)</code> 这个宏函数了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> field<span class="token punctuation">.</span>le_next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看一下<code>LIST_FOREACH(var, head, field)</code>这个宏定义，这里给出了一种遍历链表的方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来实现<code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，也即是在listelm前面添加elm。</p>
<p>一般的双向链表有下面这个就够了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> listelm<span class="token punctuation">;</span>
<span class="token comment">// listelm-&gt;prev = elm; 类似这种的操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是由于添加了prev，需要更新elm和listelm的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> elm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里*的运算级是高于-&gt;的。</p>
<p>于是完成<code>LIST_INSERT_AFTER(listelm, elm, field)</code>就很简单了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> elm<span class="token punctuation">;</span>
elm<span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="tlb原理与重填策略">TLB原理与重填策略</span></h3>
<p>首先要分清这里是包括物理内存管理和虚拟内存管理两个东西的。</p>
<p>物理内存就是一个内核链表，地址空间也是连续的。</p>
<p>虚拟内存则是需要通过转化到物理内存来访问的。</p>
<p><strong>虚拟地址映射到物理地址</strong></p>
<ul>
<li>虚拟地址0x80000000-0x9fffffff，kseg0，将最高位置0得到物理地址，通过cache访问。这一部分<strong>用于存放内核代码与数据</strong>。</li>
<li>虚拟地址0xa0000000-0xbfffffff，kseg1，将最高3位置0得到物理地址，不通过cache访问。这一部分可以<strong>用于访问外设</strong>。</li>
<li>虚拟地址0x00000000-0x7fffffff，kuseg，通过TLB转换为物理地址，然后通过cache访存。这一部分用于<strong>存放用户程序代码与数据</strong></li>
</ul>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240406230222403.png" alt="image-20240406230222403"></p>
<p>其中只有kuseg部分需要用到TLB。</p>
<p>那么TLB本身是一个两级页表结构(MIPS中是的)。第一级是页目录Page Directory，第二级是页表Page Table。</p>
<p>这么看不容易理解。</p>
<p>一级页表项是31-22位，二级页表项是21-12位。11-0位则是页内偏移量。我们在TLB转化过程中只是为了确定是哪个物理页，因此我们不关注页内偏移量，照搬即可。</p>
<ul>
<li>首先通过查一级页表，得到二级页表中的首地址</li>
<li>然后通过二级页表得到虚拟地址对应的物理地址</li>
</ul>
<p>具体的实现还用到了很多的权限位。但这是代码上的实现了，和原理解耦开来。</p>
<h2><span id="实验体会">实验体会</span></h2>
<p>lab2真的是很难的一节，首先的List这个数据结构让我感到十分困惑，一度不能理解le_prev这个结构，我刚开始甚至认为这个无法直接访问前一个结点而认为这是一个单向页表，但是其后的页表插入删除操作却又不太合理了，后来一步步看一步步记录才看懂qaq。</p>
<p>确实是收获满满！<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab2</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab2笔记</title>
    <url>/2024/04/24/os-lab2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>#　lab2</p>
<p>首先我们需要关注<code>include</code>中的一些头文件以及其中定义的一些宏函数和静态内联函数。这些东西是真的难啊，让我觉得自己程设里面学的C语言和这里的不是一个东西。</p>
<ul>
<li>
<p>首先要知道这些宏定义对应的英文全称和中文释义。</p>
<blockquote>
<ol>
<li><code>NASID</code>：Node Abstract System Identifier，节点抽象系统标识符。</li>
<li><code>PAGE_SIZE</code>：Page Size，页面大小。</li>
<li><code>PTMAP</code>：Page Table Mapping，页表映射。</li>
<li><code>PDMAP</code>：Page Directory Mapping，页目录映射。</li>
<li><code>PGSHIFT</code>：Page Shift，页偏移。</li>
<li><code>PDSHIFT</code>：Page Directory Shift，页目录偏移。</li>
<li><code>PDX</code>：Page Directory Index，页目录索引。</li>
<li><code>PTX</code>：Page Table Index，页表索引。</li>
<li><code>PTE_ADDR</code>：Page Table Entry Address，页表条目地址。</li>
<li><code>PTE_FLAGS</code>：Page Table Entry Flags，页表条目标志。</li>
</ol>
</blockquote>
</li>
<li>
<p>从整体上来理解，首先要知道几个基本的东西是啥。</p>
</li>
</ul>
<p>其中包括Page_list和Page。<code>LIST_HEAD(Page_list, Page);</code>可以知道这几个对应在LIST中的几个基本要素。</p>
<p><code>typedef LIST_ENTRY(Page) Page_LIST_entry_t;</code>虽然感觉这个类型宏替换意义不大。</p>
<ul>
<li>LIST又是啥呢？这也好难，让我感觉自己的数据结构又是白学的<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
</ul>
<p>首先要坚信这个List就是我们学的那个链表，是一个双向链表。</p>
<p>这里的链表是有一个专门的头指针的，在ds中也有地方会这么用。(有一些好像还会有一些头发指针，头指针的前一个元素)这几个都是让链表的处理更加方便，也可以认为是大家认为链表的比较优雅的实现方式。</p>
<p>头指针：</p>
<p><code>LIST_HEAD(name, type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上是定义了一个结构体，给这个结构提一个名字比如head，实际上就是<code>LIST_HEAD(name, int) head;</code></p>
<p>宏替换后实际上就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">int</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么相应的一些与链表头指针的一些操作：</p>
<p><code>LIST_HEAD_INITIALIZER(head)</code></p>
<p>具体用法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_HRAD</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
head <span class="token operator">=</span> LIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于每个结点的指针部分实际上就是</p>
<p><code>LIST_ENTRY(type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里le_next可以理解，但是这个le_prev呢，这个给的注释也很奇怪，<code>address of previous next element</code>。这么来看，实际上就是将每个next指针作为一个element，那么prev就是前一个元素的这个指针。这样并不是双向链表那种，双向链表是多了一个指向前一个结点的大结点的地址的指针，也就是说可以通过这个指针直接访问前一个结点。而这个le_prev仅仅只是前一个元素的next这个元素的地址。</p>
<p>那么到这里其实就懂了，一个结点分为data和field。filed实际上就是优化版的next，包括next和prev两个元素。data的数据格式为struct type, next是struct type*，prev是struct type**;</p>
<p>那么我们简单总结一下这个链表的结构。首先是head，head是个头指针，里面包含有第一个元素的指针。每个结点包含data和field两个部分。</p>
<p>就可以很好理解<code>LIST_NEXT(elm, field)</code> 这个宏函数了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> field<span class="token punctuation">.</span>le_next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看一下<code>LIST_FOREACH(var, head, field)</code>这个宏定义，这里给出了一种遍历链表的方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来实现<code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，也即是在listelm前面添加elm。</p>
<p>一般的双向链表有下面这个就够了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> listelm<span class="token punctuation">;</span>
<span class="token comment">// listelm-&gt;prev = elm; 类似这种的操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是由于添加了prev，需要更新elm和listelm的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> elm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里*的运算级是高于-&gt;的。</p>
<p>于是完成<code>LIST_INSERT_AFTER(listelm, elm, field)</code>就很简单了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> elm<span class="token punctuation">;</span>
elm<span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="4kc访存流程">4Kc访存流程</span></h2>
<h3><span id="cpu发出地址">CPU发出地址</span></h3>
<h3><span id="虚拟地址映射到物理地址">虚拟地址映射到物理地址</span></h3>
<ul>
<li>虚拟地址0x80000000-0x9fffffff，kseg0，将最高位置0得到物理地址，通过cache访问。这一部分<strong>用于存放内核代码与数据</strong>。</li>
<li>虚拟地址0xa0000000-0xbfffffff，kseg1，将最高3位置0得到物理地址，不通过cache访问。这一部分可以<strong>用于访问外设</strong>。</li>
<li>虚拟地址0x00000000-0x7fffffff，kuseg，通过TLB转换为物理地址，然后通过cache访存。这一部分用于<strong>存放用户程序代码与数据</strong></li>
</ul>
<p><img src="/2024/04/24/os-lab2%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E7%AC%94%E8%AE%B0%5Cimage-20240406230222403.png" alt="image-20240406230222403"></p>
<h3><span id="内核程序启动">内核程序启动</span></h3>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab2</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab3实验报告</title>
    <url>/2024/04/24/os-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab3实验报告">Lab3实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-31">Thinking 3.1</span></h3>
<blockquote>
<p>请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)]= PADDR(e-&gt;env_pgdir) | PTE_V </code>的含义。</p>
</blockquote>
<p>0x7fc00000-0x80000000 这 4MB 空间的起始位置（也就是第一个二级页表的基地址）对应着页目录的第一个页目录项。同时由于 1M 个页表项和 4GB 地址空间是线性映射的，不难算出 0x7fc00000 这一个地址对应的应该是第 0x7fc00000 &gt;&gt; 12 个页表项。</p>
<p>每个页表项是<code>4B</code>，一共有<code>1M</code>个页表项，占据<code>4MB</code>的空间，正好是<code>UVPT</code>到<code>ULIM</code>这个<code>User VPT</code>这4MB的空间。页表自映射使得页目录的某一项正好映射到这个页表。由于线性性质，那么正好就是<code>UVPT &gt;&gt; 22</code>这个页目录中的一项就是页目录所在页表的物理地址。</p>
<p>后面就是页表的标志位了。</p>
<h3><span id="thinking-32">Thinking 3.2</span></h3>
<blockquote>
<p>elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p>
</blockquote>
<p>在<code>map_page()</code>中的参数<code>data</code>就是传入<code>elf_load_seg()</code>中传入的参数<code>data</code>，也就是在<code>load_icode()</code>中传入的参数<code>struct Env *e</code>，一个进程控制块。</p>
<p>在<code>map_page()</code>中<code>data</code>的作用为最后的<code>env</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是指定当前进程的页目录的内核虚拟地址，和该进程的<code>asid</code></p>
<p>不可以去掉这个参数，这是因为每个进程有自己的<code>tlb</code>，这个<code>tlb</code>是由<code>asid</code>确定的。</p>
<h3><span id="thinking-33">Thinking 3.3</span></h3>
<blockquote>
<p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p>
</blockquote>
<ol>
<li>当前页面不可写的情况：调整传入map_page()中断权限位</li>
<li>段头和页面不对齐的情况：注意开始的位置</li>
<li>创建页面不成功的情况：return</li>
<li>二进制文件大小小于段在内存的大小的情况：继续创建填充0的页面</li>
</ol>
<h3><span id="thinking-34">Thinking 3.4</span></h3>
<blockquote>
<p>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：</p>
<ul>
<li>你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</li>
</ul>
</blockquote>
<p>虚拟地址。</p>
<p>（lab2啥理解呀）应该是说在CPU看来都是虚拟地址，MIPS是有一个MMU的作为地址变换的。</p>
<h3><span id="thinking-35">Thinking 3.5</span></h3>
<blockquote>
<p>试找出 0、 1、 2、 3 号异常处理函数的具体实现位置。 8 号异常（系统调用）涉及的 do_syscall() 函数将在 Lab4 中实现</p>
</blockquote>
<p>在<code>kern/genex.S</code>中。</p>
<p>0号异常处理<code>handle_int</code>是处理时钟中断，其中主要是调用了<code>schedule</code>这个函数，但是这里还特判一下<code>$t1</code>是否为0这个我不太理解，理论上前面刚和<code>STATUS_IM7</code>这个做完与运算应该就不会是0才对。</p>
<p>1号异常，存储异常会执行<code>do_tlb_mod</code>，这个在<code>kern/tlbex.c</code>中实现</p>
<p>2、3号异常，<code>tlb</code>异常会执行<code>do_tlb_refill</code>，也就是tlb重填，这个在<code>kern/tlb_asm.S</code>中实现</p>
<h3><span id="thinking-36">Thinking 3.6</span></h3>
<blockquote>
<p>阅读 entry.S、 genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p>
</blockquote>
<p>在<code>entry.S</code>中的<code>handle_int</code>里面开启，时钟中断过程进入<code>schedule</code>函数，然后其中调用<code>env_run</code>，再调用<code>env_pop_tf</code>，，<code>env_pop_tf</code>的具体实现在<code>env_asm.S</code>中，其中调用<code>RESET_KCLOCK</code>，也就是在<code>include/kclock.h</code>中的实现。</p>
<h3><span id="thinking-37">Thinking 3.7</span></h3>
<blockquote>
<p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p>
</blockquote>
<p>根据3.6的分析，时钟中断后会调用<code>schedule</code>在这里面切换进程，具体而言包括保存上下文和进入新的进程的上下文环境，同时时钟初始化。</p>
<h2><span id="难点分析">难点分析</span></h2>
<p>本次lab其实主要包括两个部分，一个是进程方面，包括进程的创建和调度；一个是时钟中断方面。</p>
<p>实际上进程的创建和调度应该分开说，但是我认为这两个其实都是在软件层面上的实现(似乎这么说也不准确)，反正就这么说了罢。</p>
<p>本次lab的难点我认为主要在于对这几个的流程的理解。</p>
<h3><span id="进程创建与调度">进程创建与调度</span></h3>
<p>进程的创建是在内核态中执行的。</p>
<p>创建进程包括</p>
<ol>
<li>初始化Env 这个进程控制块，包括其中的一些变量的取值</li>
<li>在<code>struct Env</code>中还有一个关键的<code>env_pgdir</code>，这个就是确定虚拟地址</li>
<li>进程是运行中的程序，那这个程序从哪里来呢？这个在<code>load_icode</code>中加以实现，由于一个程序可以有多个进程，所以肯定不能用程序的那块内存空间直接操作，同时还有一些动态的空间需要进程创建，那么这块地址空间在哪呢，对于进程来说，他看到的都是自己的虚拟地址，就是这个了~</li>
</ol>
<p>进程调度实际上就是去掉这个进程然后把那个进程拉过来</p>
<ul>
<li>去掉这个进程：这一步需要保存CPU上下文信息，同时需要在两个队列中进行处理，包括空闲env区，和调度队列区</li>
<li>把新的进程拉过来：从调度队列拿一个过来，然后恢复他的上下文信息</li>
</ul>
<h3><span id="时钟中断">时钟中断</span></h3>
<p>我觉得这里主要是函数之间的调用挺复杂的，其实工作流程还是很好理解的</p>
<ul>
<li>handle_int</li>
<li>schedule</li>
<li>env_run</li>
<li>env_pop_tf</li>
</ul>
<p>害，真是中中又断断啊~</p>
<p>其中对于<code>kern/genex.S</code>中的<code>timer_irq</code>不甚了解，但是当我看到<code>guide_book</code>中的描述时(顺便吐槽一下，咋这还不相同的)，我好像懂了，或许是更加不同情况会进入不同的异常处理，只需要将<code>bnez</code>稍微调整为<code>beq</code>为某个特定的数就可以了，由于目前只实现了是时钟中断，因此一律调用这个就好啦~</p>
<p><img src="/2024/04/24/os-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240424011924754.png" alt="image-20240424011924754"></p>
<h2><span id="实验体会">实验体会</span></h2>
<p>在Lab2的时候说这个lab好难啊，在Lab3的时候也还是这么说。Lab2对于List的使用确实是我遇到的很大的一个障碍，这次使用起来更加得手了。</p>
<p>同时自己实现了一次进程后，对于比如“每个结构都有一个数据结构”、“linux一切皆文件”，这些有了更深的认识。</p>
<p>当需要实现某个具有特定功能的结构时，首要就是分析其数据结构，课程组似乎没有特别强调<code>env</code>的数据结构，其实处处都是优雅。基于上面这一点，进程其实就是一段地址空间，与“一切皆文件”的观点不谋而合。当然需要清楚到底是哪一段内存，是什么样子的内存。</p>
<p>这次还用到了更多<code>debug</code>的功能，下次可以多多研究<code>objdump</code>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab3</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab3笔记</title>
    <url>/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="lab3">lab3</span></h1>
<p>实验目的：</p>
<ul>
<li>创建一个进程，并成功运行</li>
<li>实现时钟中断，通过时钟中断内核获得执行权</li>
<li>实现进程调度，创建两个进程，通过时钟中断切换进程执行</li>
</ul>
<p>使用进程控制卡Env来跟踪用户进程，并建立一个简单的用户进程，加载一个程序镜像到指定的内存空间，并让它运行起来。</p>
<p>进程</p>
<ul>
<li>由于没有实现线程，进程既是基本的分配单元，也是基本的执行单元。</li>
<li>每个进程都是一个实体，有自己的地址空间，通常包括代码段、数据段和堆栈。</li>
<li>程序是一个没有声明的实体，只有被操作系统执行时才能称为一个活动的实体，而执行中的程序，就是进程</li>
</ul>
<p>PCB进程控制块</p>
<blockquote>
<p>本质就是一个数据结构</p>
</blockquote>
<p><code>env_init</code></p>
<blockquote>
<p>traverse 是遍历的意思</p>
</blockquote>
<p>段地址映射</p>
<p>为<code>base_pgdir</code>分配了一页物理内存，将其转换为内核虚拟地址，并使用<code>map_segment</code>来进行映射。</p>
<ul>
<li><code>pages</code>映射到<code>UPAGES</code></li>
<li><code>envs</code>映射到<code>UENVS</code></li>
</ul>
<p>其中补全的部分我是这么写的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span><span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token function">pa2page</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">page_insert</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> asid<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其实可以把pp直接替换为中间那一部分。</p>
<p>注意是<code>va+i</code>和<code>pa+i</code></p>
<p>进程的标识</p>
<blockquote>
<p>就是<code>env_id</code></p>
</blockquote>
<p>这里用自己的话解释一下为什么还需要一个<code>asid</code></p>
<p>实际上是为了让每一个进程有一个自己的<code>tlb</code>，这样当这个进程结束时(或者进程切换的时候)只需要把这个进程的<code>tlb</code>刷新掉即可。</p>
<p>既然需要有一个自己的<code>tlb</code>那就得有一个标识符，那为什么不直接用<code>env_id</code>呢，我认为主要是为了让<code>tlb</code>只有有限个，太多了就炸内存了，这波属于是宁愿少点，不能多了。</p>
<p>创建进程</p>
<blockquote>
<p>终于开始创建进程了</p>
</blockquote>
<p>实际上创建进程在不考虑进程的交互性(也就是说这是个活的实体)，实际上就是个数据结构，那么相应的数据结构就是<code>PCB</code>进程控制块。</p>
<p>因此也可以理解为设置一个进程控制块。</p>
<ul>
<li>设置进程控制块实际上是告诉了我们这个进程是什么</li>
<li>那么进程还要有自己的地址空间，包括代码段、数据段和堆栈</li>
</ul>
<p>OK，这里开始解释后面的进程调度和中断的开启。</p>
<p>在MIPS处理器中，中断是由硬件控制的，也就是<code>CP0</code>寄存器中保存着我们需要的信息。</p>
<p>那么具体是如何设置的呢？</p>
<p>这里我们考虑的相对简单，还只开启了时钟中断。</p>
<blockquote>
<p>这里就是需要将<code>IM7</code>设置为1，表示时钟中断可以被响应，同时还有<code>IE</code>位，也就是<code>Interupt Enable</code>中断使能位要打开才能正确的中断</p>
</blockquote>
<p>还有第二个问题，中断需要调度进程，同时需要进入内核态。</p>
<blockquote>
<p>害，理论是真的很重要！！！</p>
</blockquote>
<p>用户态的标志：<code>EXL=0, UM=1</code></p>
<p>其他都是内核态</p>
<p>那么如果我们刚开始在内核态接受到了时钟中断，中断结束后我们还应当是在内核态，但是由于</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">eret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令在所有进程调度的最后都会被执行，同时<code>eret</code>会进<code>EXL</code>设置为0(也就是希望返回到用户态)，因此我们还需要手动维护一下<code>EXL</code>使得保持在内核态。</p>
<p>elf简单复习一下</p>
<p>ELF文件结构为：</p>
<ul>
<li>ELF头，包括程序的基本信息，比如体系结构和操作系统，同时也把包括了节头表和段头表相对文件的偏移量offset</li>
<li>段头表，program header table ，主要包含程序中各个段segment的信息，段的信息需要在运行时刻使用</li>
<li>节头表，section header table，主要包括程序中各个节section的信息，节的信息需要在程序编译和链接的时候使用</li>
</ul>
<p>加载二进制文件</p>
<p>ELF文件的类型有三种：可重定位文件，可执行文件，可被共享的对象文件。</p>
<p>这里指可执行文件</p>
<p>要加载一个ELF文件到内存，只需要将其中所有需要加载的program segment程序段到对应的虚拟地址上即可。(这里我认为主要是因为这里是可执行文件，所以只需要将各个需要在运行时刻使用的信息存放过去即可)</p>
<p>目前还是在内核态，<code>alloc</code>的一个页面是一个物理页面。</p>
<p>要得到其物理地址，由于是内核态，因此需要调用<code>page2kva</code>来得到物理地址。</p>
<p>这一点从<code>page_alloc()</code>中的<code>memset((void*)page2kva(pp),0,PAGE_SIZE);</code>可以初见端倪。</p>
<p>而且本身也非常合理。</p>
<p>给进程分配地址空间，实际上是将可执行文件的信息进行复制。</p>
<p>这里用到了一个回调函数，还算比较好理解。</p>
<p><code>load_icode</code>函数最后需要将<code>env_tf.cp0_epc</code>设置为<code>e_entry</code>，这个是说当执行进程时还是需要从最开始这个可执行文件的开始位置开始执行。</p>
<p>创建进程</p>
<p>进程控制块也设置好了，地址空间也安排好了，终于可以创建进程了。</p>
<p>这里的创建进程是在内核初始化时直接创建进程。</p>
<ol>
<li>分配一个新的Env结构体</li>
<li>设置进程控制块</li>
<li>将程序载入到进程的地址空间</li>
</ol>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240422043001149.png" alt="image-20240422043001149"></p>
<p>这里可以修改为</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进程运行与切换</p>
<p>要运行一个进程：</p>
<ul>
<li>需要保存当前进程的上下文(如果当前没有进程就pass)</li>
<li>恢复要启动的进程的上下文，然后运行该进程</li>
</ul>
<p>进程的上下文朴素的理解就是当时运行这个进程时硬件的情况，也就是各个寄存器的状态，也就是<code>Trapframe</code>的内容</p>
<p>包括</p>
<ul>
<li>通用寄存器</li>
<li><code>HI</code>、<code>LO</code></li>
<li>CP0的<code>Status</code>、<code>EPC</code>、<code>Cause</code>和<code>BadVAddr</code>寄存器</li>
</ul>
<p>在这里寄存器状态保存的地方是<code>KSTACKTOP</code>以下的大小为<code>TrapFrame</code>的区域</p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240422044027836.png" alt="image-20240422044027836"></p>
<p>运行一个进程：</p>
<ol>
<li>保存当前进程的上下文信息(没有就开摆)</li>
<li>切换<code>curenv</code>为即将运行的进程(这里还没有切换)</li>
<li>设置全局变量<code>cur_pgdir</code>为当前进程的页目录地址，在<code>TLB</code>重填是将用到这个全局变量</li>
<li>调用<code>env_top_tf</code>函数，恢复现场(就是即将运行的进程的现场/上下文信息)、异常返回</li>
</ol>
<p>中断与异常</p>
<p>CP0寄存器</p>
<ul>
<li>Status 状态寄存器，包括中断引脚使能，其他CPU模式等位域</li>
<li>Cause 记录导致异常的原因</li>
<li>EPC 异常结束后程序恢复执行的位置</li>
</ul>
<p>处理异常是由硬件完成的，MIPS CPU处理一个异常的步骤包括</p>
<ol>
<li>设置EPC指向从异常返回的地址</li>
<li>设置EXL位，强制CPU进入内核态，并禁止中断</li>
<li>设置Cause寄存器，记录异常发生的原因</li>
<li>CPU从异常入口位置取指，此后交给软件处理，也即是我们的操作系统来处理</li>
</ol>
<h2><span id="梳理">梳理</span></h2>
<p>这里再把整个流程进行梳理</p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240424160053472.png" alt></p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240424160152458.png" alt="image-20240424160152458"></p>
<h3><span id="进程创建">进程创建</span></h3>
<h2><span id="几个问题">几个问题</span></h2>
<ol>
<li>
<p><code>tests/lab3_*</code>这几个里面的<code>pre_env_run.c</code>是干嘛用的，<code>tests/lab3_4</code>还有个<code>quick_sort.c</code>是干嘛的</p>
<blockquote>
<p>第一直觉感觉是创建一个进程，但是仔细一看还是不太清楚</p>
</blockquote>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab3</tag>
      </tags>
  </entry>
  <entry>
    <title>overleaf</title>
    <url>/2024/04/24/overleaf/</url>
    <content><![CDATA[<h1><span id="hugo-overleaf">hugo-overleaf</span></h1>
<p>overleaf本地挂载</p>
<blockquote>
<p>确保已经安装docker docker-compose</p>
</blockquote>
<p>从github上面进行clone</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/overleaf/toolkit.git ./overleaf-toolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进入文件夹</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ./overleaf-toolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进行配置</p>
<pre class="line-numbers language-none"><code class="language-none">bin/init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>停止</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="可能遇到的问题">可能遇到的问题</span></h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ERROR: <span class="token keyword">for</span> mongo  Cannot create container <span class="token keyword">for</span> <span class="token function">service</span> mongo: Conflict. The container name <span class="token string">"/mongo"</span> is already <span class="token keyword">in</span> use by container <span class="token string">"1d7159660aa3687523944402c6650d7bea3576f4e9f281ab8df9f39b25452389"</span><span class="token builtin class-name">.</span> You have to remove <span class="token punctuation">(</span>or <span class="token function">rename</span><span class="token punctuation">)</span> that container to be able to reuse that name.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是由于docker作为一个容器，宿主机防火墙设置发生变化时，无法设置容器的ip，需要重启即可</p>
<p>解决方法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> <span class="token function">docker</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1><span id="quick-start-guide">Quick-Start Guide</span></h1>
<h2><span id="prerequisites">Prerequisites</span></h2>
<p>The Overleaf Toolkit depends on the following programs:</p>
<ul>
<li>bash</li>
<li>docker</li>
</ul>
<p>We recommend that you install the most recent version of docker that is<br>
available on your system.</p>
<h2><span id="install">Install</span></h2>
<p>First, let’s clone this git repository to your machine:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/overleaf/toolkit.git ./overleaf-toolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Next let’s move into this directory:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ./overleaf-toolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>For the rest of this guide, we will assume that you will run all subsequent commands from this directory.</p>
<h2><span id="take-a-look-around">Take a Look Around</span></h2>
<p>Let’s take a look at the structure of the repository:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Which will print something like this:</p>
<pre class="line-numbers language-none"><code class="language-none">bin
CHANGELOG.md
config
data
doc
lib
LICENSE
README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The <code>README.md</code> file contains some useful information about the project, while the <code>doc</code> directory contains all of the documentation you will need to use the toolkit. The <code>config</code> directory will contain your own local configuration files (which we will create in just a moment), while the <code>bin</code> directory contains a collection of scripts that manage your overleaf instance.</p>
<h2><span id="initialise-configuration">Initialise Configuration</span></h2>
<p>Let’s create our local configuration, by running <code>bin/init</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Now check the contents of the <code>config/</code> directory</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> config
overleaf.rc     variables.env     version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>These are the three configuration files you will interact with:</p>
<ul>
<li><code>overleaf.rc</code> : the main top-level configuration file</li>
<li><code>variables.env</code> : environment variables loaded into the docker container</li>
<li><code>version</code> : the version of the docker images to use</li>
</ul>
<h2><span id="starting-up">Starting Up</span></h2>
<p>The Overleaf Toolkit uses <code>docker compose</code> to manage the overleaf docker containers. The toolkit provides a set of scripts which wrap <code>docker compose</code>, and take care of most of the details for you.</p>
<p>Let’s start the docker services:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>You should see some log output from the docker containers, indicating that the containers are running.<br>
If you press <code>CTRL-C</code> at the terminal, the services will shut down. You can start them up again (without attaching to the log output) by running <code>bin/start</code>. More generally, you can run <code>bin/docker-compose</code> to control the <code>docker compose</code> system directly, if you find that the convenience scripts don’t cover your use-case.</p>
<h2><span id="create-the-first-admin-account">Create the first admin account</span></h2>
<p>In a browser, open <a href="http://localhost/launchpad">http://localhost/launchpad</a>. You should see a form with email and password fields.<br>
Fill these in with the credentials you want to use as the admin account, then click “Register”.</p>
<p>Then click the link to go to the login page (<a href="http://localhost/login">http://localhost/login</a>). Enter the credentials.<br>
Once you are logged in, you will be taken to a welcome page.</p>
<p>Click the green button at the bottom of the page to start using Overleaf.</p>
<h2><span id="create-your-first-project">Create your first project</span></h2>
<p>On the <a href="http://localhost/project">http://localhost/project</a> page, you will see a button prompting you to create your first<br>
project. Click the button and follow the instructions.</p>
<p>You should then be taken to the new project, where you will see a text editor and a PDF preview.</p>
<h2><span id="optional-check-the-logs">(Optional) Check the logs</span></h2>
<p>Let’s look at the logs inside the container:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/logs <span class="token parameter variable">-f</span> web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>You can also look at the logs for multiple services at once:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/logs <span class="token parameter variable">-f</span> filestore docstore web clsi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="tls-proxy">TLS Proxy</span></h2>
<p>The Overleaf Toolkit includes optional configuration to run an NGINX proxy, which presents Server Pro over HTTPS. Initial configuration can be generated by running</p>
<pre class="line-numbers language-none"><code class="language-none">bin/init --tls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This creates minimal NGINX config in <code>config/nginx/nginx.conf</code> and a sample TLS certificate and private key in <code>config/nginx/certs/overleaf_certificate.pem</code> and <code>config/nginx/certs/overleaf_key.pem</code> respectively. If you already have a signed TLS certificate for use with Server Pro, replace the sample key and certificate with your key and certificate.</p>
<p>In order to run the proxy, change the value of the <code>NGINX_ENABLED</code> variable in <code>config/overleaf.rc</code> from <code>false</code> to <code>true</code> and re-run <code>bin/up</code>.</p>
<p>Further information about the TLS proxy can be found in the <a href="tls-proxy.md">docs</a>.</p>
<h2><span id="consulting-the-doctor">Consulting the Doctor</span></h2>
<p>The Overleaf Toolkit comes with a handy tool for debugging your installation: <code>bin/doctor</code></p>
<p>Let’s run the <code>bin/doctor</code> script:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin/doctor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>We should see some output similar to this:</p>
<pre class="line-numbers language-none"><code class="language-none">====== Overleaf Doctor ======
- Host Information
    - Linux
    ...
- Dependencies
    - bash
        - status: present
        - version info: 5.0.17(1)-release
    - docker
        - status: present
        - version info: Docker version 23.06.6, build 369ce74a3c
    - docker compose
        - status: present
        - version info: docker compose version v2.17.3
    ...
====== Configuration ======
    ...
====== Warnings ======
- None, all good
====== End ======<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>First, we see some information about the host system (the machine that the toolkit is being run on), then some information about dependencies. If any dependencies are missing, we will see a warning here. Next, the doctor checks our local configuration. At the end, the doctor will print out some warnings, if any problems were encountered.</p>
<p>When you run into problems with your toolkit, you should first run the doctor script and check it’s output.</p>
<h2><span id="getting-help">Getting Help</span></h2>
<p>Users of the free Community Edition should <a href="https://github.com/overleaf/toolkit/issues">open an issue on github</a>.</p>
<p>Users of Server Pro should contact <code>support@overleaf.com</code> for assistance.</p>
<p>In both cases, it is a good idea to include the output of the <code>bin/doctor</code> script in your message.</p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>overleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>p3-CPU-设计文档</title>
    <url>/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1><span id="单周期mips架构cpu的logisim实现">单周期mips架构CPU的logisim实现</span></h1>
<p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p>
<span id="more"></span>
<h2><span id="数据路径">数据路径</span></h2>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>Stop</td>
<td>I</td>
<td>1</td>
<td>停止信号</td>
</tr>
<tr>
<td>PC’</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
<tr>
<td>Instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
<tr>
<td>4</td>
<td>取指令</td>
<td>根据当前 PC 的值从 IM（指令存储器）中读出对应的指令到 Instr 端口</td>
</tr>
</tbody>
</table>
<h4><span id="pc程序计数器">PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>Stop</td>
<td>I</td>
<td>1</td>
<td>停止信号</td>
</tr>
<tr>
<td>PC’</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="im指令存储器">IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>Instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>Branch</td>
<td>I</td>
<td>1</td>
<td>是否为Branch型指令，控制信号</td>
</tr>
<tr>
<td>Equals</td>
<td>I</td>
<td>1</td>
<td>是否满足Branch跳转判断</td>
</tr>
<tr>
<td>Offset</td>
<td>I</td>
<td>32</td>
<td>进行符号拓展后的立即数信号<br>Branch &amp; Equals==1:b型跳转</td>
</tr>
<tr>
<td>JUMP</td>
<td>I</td>
<td>1</td>
<td>是否为j指令或者jal指令，控制信号<br>1：J型跳转</td>
</tr>
<tr>
<td>Imm_26</td>
<td>I</td>
<td>26</td>
<td>26位立即数信号，拓展后即为跳转地址</td>
</tr>
<tr>
<td>JR</td>
<td>I</td>
<td>1</td>
<td>是否为jr或者jalr指令，控制信号<br>1：JR型跳转</td>
</tr>
<tr>
<td>Ra</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165252314.png" alt="image-20240221165252314"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165258299.png" alt="image-20240221165258299"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165302941.png" alt="image-20240221165302941"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="ext拓展单元">EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Imm_16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>UnsignedExt</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>Imm_32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>0000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>0001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>0010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>0011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>0100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>0101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>0110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>0111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>1000</td>
<td>ALURes = SrcA &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>1001</td>
<td>ALURes = SrcA &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>1010</td>
<td>ALURes = SrcA &gt;&gt; Shift</td>
</tr>
<tr>
<td>相等</td>
<td>equal</td>
<td>1011</td>
<td>ALURes = (SrcA == SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>有符号小于</td>
<td>signed_less</td>
<td>1100</td>
<td>ALURes = (SrcA &lt; SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>无符号小于</td>
<td>unsigned_less</td>
<td>1101</td>
<td>ALURes = (u_SrcA &lt; u_SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>有符号大于</td>
<td>signed_bigger</td>
<td>1110</td>
<td>ALURes = (SrcA &gt; SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>无符号大于</td>
<td>unsigned_bigger</td>
<td>1111</td>
<td>ALURes = (u_SrcA &gt; u_SrcB) ? 1 : 0</td>
</tr>
</tbody>
</table>
<h3><span id="dm数据存储器">DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="控制">控制</span></h2>
<h3><span id="cu">CU</span></h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p>
<p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p>
<p>其次从CU的角度开始处理指令。</p>
<p>第一步，<strong>输入信号</strong>。</p>
<p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p>
<p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p>
<p>然后利用<code>Or Logical</code>，来激活相应的接口。</p>
<p>第二步，对于<strong>lw指令</strong>。</p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165310365.png" alt="image-20240221165310365"></p>
<p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p>
<p>第三步，对于<strong>sw信号</strong>。</p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165317549.png" alt="image-20240221165317549"></p>
<p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p>
<p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p>
<h2><span id="自动化测试">自动化测试</span></h2>
<h2><span id="思考题">思考题</span></h2>
<ul>
<li>
<p>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p>
<blockquote>
<p>状态存储交给寄存器来搞定，包括IFU里面的指令寄存器和GRF里面的32个寄存器。其他的期间几乎都是在完成状态转移功能。</p>
</blockquote>
</li>
<li>
<p>现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p>
<blockquote>
<p>合理的，正确的，中肯定，毋庸置疑的</p>
</blockquote>
</li>
<li>
<p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p>
<blockquote>
<p>如果非要说的，或许可以实现一个分线器Splitter？将各部分信号传出来的一个元件，当然这几个就可以实现一个基本的mips单周期cpu</p>
</blockquote>
</li>
<li>
<p>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p>
<blockquote>
<p>等价于sll 0位，或者认为是不进行任何操作处理。</p>
</blockquote>
</li>
<li>
<p>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p>
<blockquote>
<p>强度不行。指令并有覆盖到所有可能的情况，包括使用到的寄存器，是否考虑溢出情况等。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p3</tag>
      </tags>
  </entry>
  <entry>
    <title>p4-CPU-设计文档</title>
    <url>/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1><span id="单周期mips架构cpu的verilog实现">单周期mips架构CPU的verilog实现</span></h1>
<p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p>
<h2><span id="数据路径">数据路径</span></h2>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="pc程序计数器">PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="im指令存储器">IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>Imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>regAddr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>PC+4</td>
<td>O</td>
<td>32</td>
<td>输出PC+4的值</td>
</tr>
<tr>
<td>npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC_4</td>
<td>2</td>
<td>2‘b00</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>2</td>
<td>2’b01</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>2</td>
<td>2’b10</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>2</td>
<td>2’b11</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165229781.png" alt="image-20240221165229781"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165224329.png" alt="image-20240221165224329"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165218734.png" alt="image-20240221165218734"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="ext拓展单元">EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>extUnsignedSel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>0000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>0001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>0010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>0011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>0100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>0101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>0110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>0111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>1000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>1001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>1010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="dm数据存储器">DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>dmWriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="splitter">Splitter</span></h3>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>I</td>
<td>32</td>
<td>输入指令信号</td>
</tr>
<tr>
<td>opcode</td>
<td>O</td>
<td>6</td>
<td>instr[31:26]</td>
</tr>
<tr>
<td>rs</td>
<td>O</td>
<td>5</td>
<td>instr[25:21]</td>
</tr>
<tr>
<td>base</td>
<td>O</td>
<td>5</td>
<td>instr[25:21]</td>
</tr>
<tr>
<td>rt</td>
<td>O</td>
<td>5</td>
<td>instr[20:16]</td>
</tr>
<tr>
<td>rd</td>
<td>O</td>
<td>5</td>
<td>instr[15:11]</td>
</tr>
<tr>
<td>sa</td>
<td>O</td>
<td>5</td>
<td>instr[10:6]</td>
</tr>
<tr>
<td>func</td>
<td>O</td>
<td>6</td>
<td>instr[5:0]</td>
</tr>
<tr>
<td>imm26</td>
<td>O</td>
<td>26</td>
<td>instr[25:0]</td>
</tr>
<tr>
<td>imm16</td>
<td>O</td>
<td>16</td>
<td>instr[15:0]</td>
</tr>
</tbody>
</table>
<h3><span id="cmp">CMP</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>值</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="控制">控制</span></h2>
<h3><span id="cu">CU</span></h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p>
<p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p>
<p>其次从CU的角度开始处理指令。</p>
<p>第一步，<strong>输入信号</strong>。</p>
<p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p>
<p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p>
<p>然后利用<code>Or Logical</code>，来激活相应的接口。</p>
<p>第二步，对于<strong>lw指令</strong>。</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165208821.png" alt="image-20240221165208821"></p>
<p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p>
<p>第三步，对于<strong>sw信号</strong>。</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165204960.png" alt="image-20240221165204960"></p>
<p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p>
<p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p>
<h2><span id="自动化测试">自动化测试</span></h2>
<h2><span id="思考题">思考题</span></h2>
<ul>
<li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024 字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</li>
</ul>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165157185.png" alt="image-20240221165157185"></p>
<blockquote>
<p>addr信号来自于ALU。因为是按字存储的，每四个byte一个字节。</p>
</blockquote>
<ul>
<li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</li>
</ul>
<blockquote>
<p>记录指令的控制信号如何取值</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
     <span class="token function">if</span><span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
         <span class="token function">case</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> 
             <span class="token number">6'b100000</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>
                 npcOp <span class="token operator">==</span> <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span>
                 writeRegSel <span class="token operator">==</span> <span class="token constant">`CU_GRF_A3_RD</span><span class="token punctuation">;</span>
                 grfWriteEn <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>
             <span class="token keyword">end</span>
         <span class="token keyword">endcase</span>
     <span class="token keyword">end</span>
     <span class="token keyword">else</span> <span class="token keyword">begin</span>
         <span class="token keyword">case</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">:</span>
             <span class="token constant">`CU_add_OP</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>

         <span class="token keyword">end</span>
     <span class="token keyword">endcase</span>
             <span class="token keyword">end</span>
 <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>记录控制信号每种取值所对应的指令</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> npcOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`NPC_B</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>j <span class="token operator">|</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>jr<span class="token punctuation">)</span>      <span class="token operator">?</span> <span class="token constant">`NPC_JR</span><span class="token punctuation">:</span>
                           <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> writeRegSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> sll<span class="token punctuation">)</span>       <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">:</span>
                     <span class="token punctuation">(</span>ori <span class="token operator">|</span> lw  <span class="token operator">|</span> sw <span class="token operator">|</span> lui <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RT</span> <span class="token punctuation">:</span>
                     <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                   <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RA</span> <span class="token punctuation">:</span>
                                               <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> grfWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll <span class="token operator">|</span> jal <span class="token operator">|</span> lw<span class="token punctuation">)</span> <span class="token operator">?</span>  <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> writeRegDataSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_ALURESULT</span> <span class="token punctuation">:</span>
                         <span class="token punctuation">(</span>lw<span class="token punctuation">)</span>                          <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_MEMRD</span> <span class="token punctuation">:</span>
                         <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                         <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_PC_4</span> <span class="token punctuation">:</span>
                                                         <span class="token constant">`CU_GRF_WD_ALURESULT</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> extUnsignedSel <span class="token operator">=</span> <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> aluSrcSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> beq <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">:</span>
                   <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span>   <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_IMM32</span>  <span class="token punctuation">:</span>
                                             <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> shamtSel <span class="token operator">=</span> <span class="token punctuation">(</span>lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_16</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span> <span class="token punctuation">:</span>
                          <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> aluOp <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ALU_add</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>sub<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_sub</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>ori<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_or</span>  <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>lui <span class="token operator">|</span> sll<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`ALU_sll</span> <span class="token punctuation">:</span>
                                 <span class="token constant">`ALU_add</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> dmWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> dmOp <span class="token operator">=</span> <span class="token punctuation">(</span>lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`DM_WORD</span> <span class="token punctuation">:</span>
                          <span class="token constant">`DM_WORD</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> branchOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bne<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_NOT_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bge<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER_OR_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>ble<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS_OR_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>blt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bgt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER</span> <span class="token punctuation">:</span>
                          <span class="token constant">`CMP_EQUAL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>记录指令的控制信号如何取值，更加方便记录追踪每一条指令的问题。这个对于增加指令也比较方便。</li>
<li>记录控制信号每种取值所对应的指令，方便看某一个控制指令的组成</li>
</ul>
</blockquote>
<ul>
<li>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</li>
</ul>
<blockquote>
<p>同步复位中，clk信号优先于reset信号。</p>
<p>异步复位中，reset信号优先于clk信号。</p>
</blockquote>
<ul>
<li>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</li>
</ul>
<blockquote>
<p>addi和addiu的区别，add和addu的区别在于addi和add在溢出是会报溢出异常，忽略溢出二者自然就相同了嘛。</p>
<ul>
<li>
<p>add</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165124611.png" alt="image-20240221165124611"></p>
</li>
<li>
<p>addu</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165132920.png" alt="image-20240221165132920"></p>
</li>
<li>
<p>addi</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165139866.png" alt="image-20240221165139866"></p>
</li>
<li>
<p>addiu</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165148096.png" alt="image-20240221165148096"></p>
</li>
</ul>
</blockquote>
<h2><span id="命名的合理性">命名的合理性</span></h2>
<p>元件统一大驼峰（首字母大写）</p>
<p>接口连线统一小驼峰（首字母小写），单个字母仍然使用大写以保证美观。（想了想GRF还是采用以前的A1这种命名吧，不然感觉好奇怪。</p>
<p><strong>操作控制</strong>：选择信号以Op结尾</p>
<p><strong>写使能控制</strong>：使能信号以En结尾</p>
<p><strong>多路控制</strong>：多路选择器开关信号以Sel结尾。</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p4</tag>
      </tags>
  </entry>
  <entry>
    <title>p7-知识点整理</title>
    <url>/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1><span id="mips-微系统">mips 微系统</span></h1>
<h2><span id="cp0协处理器">CP0协处理器</span></h2>
<h3><span id="cpu-控制寄存器"><strong>CPU 控制寄存器</strong></span></h3>
<table>
<thead>
<tr>
<th>寄存器助记符</th>
<th>寄存器编号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SR</td>
<td>12</td>
<td>State Register</td>
</tr>
<tr>
<td>Cause</td>
<td>13</td>
<td>记录异常中断的原因</td>
</tr>
<tr>
<td>EPC</td>
<td>14</td>
<td>Exception program counter发生异常和中断后从哪里重新开始执行</td>
</tr>
</tbody>
</table>
<h4><span id="sr"><strong>SR</strong></span></h4>
<p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206164953902.png" alt="image-20231206164953902"></p>
<p>这里我们实际使用到的或者说有意义的只有</p>
<p><strong>IM——SR[15:10]</strong></p>
<blockquote>
<p>其实这里应该指的是SR[15:8]的这8位，其中IP1-0也就是SR[9:8]是由CPU内部产生的</p>
</blockquote>
<ul>
<li>中断屏蔽：一个8位的域定义哪些允许中断源活动时产生异常。其中6个中断源由CPU核外部的信号产生。其余两个是Cause寄存器中软件可写的中断位</li>
</ul>
<p><strong>EXL——SR[1]</strong></p>
<ul>
<li>异常级：任何异常发生时置位，这会强行进入核心态并禁止中断：目的是吧EXL位维持足够长的时间以便软件决定新的CPU特权级和中断屏蔽该设成什么</li>
</ul>
<p><strong>IE——SR[0]</strong></p>
<ul>
<li>全局的中断使能位：注意不管这位是什么值，EXL和ERL总是禁止所有的中断</li>
</ul>
<h4><span id="cause"><strong>Cause</strong></span></h4>
<p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206170514085.png" alt="image-20231206170514085"></p>
<p><strong>BD——Cause[31]</strong></p>
<ul>
<li>
<p>分支延迟：EPC保存的是异常处理完之后的返回地址，正常情况下，这也指向异常受害指令。</p>
</li>
<li>
<p>但是如果发生异常的指令是在一条转移指令的延时槽里，EPC得指向那条转移指令：重新执行转移指令没有- 什么害处，但是如果返回到延迟槽指令本身，转移就不会发生，从而这个异常将破坏被中断的程序。</p>
</li>
<li>
<p>只要异常发生在延迟槽的指令，Cause(BD)就会置为，EPC就会指向分支指令。如果想要分析异常受害指令，只要看看Cause(BD)(如果Cause(BD)==1，那么该指令位于EPC+4)就知道了。</p>
</li>
</ul>
<p><strong>IP——Cause[15:10]</strong></p>
<blockquote>
<p>这里其实也是IM一个道理</p>
</blockquote>
<p>待决的中断：这里表示待发生的中断。IP照抄CPU硬件的输入信号，<code>IP1-0</code>（软件中断位）可读可写包含你最近写入的值。</p>
<ul>
<li>当相应的<code>SR(IM)</code>位（还要受到其它禁止中断的条件约束）允许时，这八位中的任意以为活动都会导致一个中断</li>
</ul>
<p><strong>BD——Cause[6:2]</strong></p>
<p>这是一个5位的编码，告诉你发生了哪种异常。</p>
<table>
<thead>
<tr>
<th>ExcCode</th>
<th>助记符</th>
<th>指令与指令类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Int</td>
<td>所有指令</td>
<td>中断</td>
</tr>
<tr>
<td>4</td>
<td>AdEL</td>
<td>所有指令<br>load型指令（或特指其中某型）</td>
<td>（取数，取指或者存数时）地址错误：<br>PC地址未字对齐<br>PC地址超过0x3000-0x6ffc<br><br> （取数，取指或者存数时）地址错误：<br><strong>lw</strong>：取数地址未与4字节对齐<br><strong>lh</strong>：取数地址未与2字节对齐<br><strong>lh，lb</strong>：取Timer</td>
</tr>
<tr>
<td>5</td>
<td>AdES</td>
<td>store型指令</td>
<td>（取数，取指或者存数时）地址错误：<br><strong>sw</strong>：存数地址未4字节对齐<br><strong>sh</strong>：存数地址未2字节对齐<br><strong>sh，sb</strong>：存Timer寄存器的值<br>store型指令：<br>计算地址加法溢出<br>向计时器的Count寄存器存值<br>存数地址超过DM，Timer0，Timer1，中断发生器的范围</td>
</tr>
<tr>
<td>8</td>
<td>Syscall</td>
<td>syscall</td>
<td>系统调用，执行了一条syscall指令</td>
</tr>
<tr>
<td>10</td>
<td>RI</td>
<td></td>
<td>出现未知的指令码</td>
</tr>
<tr>
<td>12</td>
<td>Ov</td>
<td>add,addi,sub</td>
<td>算数溢出</td>
</tr>
</tbody>
</table>
<h4><span id="epc">EPC</span></h4>
<p>异常返回地址寄存器。这是一个博爱村异常返回点的寄存器。导致（或者遭受）异常的指令地址存入EPC，除非Cause寄存器中的BD位置位了，这种情况下EPC指向前一条（分支）指令</p>
<p>​	<strong>CPU控制指令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mtc0</td>
<td>s,&lt;n&gt;</td>
<td>把数据传送到CP0<br>把CPU通用寄存器s中的内容传送到CP0的寄存器n<br>数据为32位</td>
</tr>
<tr>
<td>mfc0</td>
<td>d,&lt;n&gt;</td>
<td>从协处理器中取出数据<br>通用寄存器d中装入CPU控制寄存器n的值<br>这是查看控制寄存器的值的唯一方式</td>
</tr>
</tbody>
</table>
<p>关于mfc0</p>
<p>想要更新控制寄存器中的单个域——比如说——状态寄存器SR</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mfc0 t0, SR
and  t0, &lt;要清零的为的反码&gt;
or   t0, &lt;要置1的位&gt;
mtc0 SR, t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这里有一个比较抽象的话后续再来理解一下</p>
<p>即返回到用户态和改变特权级的操作必须是同步的，不可分的（原文只讲了不可分的，我的理解就是同步的进行操作）</p>
<p>用软件触发的异常——异常调用——作为用户代码请求（运行在高特权级上的）操作系统内核服务的唯一机制。</p>
</blockquote>
<p><strong>什么时候需要用到哪些寄存器</strong></p>
<blockquote>
<p>这里是针对CP0中的控制寄存器而言的</p>
</blockquote>
<p><strong>上电后：</strong></p>
<p>设置SR来使CPU进入一个可工作的状态</p>
<p><strong>处理任意异常：</strong></p>
<ul>
<li>
<p>早期：调用一个固定入口地址的公共的“通用异常处理程序”</p>
</li>
<li>
<p>自那以后：对不同目的使用分开的异常处理程序</p>
</li>
</ul>
<p>在异常入口处：不保存任何程序寄存器，只有返回地址被存在EPC中。</p>
<p><strong>从异常返回：</strong></p>
<ol>
<li>控制最终必须返回到异常入口处保存到EPC中的地址。</li>
<li>不管是什么异常，返回时都需要报SR寄存器调整回原来的值，恢复用户态特权、允许中断以及消除异常的一般影响</li>
<li>异常返回指令eret合并完成了返回用户空间和复位SR(EXL)的功能</li>
</ol>
<p><strong>中断：</strong></p>
<p>SR用来调整中断掩码（掩码就是一串二进制码，掩码的作用是用来存储和操作“状态”）</p>
<p><strong>纯粹为了引发异常的指令：</strong></p>
<p>比如<code>break</code>和<code>syscall</code></p>
<h2><span id="异常-中断及初始化">异常、中断及初始化</span></h2>
<ul>
<li>外部事件：在CPU核之外的时间——即来自于真实的“连线”上的输入信号，这就是中断。</li>
<li>存储器地址转换异常</li>
<li>程序或硬件检测到的错误：这些包括不存在的指令、在用户权限下非法的指令、在相应SR位被禁止是执行的协处理器指令、整数溢出、地址对齐出错、用户态中访问kuseg以外的地址</li>
<li>系统调用和自陷</li>
</ul>
<h3><span id="精确异常">精确异常</span></h3>
<p>也就是我们的宏观pc的来由，如果某个pc是异常受害指令，那么我们希望在这个指令之前的指令已经全部处理完成，在这个指令之后的还没有开始处理。</p>
<p>全部内容如下：</p>
<ul>
<li>明确的罪证：在任何异常之后，CPU的控制寄存器EPC都指向一个正确的地方，异常处理之后从该处开始重新执行。在大多数情形中，EPC指向异常受害指令，但是如果异常受害指令处于分支延迟槽内，则EPC指向前面的分支指令：返回到分支指令去重新执行受害指令，但是返回到受害指令将导致分支被忽略。
<ul>
<li>当受害指令处于分支延迟槽内时，原因寄存器的Cause(BD)位置位</li>
</ul>
</li>
<li>异常出现在指令序列中：由于是流水线，而且在不同的流水级都有可能会出现问题，但是我们为了实现精确异常，不应该是出现异常就处理，也就是出现第二条指令的异常事件先发生时需要先处理第一条指令
<ul>
<li>为了避免这一个问题，早期发现的异常并不立即采取措施：该事件只是被记录并沿着流水线传递。在大多数CPU设计中，指定一个特定的流水线阶段作为检测异常的地方。如果当我们的异常记录正沿着流水线向下传递，更老的指令的后期检测到的事件到达了这个终点线，此时异常记录就直接丢弃。</li>
</ul>
</li>
<li>后续指令无效：因为流水线的原因，处于EPC中的受害指令之后的指令就已经开始了。</li>
</ul>
<h3><span id="非精确异常">非精确异常</span></h3>
<blockquote>
<p>这里实际上指的是历史上的MPIS CPU的乘法器，也就是我们P6的内容，采取直接发送一个busy信号的处理方法，这里我们不在进行讨论</p>
</blockquote>
<p><strong>异常发生的时机</strong></p>
<p>因为异常是精确的，那么异常发生的时间应当也是没有歧义的：</p>
<ul>
<li>异常之前执行的最后一条指令就是异常受害指令的前一条。</li>
<li>如果该异常不是中断：受害指令即是引发异常的指令</li>
</ul>
<blockquote>
<p>下面是MIPS CPU决定处理一个异常是所要做的</p>
</blockquote>
<ol>
<li>设置EPC指向重新开始的地址</li>
<li>设置SR(EXL)位，强制CPU进入内核态（高特权态）并且禁止中断</li>
<li>设置Cause寄存器这样软件可以看到发生异常的原因。在地址异常时，BadVAddr也要设置<strong>但是我们课程好像没有这个要求</strong></li>
<li>然后CPU开始从异常入口点取值，此后一切交给软件处理。<strong>其实也就是继续进行handler处理程序的执行部分</strong></li>
</ol>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p7</tag>
      </tags>
  </entry>
  <entry>
    <title>p7-流水线</title>
    <url>/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1>
<blockquote>
<p>这里是hugo的blog</p>
</blockquote>
<blockquote>
<p>P6-P7</p>
</blockquote>
<h2><span id="mips微系统">MIPS微系统</span></h2>
<p>有亿点点麻烦，首先阐释具体的概念，然后是工程化的应用。</p>
<ul>
<li>P7的任务是实现一个简单的计算机系统，即“mips微系统”</li>
<li>为了实现CPU的异常报告和与外设进行复杂的交互</li>
</ul>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/%E5%BE%AE%E7%B3%BB%E7%BB%9F.png" alt="img"></p>
<h3><span id="外设">外设</span></h3>
<p>暂时不重要</p>
<ul>
<li>Timer</li>
<li>Memory</li>
<li>InterruptGenerator</li>
</ul>
<p>Timer那里的是定时产生时钟中断。</p>
<p>InterruptGenerator是产生随机的外部中断信号，用来模拟外界情形</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/structure-1701416411059-3.svg" alt="structure"></p>
<blockquote>
<ul>
<li>
<p><strong>Q：我们计组课程一本参考书目标题中有 “硬件 / 软件接口” 接口字样，那么到底什么是 “硬件 / 软件接口”？(Tips：什么是接口？和我们到现在为止所学的有什么联系？)</strong></p>
<p><strong>A：</strong> 硬件 / 软件接口是指软件和硬件之间数据交互的接口。在我看来，这个应该指的是操作系统，操作系统将外部软件程序的机器码传入 core，由 core 执行；而 core 执行后产生的数据又通过操作系统传给软件。</p>
</li>
<li>
<p><strong>Q：BE 部件对所有的外设都是必要的吗？</strong></p>
<p><strong>A：</strong> 我认为没有必要，BE 部件是为了实现 DM 按字节访存设置的，而其他的部件例如 Timer 仅仅支持按字访存，因此不需要 BE 部件。</p>
</li>
<li>
<p><strong>Q：请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</strong></p>
<p><strong>A：</strong> 鼠标和键盘等外设并不是直接与 CPU 相连的，中间需要通过软件来连接，这个软件也就是我们熟知的驱动。驱动和硬件之间通过操作系统进行处理。</p>
</li>
<li>
<p><strong>Q:</strong> 请开发一个主程序以及定时器的 exception handler。整个系统完成如下功能：</p>
<p>（1）定时器在主程序中被初始化为模式 0；</p>
<p>（2）定时器倒计数至 0 产生中断；</p>
<p>（3）handler 设置使能 Enable 为 1 从而再次启动定时器的计数器。(2) 及 (3) 被无限重复。</p>
<p>（4）主程序在初始化时将定时器初始化为模式 0，设定初值寄存器的初值为某个值，如 100 或 1000。（注意，主程序可能需要涉及对 <a href="http://CP0.SR">CP0.SR</a> 的编程，推荐阅读过后文后再进行。）</p>
<p><strong>A:</strong></p>
<p>verilog</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">主程序<span class="token punctuation">:</span>
<span class="token punctuation">.</span>text
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>xfc01
mtc0 <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x0
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">288</span>
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f04
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
addi <span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">1</span>
loop<span class="token punctuation">:</span>
add <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
j loop
异常处理程序<span class="token punctuation">:</span>
<span class="token punctuation">.</span>ktext <span class="token number">0</span>x00004180
ori <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x1
ori <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9
sw <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
sw <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>P5-P6</p>
</blockquote>
<p>本次迭代新增了不少calc_r,calc_i型指令，这类指令基本上不敲错code基本上没啥问题，对于新增的md,mt,mf类型的指令，新增一个D_MDU进行处理。</p>
<p>关键这里将IM和DM进行了外置</p>
<blockquote></blockquote>
<p>实现五级流水线CPU</p>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<h3><span id="实现指令说明">实现指令说明</span></h3>
<p>将本CPU实现的指令分为以下几类：</p>
<table>
<thead>
<tr>
<th>classify</th>
<th>指令set</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>lw//lh,lhu,lb,lbu</td>
</tr>
<tr>
<td>store</td>
<td>sw//sh,sb</td>
</tr>
<tr>
<td>calc_r</td>
<td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td>
</tr>
<tr>
<td>calc_i</td>
<td>ori//addiu,addi,xori,slti,sltiu</td>
</tr>
<tr>
<td>shift_s</td>
<td>sll//sra,srl</td>
</tr>
<tr>
<td>shift_v</td>
<td>//sllv,srav,srlv</td>
</tr>
<tr>
<td>b_type</td>
<td>beq//bne</td>
</tr>
<tr>
<td>j</td>
<td>jal,j</td>
</tr>
<tr>
<td>特殊</td>
<td>jr,lui</td>
</tr>
</tbody>
</table>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
<h3><span id="命名规范">命名规范</span></h3>
<ul>
<li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li>
<li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li>
<li>寄存器文件采用两边的流水线层级加上_REG的方式。</li>
</ul>
<h2><span id="数据通路datapath">数据通路DataPath</span></h2>
<p>同P4，变量命名有稍微修改。</p>
<p>但没有单独使用一个DataPath的模块，显得比较多余。</p>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>i_en</td>
<td>I</td>
<td>1</td>
<td>使能信号</td>
</tr>
<tr>
<td>i_npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>or_pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>o_instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>i_npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>i_imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>i_jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>i_ra_of_jr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>o_npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC4</td>
<td>3</td>
<td>3‘b000</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>3</td>
<td>3’b001</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>3</td>
<td>3’b010</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>3</td>
<td>3’b011</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>i_writeEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>i_A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>i_A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>i_WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>o_RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>o_RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>用于$display</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>i_unsigned_ext_Sel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>o_imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMP_EQUAL</td>
<td>4</td>
<td>4‘b0000</td>
<td>判断是否相等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3>
<p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">信号名</th>
<th style="text-align:left">方向</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALUOp</td>
<td style="text-align:left">I</td>
<td style="text-align:left">4</td>
<td style="text-align:left">ALU 功能选择信号</td>
</tr>
<tr>
<td style="text-align:left">src_A</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第一个值</td>
</tr>
<tr>
<td style="text-align:left">src_B</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第二个值 S</td>
</tr>
<tr>
<td style="text-align:left">shamt</td>
<td style="text-align:left">I</td>
<td style="text-align:left">5</td>
<td style="text-align:left">移位数输入</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">O</td>
<td style="text-align:left">32</td>
<td style="text-align:left">输出 ALU 计算结果</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>00000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>00001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>00010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>00011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>00100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>00101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>00110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>00111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>01000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>01001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>01010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>i_Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>i_dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>i_WriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_writeData</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>o_RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>reset信号有效时，所有寄存器的中存储的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A地址对应的存储单元的数据，将其加载到RD</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td>
</tr>
</tbody>
</table>
<h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2>
<p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p>
<h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v 中的 clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v 中的 reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器使能信号</td>
<td style="text-align:left">HCU 中 stall 信号取反</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器清空信号</td>
<td style="text-align:left">默认为 1‘b0</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 instr 输入</td>
<td style="text-align:left">IFU_instr</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 pc 输入</td>
<td style="text-align:left">IFU_pc</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 instr 输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 pc 输出</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from EXT</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p>
</li>
</ul>
<h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3>
<ul>
<li>
<p>端口定义</p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left">关于sw的来自GRF_RD2的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<blockquote>
<p>我这里暂停部分在专门的一个模块HU中解决了</p>
</blockquote>
<p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p>
</li>
</ul>
<h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>接口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left">来自dm的数据读出信号</td>
<td style="text-align:left">from M_DM</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2><span id="控制单元_cu">控制单元_CU</span></h2>
<p>输入改为instr，之前为opcode和func</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0]</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="分支转移实现">分支转移实现</span></h3>
<h4><span id="b-类指令">B 类指令</span></h4>
<p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h4><span id="j-和-jal">j 和 jal</span></h4>
<p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p>
<h4><span id="jr">jr</span></h4>
<p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h2><span id="冒险处理">冒险处理</span></h2>
<p>冒险处理我们均通过 “A_T” 法实现 ——</p>
<h3><span id="转发forward">转发（forward）</span></h3>
<p><strong>无脑转发策略。</strong></p>
<p><strong>将所有在该层级后面的均进行转发。</strong></p>
<p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p>
<p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p>
<p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p>
<ul>
<li>
<p><strong>供应者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">流水级</th>
<th style="text-align:left">产生数据</th>
<th style="text-align:left">MUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">E_E32，E_pc8</td>
<td style="text-align:left">MUX_E_out &amp; SelEMOut</td>
<td style="text-align:left">E_out</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">M_AO，M_pc8</td>
<td style="text-align:left">MUX_M_out &amp; SelEMOut</td>
<td style="text-align:left">M_out</td>
</tr>
<tr>
<td style="text-align:left">W</td>
<td style="text-align:left">W_AO，W_RD，W_pc8</td>
<td style="text-align:left">MUX_W_out &amp; SelWOut</td>
<td style="text-align:left">W_out</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>需求者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">接收端口</th>
<th style="text-align:left">选择数据</th>
<th style="text-align:left">HMUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMP_D1/NPC_ra</td>
<td style="text-align:left">D_V1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td>
<td style="text-align:left">D_V1_f</td>
</tr>
<tr>
<td style="text-align:left">CMP_D2</td>
<td style="text-align:left">D_v1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td>
<td style="text-align:left">D_V2_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_A</td>
<td style="text-align:left">E_V1， W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_B</td>
<td style="text-align:left">E_V2，W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">DM_WD</td>
<td style="text-align:left">M_V2， W_out</td>
<td style="text-align:left">HMUX_DM &amp; FwdDM</td>
<td style="text-align:left">M_V2_f</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p>
<p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p>
<ul>
<li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li>
<li><strong>写使能信号有效</strong></li>
</ul>
<p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p>
<h3><span id="暂停stall">暂停（stall）</span></h3>
<p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p>
<p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p>
<ul>
<li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li>
<li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li>
</ul>
<p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p>
<ul>
<li>
<p><strong>Tuse 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tuse_rs</th>
<th style="text-align:left">Tuse_rt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">X</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jump</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">0</td>
<td style="text-align:left">X</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Tnew 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tnew_D</th>
<th style="text-align:left">Tnew_E</th>
<th style="text-align:left">Tnew_M</th>
<th style="text-align:left">Tnew_W</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jal</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">lui</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p>
<ul>
<li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li>
<li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li>
<li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li>
</ul>
<h1><span id="碎碎念">碎碎念</span></h1>
<ul>
<li>
<p>关于slt</p>
<blockquote>
<p>下面这种是错的</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> signed_srcA<span class="token punctuation">,</span> signed_srcB<span class="token punctuation">;</span>
 <span class="token keyword">assign</span> signed_srcB <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">assign</span> signed_srcA <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  signed_srcA <span class="token operator">&lt;</span> signed_srcB<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这种是对的</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</li>
<li>
<p>关于lb</p>
<blockquote>
<p>不知道这个为什么会有问题</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v<span class="token punctuation">:</span>
<span class="token constant">`define</span> GRF_WD_PC4          <span class="token number">3'b000</span>
<span class="token constant">`define</span> GRF_WD_PC8          <span class="token number">3'b001</span>
<span class="token constant">`define</span> GRF_WD_ALU_RESULT   <span class="token number">3'b010</span>
<span class="token constant">`define</span> GRF_WD_MEM_RD       <span class="token number">3'b011</span>
<span class="token constant">`define</span> GRF_WD_EXT          <span class="token number">3'b100</span>
<span class="token constant">`define</span> GRF_WD_MDU_RESULT   <span class="token number">3'b101</span>
# CU<span class="token punctuation">.</span>v<span class="token punctuation">:</span>
	<span class="token keyword">assign</span> o_grf_WD_Sel       <span class="token operator">=</span> <span class="token punctuation">(</span>o_load             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MEM_RD</span>     <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_calc_r <span class="token operator">|</span> o_calc_i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_mf               <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MDU_RESULT</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_link             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_PC8</span>        <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_lui              <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_EXT</span>        <span class="token punctuation">:</span> 
                                                     <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个W级CU的控制信号（我采用的是分布式译码），然后本来是o_calc_r和o_calc_i那个是第一行，为了测试调整了一下，按照仿真结果</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126002548684.png" alt="image-20231126002548684"></p>
<p>o_load确实是1,但是为什么这个Sel（grf的写入数据写入信号）为什么还是010（也就是ALU的那个呀）</p>
<p>测试代码如下：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003114530.png" alt="image-20231126003114530"></p>
<p>标准输出：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003204669.png" alt="image-20231126003204669"></p>
<p>我的输出：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003137500.png" alt="image-20231126003137500"></p>
<p>这个0x0000260f正好就是alu_result也就是计算得到的lb的地址</p>
</blockquote>
</li>
<li>
<p>bne</p>
<blockquote>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v
<span class="token constant">`define</span> NPC_PC4       <span class="token number">3'b000</span>
<span class="token constant">`define</span> NPC_BRANCH    <span class="token number">3'b001</span>
<span class="token constant">`define</span> NPC_J         <span class="token number">3'b010</span>
<span class="token constant">`define</span> NPC_JR        <span class="token number">3'b011</span>
# CU<span class="token punctuation">.</span>v
		<span class="token keyword">assign</span> o_npcOp        <span class="token operator">=</span> <span class="token punctuation">(</span>o_b_type <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_BRANCH</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_j_imm26<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span>  <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_j_r    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_JR</span> <span class="token punctuation">:</span>
                                           <span class="token constant">`NPC_PC4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也出现了类似上面的情况</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126010102868.png" alt="image-20231126010102868"></p>
<p>也就是o_b_type为1,但是npcOp仍然是PC4的000，而不是001</p>
</blockquote>
</li>
</ul>
<h1><span id="思考题">思考题</span></h1>
<blockquote>
<p>1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p>
</blockquote>
<ul>
<li>乘除法都有较高的延迟，若整合进 ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在 D 级，造成了极大的性能损失。单独设置 MDU 的话，无关的指令还能正常的在 ALU 运行，效率较高。</li>
<li>HI，LO 寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于 GRF 中，内置在 MDU 中即可。</li>
</ul>
<blockquote>
<p>2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p>
</blockquote>
<ul>
<li>
<p>真实的流水线 CPU 采用的乘法是有加法器和移位器循环，具体实现过程为：</p>
<blockquote>
<p>首先 CPU 会初始化三个通用寄存器用来存放被乘数，乘数，部分积。<br>
部分积寄存器初始化为 0。<br>
判断乘数寄存器的低位是 0|1，如果为 0 则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。<br>
在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。<br>
同时部分积寄存器高位补 0。如果为 1 则将部分积寄存器加上被乘数寄存器，再进行移位操作。<br>
当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。</p>
</blockquote>
</li>
<li>
<p>还有另一种乘法的方式：</p>
<blockquote>
<p>只需两个寄存器，A [31:0],B [63:0]，A 初始化为被乘数，B 初始化为乘数。<br>
每一次取 B 的最低位，为 1 则将 A [31:0]+B [63:32] -&gt; B [63:32]，为 0 则不操作。<br>
每次将 B &gt;&gt; 1，然后高位补 0。</p>
</blockquote>
</li>
<li>
<p>除法实现：</p>
<blockquote>
<p>与乘法的操作基本相反，首先 CPU 会初始化三个寄存器，用来存放被除数，除数，部分商。余数 (被除数与除数比较的结果) 放到被除数的有效高位上。CPU 做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先 CPU 会把被除数 bit 位与除数 bit 位对齐，然后再让对齐的被除数与除数比较 (双符号位判断)。比如 01-10=11 (前面的 1 是符号位) 1-2=-1 计算机通过符号位和后一位的 bit 位来判断大于和小于，那么 01-10=11 就说明 01 小于 10，如果得数为 01 就代表大于，如果得数为 00 代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位 (上商就是将商的最低位左移 1 位腾出商寄存器最低位上新的商) 如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p>
</blockquote>
<ul>
<li>除 cnt—，和 BusyReg 置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
<li>对于乘除指令：
<ul>
<li>将 Busy，start_E，MDUOp_D 传入 HCU</li>
<li>然后 md 暂停信号为 <code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p>
</blockquote>
<ul>
<li>对于需要写入的位置更加的直观，相当于将 DMWE、DMOP 写入的 A [1:0] 用四位字节使能信号表示，十分的统一。</li>
</ul>
<blockquote>
<p>5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p>
</blockquote>
<ul>
<li>按字节读写的时候，我们获得的是一字节，但是我们如果要 lw 或 lh 的话我们就需要拼接。如果是 sw 或 sh 的话我们需要多次存入。</li>
<li>若用 lb，sb，lh，sh 这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。</li>
</ul>
<blockquote>
<p>6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p>
</blockquote>
<ul>
<li>我们根据不同指令之间的相似性将指令分成了几类 ——calc_R、calc_I、shift、shiftv、load、store、B 类、J 类、md 类、mf 类、mt 类， 并设置对应信号帮助译码，防止计算表达式过长，而且在处理数据冲突时我们只需要将表示该类的信号写入表达式即可。此外，我们将相似功能的控制信号用一个多位宽信号来表示，如针对 DM 的访存功能，我们设置一个 3 位 LSOp 信号；针对乘除槽中的 md、mf、mt 功能，我们设置一个 MDUOp 信号来控制，从而减少了流水寄存器的接口数目，从而降低复杂度。</li>
</ul>
<blockquote>
<p>7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
</blockquote>
<p>tuse和tnew部分有</p>
<blockquote>
<p>8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p>
</blockquote>
<p>白嫖捏</p>
<h3><span id="参考">参考</span></h3>
<p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p7</tag>
      </tags>
  </entry>
  <entry>
    <title>p5-流水线</title>
    <url>/2024/02/21/p5-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$五级流水线$\mathscr{Design}$</span></h1>
<p>实现五级流水线CPU</p>
<span id="more"></span>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p5</tag>
      </tags>
  </entry>
  <entry>
    <title>p5p6-流水线</title>
    <url>/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1>
<p>实现五级流水线CPU</p>
<span id="more"></span>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<h3><span id="实现指令说明">实现指令说明</span></h3>
<p>将本CPU实现的指令分为以下几类：</p>
<table>
<thead>
<tr>
<th>classify</th>
<th>指令set</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>lw//lh,lhu,lb,lbu</td>
</tr>
<tr>
<td>store</td>
<td>sw//sh,sb</td>
</tr>
<tr>
<td>calc_r</td>
<td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td>
</tr>
<tr>
<td>calc_i</td>
<td>ori//addiu,addi,xori,slti,sltiu</td>
</tr>
<tr>
<td>shift_s</td>
<td>sll//sra,srl</td>
</tr>
<tr>
<td>shift_v</td>
<td>//sllv,srav,srlv</td>
</tr>
<tr>
<td>b_type</td>
<td>beq//bne</td>
</tr>
<tr>
<td>j</td>
<td>jal,j</td>
</tr>
<tr>
<td>特殊</td>
<td>jr,lui</td>
</tr>
</tbody>
</table>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
<h3><span id="命名规范">命名规范</span></h3>
<ul>
<li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li>
<li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li>
<li>寄存器文件采用两边的流水线层级加上_REG的方式。</li>
</ul>
<h2><span id="数据通路datapath">数据通路DataPath</span></h2>
<p>同P4，变量命名有稍微修改。</p>
<p>但没有单独使用一个DataPath的模块，显得比较多余。</p>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>i_en</td>
<td>I</td>
<td>1</td>
<td>使能信号</td>
</tr>
<tr>
<td>i_npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>or_pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>o_instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>i_npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>i_imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>i_jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>i_ra_of_jr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>o_npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC4</td>
<td>3</td>
<td>3‘b000</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>3</td>
<td>3’b001</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>3</td>
<td>3’b010</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>3</td>
<td>3’b011</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>i_writeEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>i_A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>i_A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>i_WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>o_RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>o_RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>用于$display</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>i_unsigned_ext_Sel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>o_imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMP_EQUAL</td>
<td>4</td>
<td>4‘b0000</td>
<td>判断是否相等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3>
<p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">信号名</th>
<th style="text-align:left">方向</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALUOp</td>
<td style="text-align:left">I</td>
<td style="text-align:left">4</td>
<td style="text-align:left">ALU 功能选择信号</td>
</tr>
<tr>
<td style="text-align:left">src_A</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第一个值</td>
</tr>
<tr>
<td style="text-align:left">src_B</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第二个值 S</td>
</tr>
<tr>
<td style="text-align:left">shamt</td>
<td style="text-align:left">I</td>
<td style="text-align:left">5</td>
<td style="text-align:left">移位数输入</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">O</td>
<td style="text-align:left">32</td>
<td style="text-align:left">输出 ALU 计算结果</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>00000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>00001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>00010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>00011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>00100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>00101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>00110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>00111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>01000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>01001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>01010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>i_Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>i_dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>i_WriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_writeData</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>o_RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>reset信号有效时，所有寄存器的中存储的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A地址对应的存储单元的数据，将其加载到RD</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td>
</tr>
</tbody>
</table>
<h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2>
<p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p>
<h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v 中的 clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v 中的 reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器使能信号</td>
<td style="text-align:left">HCU 中 stall 信号取反</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器清空信号</td>
<td style="text-align:left">默认为 1‘b0</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 instr 输入</td>
<td style="text-align:left">IFU_instr</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 pc 输入</td>
<td style="text-align:left">IFU_pc</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 instr 输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 pc 输出</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from EXT</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p>
</li>
</ul>
<h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3>
<ul>
<li>
<p>端口定义</p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left">关于sw的来自GRF_RD2的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<blockquote>
<p>我这里暂停部分在专门的一个模块HU中解决了</p>
</blockquote>
<p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p>
</li>
</ul>
<h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>接口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left">来自dm的数据读出信号</td>
<td style="text-align:left">from M_DM</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2><span id="控制单元_cu">控制单元_CU</span></h2>
<p>输入改为instr，之前为opcode和func</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0]</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="分支转移实现">分支转移实现</span></h3>
<h4><span id="b-类指令">B 类指令</span></h4>
<p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h4><span id="j-和-jal">j 和 jal</span></h4>
<p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p>
<h4><span id="jr">jr</span></h4>
<p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h2><span id="冒险处理">冒险处理</span></h2>
<p>冒险处理我们均通过 “A_T” 法实现 ——</p>
<h3><span id="转发forward">转发（forward）</span></h3>
<p><strong>无脑转发策略。</strong></p>
<p><strong>将所有在该层级后面的均进行转发。</strong></p>
<p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p>
<p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p>
<p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p>
<ul>
<li>
<p><strong>供应者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">流水级</th>
<th style="text-align:left">产生数据</th>
<th style="text-align:left">MUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">E_E32，E_pc8</td>
<td style="text-align:left">MUX_E_out &amp; SelEMOut</td>
<td style="text-align:left">E_out</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">M_AO，M_pc8</td>
<td style="text-align:left">MUX_M_out &amp; SelEMOut</td>
<td style="text-align:left">M_out</td>
</tr>
<tr>
<td style="text-align:left">W</td>
<td style="text-align:left">W_AO，W_RD，W_pc8</td>
<td style="text-align:left">MUX_W_out &amp; SelWOut</td>
<td style="text-align:left">W_out</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>需求者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">接收端口</th>
<th style="text-align:left">选择数据</th>
<th style="text-align:left">HMUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMP_D1/NPC_ra</td>
<td style="text-align:left">D_V1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td>
<td style="text-align:left">D_V1_f</td>
</tr>
<tr>
<td style="text-align:left">CMP_D2</td>
<td style="text-align:left">D_v1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td>
<td style="text-align:left">D_V2_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_A</td>
<td style="text-align:left">E_V1， W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_B</td>
<td style="text-align:left">E_V2，W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">DM_WD</td>
<td style="text-align:left">M_V2， W_out</td>
<td style="text-align:left">HMUX_DM &amp; FwdDM</td>
<td style="text-align:left">M_V2_f</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p>
<p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p>
<ul>
<li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li>
<li><strong>写使能信号有效</strong></li>
</ul>
<p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p>
<h3><span id="暂停stall">暂停（stall）</span></h3>
<p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p>
<p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p>
<ul>
<li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li>
<li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li>
</ul>
<p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p>
<ul>
<li>
<p><strong>Tuse 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tuse_rs</th>
<th style="text-align:left">Tuse_rt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">X</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jump</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">0</td>
<td style="text-align:left">X</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Tnew 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tnew_D</th>
<th style="text-align:left">Tnew_E</th>
<th style="text-align:left">Tnew_M</th>
<th style="text-align:left">Tnew_W</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jal</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">lui</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p>
<ul>
<li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li>
<li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li>
<li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li>
</ul>
<h1><span id="思考题">思考题</span></h1>
<blockquote>
<p>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p>
</blockquote>
<ul>
<li>我们使用两个寄存器值的时间最早来到了 D 级，所以很可能会引发暂停.</li>
<li>如下面这种情况，若 beq 的结果在 E 级产生，则不需要暂停，可以转发，但是现在 beq 在 D 级的时候 lw 还在 M 级，没有产生结果，需要暂停。</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw    $t0, 0($0)
nop
beq   $t0, $t0, label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</p>
</blockquote>
<ul>
<li>因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把 PC+8 写入寄存器，不然 jr 时延迟槽内的指令会再执行一次</li>
</ul>
<blockquote>
<p>3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？</p>
</blockquote>
<ul>
<li>因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</li>
</ul>
<blockquote>
<p>4、我们为什么要使用 GPR 内部转发？该如何实现？</p>
</blockquote>
<p>如果你W级写入数据的寄存器与D级读寄存器的地址相同时，将会你导致出现错误的数值，因此需要通过内部转发来规避数据冒险。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 内部转发</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_RD1_D<span class="token punctuation">,</span> D_FWD_RD2_D<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> D_FWD_RD1_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A1 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>
                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A1 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>
                                            r_rf<span class="token punctuation">[</span>i_A1<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token keyword">assign</span> D_FWD_RD2_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A2 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>
                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A2 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>
                                            r_rf<span class="token punctuation">[</span>i_A2<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p>
</blockquote>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                                                D_grf_RD1<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                                                D_grf_RD2<span class="token punctuation">;</span>

<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                E_grf_RD1<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                E_grf_RD2<span class="token punctuation">;</span>

<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> M_FWD_writeData <span class="token operator">=</span> <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                              <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                   M_dm_writeData  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p>
</blockquote>
<ul>
<li>高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改数据通路</li>
<li>对于计算类：首先改变 MCU，注意每个指令的控制信号的对应，再改 ALU 的结构，增加输出选择</li>
<li>对于访存类：改变 MCU + 修改 DM 增加相应的功能</li>
<li>对于跳转类：修改 MCU+NPC 相应功能修改</li>
<li>小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。</li>
</ul>
<blockquote>
<p>7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p>
</blockquote>
<p>我采用的是分布式译码。我感觉分布式译码器确实从实际运用上讲会造成器件的浪费，但是单从code上来讲，确实会方便很多，其中把每个instr传进去也感觉十分方便。</p>
<p>但是可能不足在于修改了CU相应的部分，mips.v和HU.v都需要进行比较大的改动。</p>
<h3><span id="流水线冒险">流水线冒险</span></h3>
<ol>
<li>
<p><strong>在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</strong></p>
<p><strong>A</strong>：当需要进行暂停时，IFU 的使能信号失效，PC 值不变。当不需要进行分支转移和跳转时，NPC 中将 F_pc 信号加 4 处理返回 IFU，下一时钟沿来临时更新为 F_pc+4。当执行分支指令时，NPC 将 D_pc +4 和符号扩展后的 imm16 相加，返回 IFU，下一时钟沿上升时更新。当执行 j/jal 指令时，NPC 将 imm26 进行扩展（前四位补 D_pc 的前四位，后两位补 0），返回 IFU，下一时钟沿上升时更新。当执行 jr 指令时，NPC 将从 GRF 的 RD1 端口（考虑转发）输出的值输出，返回 IFU 下一时钟沿上升时更新。</p>
</li>
<li>
<p><strong>对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8 ？</strong></p>
<p><strong>A</strong>：因为需要考虑编译优化，jal 的下一条指令是延迟槽中的指令，在 jal 执行前会被执行。如果回写 PC+4 的话，当出现 “jr $ra” 时，将会回到延迟槽，重复执行延迟槽中的指令。因此需要回写 PC+8。</p>
</li>
</ol>
<h3><span id="数据冒险的分析">数据冒险的分析</span></h3>
<ol>
<li>
<p><strong>为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由 ALU 或者 DM 等部件来提供数据？</strong></p>
<p><strong>A</strong>：因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</p>
</li>
</ol>
<h3><span id="at-法处理流水线数据冒险">AT 法处理流水线数据冒险</span></h3>
<ol>
<li>
<p><strong>“转发（旁路）机制的构造” 中的 Thinking 1-4；</strong></p>
<p><strong>Thinking 1</strong>：如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</p>
<p><strong>A</strong>：例如：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addi    $s0, $0, 4
andi	$s1, $s0, 5
sw      $s1, 4($s0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>Thinking 2</strong>：我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</p>
<p><strong>A</strong>：因为需要使得 W 级保存的将要写入得数据及时反馈到 GRF 的输出端口，从而规避数据冒险。如果不采用内部转发，我们可以在 GRF 的输出端口加入多路选择器，将 W 级的数据进行转发。</p>
<p><strong>Thinking 3</strong>：为什么 0 号寄存器需要特殊处理？</p>
<p><strong>A</strong>：因为对 0 号寄存器的写入是无效的，如果不特殊处理，则会使得向 0 号寄存器写入的数据（无效输入）被错误转发，从而造成 BUG。</p>
<p><strong>Thinking 4</strong>：什么是 “最新产生的数据”？</p>
<p><strong>A</strong>: 距离当前需求者最近的流水寄存器中储存的数据。</p>
</li>
<li>
<p><strong>在 AT 方法讨论转发条件的时候，只提到了 “供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？</strong></p>
<p><strong>A</strong>： 因为当 we 信号为 0 时我们就把 RF 写入地址置为 0，因此如果 “供给者的 A 不为 0”，就已经排除了 “写入信号为 0” 的情况。</p>
</li>
</ol>
<h3><span id="在线测试相关说明">在线测试相关说明</span></h3>
<p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
<p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略，<strong>比如构造连续数据冒险序列，请你描述一下你使用的策略如何</strong>结合了随机性</strong>达到强测的效果。</p>
<p>此思考题请同学们结合自己测试 CPU 使用的具体手段，按照自己的实际情况进行回答。</p>
<p><strong>A</strong>：我是采用半随机生成半手动构造的方法。对于功能型指令，完全通过 python 脚本自动生成。并且为了提高数据冲突的概率，我们仅仅使用 0~7 号寄存器进行测试。对于跳转指令，我们先使用一定模板进行构建，然后为了增加数据冒险和控制冒险，我们又手动进行一定修改，使得测试样例尽可能更多的覆盖所有可能的情况</p>
<h3><span id="参考">参考</span></h3>
<p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p6</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl</title>
    <url>/2024/04/24/wsl/</url>
    <content><![CDATA[<h1><span id="wsl">wsl</span></h1>
<h2><span id="安装">安装</span></h2>
<p>安装wsl</p>
<p>在管理员模式下打开 PowerShell 或 Windows 命令提示符，方法是右键单击并选择“以管理员身份运行”，输入 wsl --install 命令，然后重启计算机。</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以通过查看</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl<span class="token punctuation">.</span>exe <span class="token operator">--</span>list <span class="token operator">--</span>online<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>来获取有哪些可行的发行版</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">以下是可安装的有效分发的列表。
使用 <span class="token string">'wsl.exe --install &lt;Distro&gt;'</span> 安装。

NAME                                   FRIENDLY NAME
Ubuntu                                 Ubuntu
Debian                                 Debian GNU/Linux
kali-linux                             Kali Linux Rolling
Ubuntu-18.04                           Ubuntu <span class="token number">18.04</span> LTS
Ubuntu-20.04                           Ubuntu <span class="token number">20.04</span> LTS
Ubuntu-22.04                           Ubuntu <span class="token number">22.04</span> LTS
OracleLinux_7_9                        Oracle Linux <span class="token number">7.9</span>
OracleLinux_8_7                        Oracle Linux <span class="token number">8.7</span>
OracleLinux_9_1                        Oracle Linux <span class="token number">9.1</span>
openSUSE-Leap-15.5                     openSUSE Leap <span class="token number">15.5</span>
SUSE-Linux-Enterprise-Server-15-SP4    SUSE Linux Enterprise Server <span class="token number">15</span> SP4
SUSE-Linux-Enterprise-15-SP5           SUSE Linux Enterprise <span class="token number">15</span> SP5
openSUSE-Tumbleweed                    openSUSE Tumbleweed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装想要的发行版</p>
<blockquote>
<p>这里我是安装一个新的发行版作为演示，一般建议安装ubuntu或者debian</p>
</blockquote>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl<span class="token punctuation">.</span>ext <span class="token operator">--</span>install <span class="token operator">-</span>d Ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl<span class="token punctuation">.</span>exe <span class="token operator">--</span>install <span class="token operator">-</span>d kali-linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2><span id="配置超算相关环境">配置超算相关环境</span></h2>
<blockquote>
<p>这里我是安装了一个新的发行版，也就是kali-linux，来得到一个空白的环境作为演示，一般建议安装ubuntu</p>
</blockquote>
<ol>
<li>
<p>安装gcc和g++</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> g++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h2><span id="遇到的问题">遇到的问题</span></h2>
<h3><span id="系统找不到指定的文件">系统找不到指定的文件</span></h3>
<p><img src="/2024/04/24/wsl/D:%5Cblog%5Chexo%5Csource_posts%5Cwsl%5Cimage-20231208144337351.png" alt="image-20231208144337351"></p>
<p>wsl莫名又找不到了</p>
<p><img src="/2024/04/24/wsl/D:%5Cblog%5Chexo%5Csource_posts%5Cwsl%5Cimage-20231208144522903.png" alt="image-20231208144522903"></p>
<p>但是在应用里面还有</p>
<p>直接加环境变量就是了（虽然不知道正解应该是什么但是我也不知道问题是什么啊）</p>
<p>重启后还是没有，樂</p>
<p><img src="/2024/04/24/wsl/D:%5Cblog%5Chexo%5Csource_posts%5Cwsl%5Cimage-20231208145449773.png" alt="image-20231208145449773"></p>
<p>接着出问题</p>
<p><img src="/2024/04/24/wsl/D:%5Cblog%5Chexo%5Csource_posts%5Cwsl%5Cimage-20231208160738248.png" alt="image-20231208160738248"></p>
<p>6</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">86152  C:<span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span>system32  <span class="token number">16</span>:30:24  <span class="token comment"># 卸载所有Linux发行版                                                         86152  C:\WINDOWS\system32  16:30:28  Get-AppxPackage -allusers -name *linux* | Remove-AppxPackage                  86152  C:\WINDOWS\system32  16:30:32 </span>
86152  C:<span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span>system32  <span class="token number">16</span>:30:43  <span class="token comment"># 卸载具体的Linux发行版</span>
86152  C:<span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span>system32  <span class="token number">16</span>:30:44  Get-AppxPackage <span class="token parameter variable">-allusers</span> <span class="token operator">|</span> where-object <span class="token punctuation">{</span><span class="token variable">$_</span>.name <span class="token parameter variable">-like</span> <span class="token string">"*&lt;发行版名称&gt;*"</span><span class="token punctuation">}</span> <span class="token operator">|</span> Remove-AppxPackage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后就解决问题了</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>spack</title>
    <url>/2024/04/24/spack/</url>
    <content><![CDATA[<h1><span id="spack超算最好用的包管理器">spack：超算最好用的包管理器</span></h1>
<h2><span id="安装">安装</span></h2>
<blockquote>
<p>这里建议装到/opt文件夹下</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">-c</span> <span class="token assign-left variable">feature.manyFiles</span><span class="token operator">=</span>true https://github.com/spack/spack.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>初始化Spack</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> spack
./bin/spack bootstrap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>设置环境变量</p>
<p>在主目录下的<code>.bashrc</code>中添加</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">SPACK_ROOT</span><span class="token operator">=</span>/opt
<span class="token builtin class-name">.</span> <span class="token variable">$SPACK_ROOT</span>/share/spack/setup-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>source ~/.bashrc</code>加载环境变量</p>
<p>验证安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spack <span class="token parameter variable">--version</span>
spack info gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2><span id="使用">使用</span></h2>
<p>使用Spack安装软件包</p>
<ol>
<li>
<p>在终端使用如下命令搜索可用的软件包</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spack <span class="token function">find</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>选择想要安装的软件包，并使用如下命令进行安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spack <span class="token function">install</span> <span class="token operator">&lt;</span>package_name<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>spack 将自动下载、构建和安装软件包及其依赖项</p>
</li>
<li>
<p>查看已安装的软件包的列表</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spack <span class="token function">find</span> <span class="token parameter variable">--installed</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>遇事不决</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spack <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者<a href="https://spack.readthedocs.io/en/latest/">https://spack.readthedocs.io/en/latest/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>包管理器</category>
      </categories>
      <tags>
        <tag>spack</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh</title>
    <url>/2024/04/24/zsh/</url>
    <content><![CDATA[<h1><span id="zsh">zsh</span></h1>
<blockquote>
<p>linux安装配置zsh</p>
</blockquote>
<p>安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">zsh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置为默认shell</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chsh <span class="token parameter variable">-s</span> /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者直接编辑<code>/etc/passwd</code></p>
<p>安装<code>oh-my-zsh</code>进行配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>除了内置主题外，还可以选择其他开源的主题，强烈推荐尝试一下 <code>powerlevel10k</code> 主题，一个顶十个，项目地址为：<a href="https://link.zhihu.com/?target=https%3A//github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p>
<p>oh-my-zsh 安装这个款主题的方法：使用 git 将文件 clone 只指定文件夹 <code>～/.oh-my-zsh/custom/themes/powerlevel10k</code> ，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span> https://github.com/romkatv/powerlevel10k.git <span class="token variable">${ZSH_CUSTOM<span class="token operator">:-</span>$HOME<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom}</span>/themes/powerlevel10k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 vim 编辑 <code>.zshrc</code>，键入以下内容并保存：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">ZSH_THEME</span><span class="token operator">=</span><span class="token string">"powerlevel10k/powerlevel10k"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，执行 <code>source ~/.zshrc</code> 配置生效，这时会提示对主题进行配置，按照提示进行即可。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>字典序</title>
    <url>/2023/05/25/%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
    <content><![CDATA[<h1><span id="字典序">字典序</span></h1>
<h2><span id="说在前面">说在前面</span></h2>
<blockquote>
<p>字典序(dictionary order)，又称字母序(alphabetical order)，原意是表示英文单词在字典中的先后顺序，后引申为任意两个字符串的大小关系</p>
</blockquote>
<p>那么大家就清楚了这指的是一种大小关系，一种序，正如我们数学分析中的有序集的序有类似的概念，这里大家需要与字典树(Tire)区分开来，字典树实质上是一种数据结构中的用于存储和查找单词的一种树状结构，详情可以看这个<a href="https://www.hugohealthy.top/2023/05/25/Trie/">tire</a>。(在我的另一篇blog可以看到哦)</p>
<h2><span id="字典序算法相关">字典序算法相关</span></h2>
<h3><span id="字典序全排列问题">字典序全排列问题</span></h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token comment">//交换两个字符，注意这里传过去的是地址，改变的是地址对应的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//将一个字符串begin到end的部分逆序</span>
<span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        begin<span class="token operator">++</span><span class="token punctuation">;</span>
        end<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">next_permutation</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> str<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token comment">//从后往前找到第一个正序的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">//表示找完了，已经全部是逆序了</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//从i开始找到前面的第一个比str[i]大的，那么就进行交换</span>
<span class="token comment">//再把i+1以后的逆序一遍</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abd"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该代码可以实现一个<strong>顺序的字符串</strong>的所有字母的按字典序输出的全排列。</p>
<p>否则的话就是输出比改字符串的字典序大于等于的字符串。</p>
<p>当然简单调整当然可以是任意顺序的一个字符串的操作。</p>
<h3><span id="字典序排序">字典序排序</span></h3>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_37050329/article/details/86637183">https://blog.csdn.net/qq_37050329/article/details/86637183</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典序</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2023/05/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1><span id="使用两个栈实现一个队列两个队列实现一个栈">使用两个栈实现一个队列，两个队列实现一个栈</span></h1>
<blockquote>
<p>总感觉这像是一个面试题		——hugo</p>
</blockquote>
<span id="more"></span>
<p>栈是一种后入先出(Last In First Out, LIFO)的数据结构，队列是一种先进先出(First In First Out, FIFO)的数据结构。</p>
<h2><span id="两个栈实现一个队列">两个栈实现一个队列</span></h2>
<p>思路一：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p>
<p>入队：</p>
<p><code>push_s1(item)</code></p>
<p>出队：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>top_s2 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push_s1</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即<code>s1</code>式负责元素的存储，<code>s2</code>作为过渡栈，每次元素出队矩利用到<code>s2</code>;</p>
<p>但是整个过程中出队入队显然太麻烦了，那么对此进行优化有：</p>
<p>我们其实可以发现对<code>s2</code>中的<code>top</code>元素<code>pop</code>后其实不一定需要再全部倒回<code>s1</code>，</p>
<p>那么就有：</p>
<p>思路二：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p>
<p>入队：</p>
<p><code>push_s1(item)</code></p>
<p>出队：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top_s2 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>思路二主要就是减少了两个栈之间元素的转移。</p>
<h2><span id="两个队列实现一个栈">两个队列实现一个栈</span></h2>
<p>思路一：<code>q1</code>负责出栈，<code>q2</code>只是一个中转</p>
<p>入栈：</p>
<p><code>q1[rear1++]=item</code></p>
<p>出栈：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>front1 <span class="token operator">&lt;</span> rear1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    q2<span class="token punctuation">[</span>rear2<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
item <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>front2 <span class="token operator">&lt;</span> rear2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> q2<span class="token punctuation">[</span><span class="token operator">++</span>front2<span class="token punctuation">]</span><span class="token punctuation">;</span>
    q1<span class="token punctuation">[</span>rear1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>思路二：<code>q1</code>和<code>q2</code>都负责进出栈</p>
<p>入栈：</p>
<p>如果<code>q1</code>和<code>q2</code>都为空，随便入一个队即可，这里选择入<code>q1</code>；</p>
<p>如果一个队列为空，另一个队列非空，则入非空队；</p>
<p>如果都非空，则入<code>q1</code>即可。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>rear1 <span class="token operator">==</span> front <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    q2<span class="token punctuation">[</span><span class="token operator">++</span>rear2<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>出栈：</p>
<p>如果一个队列为空，另一个队列非空，则仿造思路1将非空队列的队尾元素出队；</p>
<p>如果两个队列都非空，则将<code>q1</code>的队尾元素出队，其他元素入队<code>q2</code>。即把不为空的队列中除最后一个元素外的所有元素移动到另一个队列中，然后出队最后一个元素。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大一下数据结构大作业</title>
    <url>/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>暂时嘛，啥也没有</p>
<p>蒟蒻博主啥也不会捏</p>
<p>会了也不告诉你</p>
</blockquote>
<span id="more"></span>
<h2><span id="bug">bug</span></h2>
<blockquote>
<p>这里是大家可能会遇到的一些问题，我分享一些我的想法</p>
</blockquote>
<h2><span id="读题">读题</span></h2>
<p>要注意理解题目意思。大致就是首先统计article的词频。接着得到单词中非停用词的词频最多的前N个。（要注意不是每个网页的前N个，而是将所有article的网页的词频统计好之后的前N个（这个也就是特征向量）。然后通过<strong>题目描述的计算方式</strong>得到指纹。然后对每个sample的网页，同样统计特征向量中每个单词（注意这里变成了特征向量中的单词，而不需要所有的）的词频，通过<strong>题目描述的计算方式</strong>再次得到指纹。最后将每一个sample网页的指纹与所有article的指纹进行汉明距离的计算，然后统计输出。</p>
<h3><span id="第一种本地不对">第一种，本地不对</span></h3>
<p>本地不管是输出错误还是运行时错误，都可以采取打印调试法和逐步调试法。(debug是必修课喔~~)</p>
<h3><span id="第二种本地对小数据不对">第二种，本地对小数据不对</span></h3>
<p>嗯，这种情况其实到后面可以向助教祈求小数据的内容。</p>
<p>首先可能是windows与linux的差异。</p>
<p>也就是linux中每一行结束时\r\n，而windows是\n。</p>
<p>可以将文件打开Mode改为rb，看本地输出是否正确。</p>
<h3><span id="第三种小数据对大数据不对">第三种，小数据对大数据不对</span></h3>
<blockquote>
<p>这一种是最恼火的</p>
</blockquote>
<p>如果是输出错误，</p>
<ul>
<li>千万要注意article和sample的网页名。如果是直接以为就是样例中的1-%d这种的，那么就会出问题。建议改为从数组中解析或者fscanf。</li>
</ul>
<p>如果是运行时错误，</p>
<p>多半是数组开小了，或者malloc多了。</p>
<ul>
<li>这种情况下关键是找到哪里运行时错误了。可以在代码的不同位置return 0强制结束然。后看在哪个之前显示的是输出错误，过了那个就变成了运行时错误，那么就仔细看看应该如何解决。</li>
</ul>
<h2><span id="题目">题目</span></h2>
<p><img src="/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E4%BD%9C%E4%B8%9A.png" alt></p>
<h2><span id="code">code</span></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// N 5000</span>
<span class="token comment">// M 64</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span></span><span class="token string">"Ofast"</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">low</span><span class="token expression"><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">&gt;=</span><span class="token number">65</span><span class="token operator">&amp;&amp;</span>c<span class="token operator">&lt;=</span><span class="token number">90</span> <span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">32</span><span class="token operator">+</span>c<span class="token operator">:</span>c<span class="token punctuation">)</span></span></span>
<span class="token comment">//#define low(c) (c|0x20)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NMAX</span> <span class="token expression"><span class="token number">10005</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MMAX</span> <span class="token expression"><span class="token number">130</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXHASH</span> <span class="token expression"><span class="token number">1280010</span></span></span>
<span class="token keyword">char</span> bufferHash<span class="token punctuation">[</span>MAXHASH<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSTOPCHARS</span> <span class="token expression"><span class="token number">10000</span></span></span>
<span class="token keyword">char</span> bufferStopChars<span class="token punctuation">[</span>MAXSTOPCHARS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXARTICLECHARS</span> <span class="token expression"><span class="token number">350000000</span></span></span>
<span class="token keyword">char</span> bufferArticleChars<span class="token punctuation">[</span>MAXARTICLECHARS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGENUMMAX</span> <span class="token expression"><span class="token number">16000</span></span></span>
<span class="token keyword">int</span> hash_better<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span><span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">myatoi</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tmp <span class="token operator">=</span> tmp <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">!=</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">-</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
        p2<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mystrcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mymemset_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mystrcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
        p2<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">++</span><span class="token punctuation">;</span>
        len<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">readHash</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferHash<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXHASH<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferHash<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            hash_better<span class="token punctuation">[</span>hash_i_line<span class="token punctuation">]</span><span class="token punctuation">[</span>hash_i<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">==</span> <span class="token number">48</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
            hash_i_line<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                hash_i<span class="token operator">++</span><span class="token punctuation">;</span>
                hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_stopWords <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">search_stopwords</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//就是1</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferStopChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSTOPCHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferStopChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_stopWords<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aword</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span> word<span class="token punctuation">;</span>
word word_num_article<span class="token punctuation">[</span><span class="token number">106010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_word <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> name_page<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_page <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    len_article <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_article<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search_stopwords</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">mystrcpy</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> p<span class="token punctuation">;</span>
                pos_word<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                num_page<span class="token operator">++</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    pos<span class="token operator">++</span><span class="token punctuation">;</span>
                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                    pos<span class="token operator">++</span><span class="token punctuation">;</span>
                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>
    word <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">-</span> num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>str<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">^</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            n <span class="token operator">=</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> weightArticle<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sumSignedWeightArticle<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
__uint128_t fingerprintArticle<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> isNWords <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isNWords <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                weightArticle<span class="token punctuation">[</span>isNWords <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//0.96429S</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span> weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span> __uint128_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> weightSample<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sumSignWeightSample<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
__uint128_t fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> name_sample<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_sample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> flag_ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>space <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">readSample</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">,</span> FILE <span class="token operator">*</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> flag_f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">!=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pos<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> ppage <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ppage <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            weightSample<span class="token punctuation">[</span>ppage <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            flag_f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> N<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token punctuation">(</span>num_page <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                distance <span class="token operator">=</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>fingerprintSample<span class="token punctuation">,</span> fingerprintArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> name_page<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> name_sample<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n%d:"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">fwrite</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            num_sample<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    N <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    M <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>pp_result <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"result.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_stop <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"stopwords.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_article <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"article.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_sample <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"sample.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_hashvalue <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"hashvalue.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">readHash</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.01427S</span>
    <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.39820S</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">,</span> pos_word <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.49212S</span>
    <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.50967</span>
    <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//3.53592S</span>
    <span class="token function">readSample</span><span class="token punctuation">(</span>fp_sample<span class="token punctuation">,</span> pp_result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//    fclose(fp_sample);</span>
<span class="token comment">//    fclose(pp_result);</span>
    <span class="token comment">//3.63961S</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="version5说明">version5说明</span></h2>
<p>这里我优化了计算指纹的部分。我将计算的循环次序进行了交换，同时我判断weight是否为0，如果是就不需要进行循环了。</p>
<p>这个版本在优化后最终也是跑到了<code>1.15s</code></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大作业优化</tag>
      </tags>
  </entry>
  <entry>
    <title>离散2</title>
    <url>/2023/11/24/%E7%A6%BB%E6%95%A32/</url>
    <content><![CDATA[<h1><span id="离散2">离散2</span></h1>
<p>这里会放上我的一些作业</p>
<span id="more"></span>
<h2><span id="作业5">作业5</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)不是\<br>
&amp;A = {1, 2, 3}\<br>
&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;1,2&gt;,&lt;2,1&gt;, &lt;1,3&gt;,&lt;3,1&gt;,&lt;2,3&gt;,&lt;3,2&gt;}\<br>
&amp;R_2 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;1,2&gt;,&lt;2,1&gt;}\<br>
&amp;则r(R_1 - R_2) = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;2,3&gt;,&lt;3,2&gt;,&lt;1,3&gt;,&lt;3,1&gt;}\<br>
&amp;而有&lt;1,3&gt;,&lt;3,2&gt;\in r(R_1 - R_2) 但是&lt;1,2&gt; \notin r(R_1 - R_2),故r(R_1-R_2)不是传递的，因而不是等价关系\<br>
&amp;(2)不是\<br>
&amp; 上课已经讲过，R_1 , R_2是对称时，R_1 \circ R_2 不一定对称\<br>
&amp; 比如取A = {1, 2, 3}\<br>
&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;,&lt;1,2&gt;,&lt;2,1&gt;,}\<br>
&amp;R_2 = {&lt;2,2&gt;, &lt;3,3&gt;, &lt;2,3&gt;,&lt;3,2&gt;}\<br>
&amp;则R_1\circ R_2 = {&lt;2,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;,&lt;1,2&gt;}显然不是等价关系\<br>
&amp;(3)是\<br>
&amp;R_1,R_2都是等价关系，那么都是自反，对称，传递的\<br>
&amp;就有R_1\cup R_2是自反的，对称的\<br>
&amp;同时如果R_1 \cup R_2 是自反的，对称的，那么t(R_1,R_2)仍然是自反、对称的，同时还是传递的\<br>
&amp;由等价关系的定义可知t(R_1, R_2)是等价关系<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(a)\<br>
&amp;左到右:\<br>
&amp;S_1 \in A/R1,则\forall s_1 \in S_1\<br>
&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>
&amp;又R_1\subseteq R_2,及&lt;x,y&gt; \in R_1 有&lt;x,y&gt; \in R_2，即xR_2y\<br>
&amp;故s_1 \in S_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y}\<br>
&amp;即S_1 \subseteq S_2,由加细的定义有A/R_1 \le A/R_2\<br>
&amp;右到左:\<br>
&amp;A/R_1 \le A/R_2\<br>
&amp;有\forall S_1 \in A/R_1 , \exist S_2 \in A/R_2 , s.t. S_1 \subseteq S_2\<br>
&amp;\forall s_1 \in S_1\<br>
&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>
&amp;故\exist s_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y},s_1 \subseteq s_2 \<br>
&amp;即\forall xR_1y,有xR_2y,即R_1 \subseteq R_2\<br>
&amp;综上即可得证\<br>
&amp;(b)\<br>
&amp;左到右:\<br>
&amp;R_1 \subset R_2 必然有R_1 \subseteq R_2，则A/R_1 \le A/R_2\<br>
&amp;又R_1\ne R_2,即\exist &lt;x_0,y&gt; \in R_2,&lt;x_0,y&gt;\notin R_1\<br>
&amp;取s_2 = [x_0]<em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2 \in S_2，其中S_2 \in A/R_2\<br>
&amp;且由于&lt;x_0,y&gt;\notin R_1 ,s_2 \notin S_1,故S_1 \ne S_2,其中S_1 \in A/R_1\<br>
&amp;即A/R_1 \ne A/R_2\<br>
&amp;右到左:\<br>
&amp;A/R_1 \subset A/R_2,则同样易有R_1\subseteq R_2\<br>
&amp;A/R_1 \ne A/R_2\<br>
&amp;则存在S_2 \in A/R_2,找不到S_1 \in A/R_1,s.t. S_2 \subseteq S_1,\<br>
&amp;同样取s_2 = [x_0]</em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2\in S_2，且s_2 \notin S_1\<br>
&amp;即\exist &lt;x_0,y_0&gt;,s.t. x_0R_2y_0,x_0\overline{R_1}y_0\<br>
&amp;即R_1 \ne R_2\<br>
&amp;故R_1 \subset R_2\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;看法不对,证明就不可能对了嘛。\<br>
&amp;若R是非空集合A的空关系，由于前件为0，R是对称和传递的，但是\forall x \in A, &lt;x,x&gt;\notin R\<br>
&amp;R不是自反的\<br>
&amp;故即可完成论证\<br>
\end{align}<br>
$$</p>
<ol start="4">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;必要性:\<br>
&amp;(显然bushi)R是等价关系，且&lt;a,b&gt;\in R,&lt;a,c&gt; \in R\<br>
&amp;由于R是对称的，有&lt;b,a&gt;\in R\<br>
&amp;由于R是传递的，有&lt;b,c&gt;\in R\<br>
&amp;必要性即证\<br>
&amp;充分性:\<br>
&amp;若&lt;a,b&gt;\in R,&lt;a,c&gt;\in R,则&lt;b,c&gt;\in R\<br>
&amp;同时R是自反的\<br>
&amp;\forall &lt;a,b&gt;\in R, 且由自反性有&lt;a,a&gt; \in R \<br>
&amp;由条件可得，&lt;b,a&gt; \in R，故R是对称的\<br>
&amp;\forall &lt;a,b&gt; \in R , &lt;b,c&gt; \in R\<br>
&amp;证明了对称性，有&lt;b,a&gt;\in R,则结合条件可得\<br>
&amp;&lt;a,c&gt;\in R，故R是传递的\<br>
&amp;由等价关系的定义可知R是等价关系\<br>
&amp;充分性得证\<br>
&amp;综上即可得证\<br>
\end{align}<br>
$$</p>
<ol start="5">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;必要性:\<br>
&amp;(也挺显然的)&lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>
&amp;则由传递性，&lt;x,z&gt;\in R\<br>
&amp;再由对称性，&lt;z,x&gt;\in R\<br>
&amp;必要性即证\<br>
&amp;充分性:\<br>
&amp;R是自反的，且R是循环的\<br>
&amp;\forall &lt;x,y&gt; \in R, 由自反性&lt;y,y&gt;\in R\<br>
&amp;再有循环性，有&lt;y,x&gt;\in R，即R是对称的\<br>
&amp;\forall &lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>
&amp;由循环性,&lt;z,x&gt;\in R,又已经证明R是对称的\<br>
&amp;则有&lt;x,z&gt;\in R，故R是传递的\<br>
&amp;必要性得证\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<h2><span id="作业六">作业六</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)能够\<br>
&amp;dom = {1,2,3,4}\<br>
&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;1,4&gt;}\<br>
&amp;(2)能够\<br>
&amp;dom = {1,2,3}\<br>
&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;3,2&gt;}\<br>
&amp;(3)不能够\<br>
&amp;(4)能够\<br>
&amp;dom = {1,2,3}\<br>
&amp;ran = {&lt;2,3&gt;}\<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp; (1)\forall y \in f[A] - f[B]\<br>
&amp;\Rightarrow y \in f[A] \wedge y \notin f[B]\<br>
&amp;\exist x\in A \quad s.t. \quad y = f(x)\<br>
&amp;若x\in B,则与y\notin f[B]矛盾,故x\in A - B\<br>
&amp;即y \in f[A- B]\<br>
&amp;反例:\<br>
&amp;X= {1,2},Y = {0}\<br>
&amp;f = {&lt;1,0&gt;,&lt;2,0&gt;}\<br>
&amp;A = {1,2}, B = {1}\<br>
&amp;此时f[A] = {0},f[B] = {0},f[A] - f[B] = \varnothing\<br>
&amp;f[A-B] = {0}，等号不成立\<br>
&amp;(2)\forall x \in f^{-1}[C-D]\<br>
&amp;\exist y \in C- D , y = f(x)\<br>
&amp;\Rightarrow y\in C\wedge y\notin D\<br>
&amp;\Rightarrow x\in f^{-1}[C] \wedge x \notin f^{-1}[D]\<br>
&amp;\Rightarrow x \in f^{-1}[C]-f^{-1}[D]\<br>
&amp;因此有f^{-1}[C-D]\subseteq f^{-1}[C]-f^{-1}[D]\<br>
&amp;\forall x \in f^{-1}[C]-f^{-1}[D]\<br>
&amp;\exist y \in C ,y = f(x)\<br>
&amp;若y\in D,则x\in f^{-1}[D],矛盾，因此y\notin D\<br>
&amp;\Rightarrow y\in C-D\<br>
&amp;即x \in f^{-1}[C-D]\<br>
&amp;因此有f^{-1}[C]-f^{-a}[D] \subseteq f^{-a}[C-D]\<br>
&amp;故综上有f^{-1}[C-D] = f^{-1}[C]- f^{-1}[D]\<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;单射：(1),(2)\<br>
&amp;满射：(2),(3)\<br>
&amp;双射：(2)\<br>
\end{align}<br>
$$</p>
<h2><span id="作业七">作业七</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;由上课讲的定理显然可得：\<br>
&amp;(定理如下，课上证明了，课下就不证了了吧)\<br>
&amp;f:X ⟶ Y 和 g: Y ⟶ Z，则\<br>
&amp;(1) 若 f 和 g 都是满射，则 g\circ ƒ 也是满射\<br>
&amp;(2) 若 f 和 g 都是单射，则 g\circ ƒ 也是单射\<br>
&amp;(3) 若 f 和 g 都是双射，则 g\circ ƒ 也是双射\<br>
&amp;用数学归纳法显然可证\<br>
&amp;n = 1时，结论成立 \<br>
&amp;若n时结论成立，则n+1时\<br>
&amp;f^{n+1} = f^n \circ f\<br>
&amp;f^n和f都是满射，单射或双射，则f^{n+1}时满射，单射或双射\<br>
&amp;由数学归纳法即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)g\circ f为满射，g为单射\<br>
&amp;则ran(g\circ f) = Z\<br>
&amp;且由课上结论,g为满射，故g为1-1映射\<br>
&amp;dom(g) = Y,g^{-1}[Z] = Y \<br>
&amp;又g[ran(f)] = Z\<br>
&amp;即ran(f) = Y\<br>
&amp;故f为满射\<br>
&amp;综上即可得证\<br>
&amp;(2)g\circ f为单射,f为满射\<br>
&amp;且由课上结论，f为单射，故f为1-1映射\<br>
&amp;\forall y_1 ,y_2\in Y,且y_1 \ne y_2\<br>
&amp;由于f为1-1映射,故存在唯一x_1,x_2,s.t.y_1 = f(x_1),y_2 = f(x_2)\<br>
&amp;若x_1 = x_2 ,则显然y_1 = y_2，故有x_1 \ne x_2\<br>
&amp;则g\circ f(x_1) = g(y_1)  = z_1,g\circ f(x_2) = g(y_2) = z_2\<br>
&amp;由g\circ f为单射,故z_1\ne z_2\<br>
&amp;故可得g也为单射\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;dom(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>
&amp;ran(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>
&amp;dom(h\circ g) = {x | x\in \R}\<br>
&amp;ran(h\circ g) = {x | x\in \R_+ | x = 0}\<br>
&amp;dom(g\circ h) = {x|x \in \R_+ | x = 0}\<br>
&amp;ran(g\circ h) = {x|x \in \R_+ | x = 0}\</p>
<p>\end{align}<br>
$$</p>
<h2><span id="作业7">作业7</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;左推右\<br>
&amp;显然!!f可逆等价于f有唯一的左逆和右逆\<br>
&amp;右推左\<br>
&amp;若f有唯一的左逆(右逆证明类似)\<br>
&amp;那么可以推出f是单射\<br>
&amp;需要证明f是可逆的，那么只需要证明f是右可逆的\<br>
&amp;这里采用反证法，假设f不是右可逆的，那么等价于f不是满射\<br>
&amp;设A中至少有的两个元素为a_1, a_2,由于f是单射\<br>
&amp;设f(a_1) = b_1, f(a_2) = b_2,且有b_1 \ne b_2，同时由于不是满射\<br>
&amp;B中至少存在一个元素，设为b_3,A中没有元素映射到b_3\<br>
&amp;接下来我们构造g_1,g_2,使得g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2\<br>
&amp;g_1(x) = \begin{cases}<br>
a_i, &amp; if, x = b_i,i=1,2\<br>
a_1, &amp; if, x = b_3\<br>
f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>
\end{cases}\<br>
&amp;g_2(x) = \begin{cases}<br>
a_i, &amp; if, x = b_i,i=1,2\<br>
a_2, &amp; if, x = b_3\<br>
f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>
\end{cases}\<br>
&amp;那么就有g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2成立，与f有唯一的左逆矛盾\<br>
&amp;故有上面的反证法可以得到f是右可逆的，那么f是可逆，即可得证\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
(1)&amp;f是左可逆，右可逆，可逆的\<br>
&amp;显然f是单射，满射，因此是可逆的。同时求出f的逆即为f的左逆和右逆\<br>
&amp;构造g(x) = \begin{cases}<br>
4,&amp; if, x= 0\<br>
x-1,&amp; if, x = 1,2,3,4\<br>
x,&amp; if, x &gt; 5<br>
\end{cases}\<br>
&amp;可以验证f\circ g = I_N, g\circ f = I_N\<br>
&amp;即为所求\<br>
(2)&amp;f是右可逆，不是左可逆，不是可逆\<br>
&amp;由于f(1)  = f(3) =  3,因此f不是单射，f不是左可逆\<br>
&amp;f是满射，\forall x \in N,\exist f(2x) = x,2x \in N;<br>
&amp;下面构造f的右逆g\<br>
&amp;g(x) = 2x, x \in N;即为右逆之一<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;\chi_{A-B\cap C}\<br>
&amp;= \chi_A - \chi_A <em>\chi_{B\cap C}\<br>
&amp;= \chi_A - \chi_A</em>\chi_B*\chi_C\<br>
&amp;\chi_{(A-B)\cup (A-C)}\<br>
&amp;=\chi_{A-B} + \chi_{A-C}-\chi_{A-B}<em>\chi_{A-C}\<br>
&amp;=\chi_A-\chi_A</em>\chi_B+\chi_A-\chi_A*\chi_C - (\chi_A-\chi_A*\chi_B)<em>(\chi_A-\chi_A</em>\chi_C)\<br>
&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_A*\chi_C-\chi_A*\chi_B*\chi_A+\chi_A*\chi_B*\chi_A*\chi_C)\<br>
&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_C-\chi_A*\chi_B+\chi_A*\chi_B*\chi_C)\<br>
&amp;=\chi_A - \chi_A*\chi_B*\chi_C\<br>
&amp;于是显然有\chi_{A-B\cap C} = \chi_{(A-B)\cup (A-C)}\<br>
&amp;于是可以证明A-B\cap C = (A-B)\cup(A-C)\<br>
\end{align}<br>
$$</p>
<ol start="4">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;\chi_{A\oplus B}\<br>
&amp;=\chi_{A} - \chi_{A\cap B} + \chi_{B}-\chi_{A\cap B}\<br>
&amp;=\chi_{A} + \chi_{B} - 2*\chi_{A}<em>\chi_{B}\<br>
&amp;=0\<br>
&amp;那么有\chi_{A}</em>(1-\chi_{B}) = \chi_B*(1-\chi_{A})\<br>
&amp;\iff \chi_{A}<em>\chi_{\sim B} = \chi_{B}</em>\chi_{\sim A}\<br>
&amp;\iff \chi_{A\cap \sim B} = \chi_{B\cap \sim A}\<br>
&amp;\iff A\cap \sim B = B \cap \sim A\<br>
&amp;即为所求<br>
\end{align}<br>
$$</p>
<h2><span id="作业8">作业8</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;利用第一数学归纳法进行证明\<br>
&amp;(1)由于为自然数序列，所以显然有0\le a_0\<br>
&amp;(2)\forall n\ge 0,若n \le a_n,下面证明n^+\le a_{n^+}\<br>
&amp;由于为单调递增序列，因此显然有a_n &lt;a_{n^+}\<br>
&amp;同时为正整数序列，由于正整数是不稠密的\<br>
&amp;有a_n + 1 \le a_{n^+}\<br>
&amp;n^+ = n + 1 \le a_n + 1\le a_{n^+}\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;对于本题我们先证明如下结论:\<br>
&amp;\forall i \in n, 有i \subseteq n\<br>
&amp;使用第一数学归纳法进行证明\<br>
&amp;(1)n = 0时显然成立。\<br>
&amp;(2)\forall n \ge 0,若结论成立，即\forall i \in n, 有i\subseteq n\<br>
&amp;那么对于n^+,有n^+ = {n,{n}}\<br>
&amp;\forall i \in n^+, 有i = n 或者i \in n(由三歧性可得)\<br>
&amp;若i = n,显然有i\subseteq n^+\<br>
&amp;若i\in n,由归纳假设，i\in n\<br>
&amp;又n\in n^=,则又i\in n^+\<br>
&amp;故该结论得证\<br>
&amp;对于本题,\forall a \in n,\forall x \in a\<br>
&amp;由于可推出a \in n, 于是显然有x \in n\<br>
&amp;故综上即可得证\forall n \in N 是传递的<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;本题应该是想用二重归纳法做，但是太麻烦了，我就直接用构造法哈(goutou)\<br>
&amp;设n = k(m+1) + t,(t &lt; m+1)\<br>
&amp;由于n &gt; m 且(m+1)\nmid n\<br>
&amp;可得k \ge 1, t \ne 0\<br>
&amp;那么甲第一次取t个球，然后每次乙取x个球\<br>
&amp;甲取(m+1-x)个球，一轮取球数维m+1，故经过k轮\<br>
&amp;恰好甲取完最后的球，获胜<br>
\end{align}<br>
$$</p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散2</tag>
      </tags>
  </entry>
  <entry>
    <title>高代期末</title>
    <url>/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/</url>
    <content><![CDATA[<h1><span id="线代期末串讲">线代期末串讲</span></h1>
<blockquote>
<p><a href="https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C">https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C</a><br>
文件夹名：高代期末串讲<br>
有效期限：永久有效</p>
</blockquote>
<p>资料如上</p>
<span id="more"></span>
<blockquote>
<p>2023 12.31 <a href="hugohealthy.top">胡健</a></p>
</blockquote>
<p>线性代数这门课程的切入点有很多，这里从知识层面上划分出来了线性方程组和向量组，线性空间，矩阵与行列式这三大部分。同时，会讲到几个重要的定理和公式。</p>
<h2><span id="线性方程组和向量组">线性方程组和向量组</span></h2>
<ul>
<li>线性方程组</li>
</ul>
<p>齐次解和非齐次解的讨论<br>
$$<br>
AX=O\<br>
AX=\beta<br>
$$<br>
齐次：有唯一解，有无穷多组解</p>
<p>非齐次：无解，有唯一解，有无穷多组解<br>
$$<br>
有解\iff r(A)=r(A|\beta)<br>
$$<br>
<strong>可拓展到矩阵方程的解的情况</strong></p>
<p>通解问题<br>
$$<br>
\begin{align}<br>
&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p\<br>
&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p + X_1<br>
\end{align}<br>
$$</p>
<ul>
<li>向量组</li>
</ul>
<p>(列向量组)<br>
$$<br>
\alpha_i\in R^n,{\alpha_1\dots \alpha_p}<br>
$$<br>
线性相关与线性无关的含义<br>
$$<br>
\begin{align}<br>
&amp;存在不全为0的k_1\dots k_p,k_1\alpha_1 +\dots k_p\alpha_p = 0\Rightarrow线性相关\<br>
&amp;k_1\alpha_1 +\dots k_p\alpha_p = 0\rightarrow k_1\dots k_p = 0\Rightarrow线性无关<br>
\end{align}<br>
$$</p>
<ul>
<li>极大线性无关与秩</li>
</ul>
<p>极大线性无关组指的是：<br>
$$<br>
\alpha_1\dots\alpha_m线性无关，且加上向量组中任一向量\alpha后线性相关<br>
$$<br>
向量组的秩的含义是极大线性无关组中向量的个数</p>
<ul>
<li>向量组的等价</li>
</ul>
<p>一个向量组A中的每一个向量可以用另一个向量组B来线性表示，称向量组A能由向量组B线性表示</p>
<p>向量组的等价指的是可以相互线性表示</p>
<ul>
<li>
<p>向量组的一些性质</p>
</li>
<li>
<p>相关的线性表示（及其逆，单边法则）</p>
</li>
</ul>
<blockquote>
<p>由线性相关的定义可推出，其中某个向量可以由其余向量线性表示，这又可推出其中的某个向量可以写成前面的向量的线性组合。<br>
所以我们逆过来看，线性无关，等价于<br>
$每一个向量都不可由前面的向量表示（\alpha_i = 0） $<br>
这我们叫做单边法则</p>
</blockquote>
<ul>
<li>大数法则/不大法则</li>
</ul>
<blockquote>
<p>我们先来看，一个向量组被另一个向量组表示被表示的意义。<br>
$S_1组被S_2组表示\Leftrightarrow \forall \alpha_i \in S_1 , \alpha_i 可以被 \beta_j \in S_2 表示 $<br>
大的向量组可以被小的向量组表示，大组必相关<br>
（逆否命题：若A组无关，但可以被B组表示，则A比B小 ——不大法则）<br>
为啥可以被表示，我们可以理解了后面的秩再来说，是不是说AX=B有解啊。</p>
</blockquote>
<ul>
<li>表示的传递性</li>
</ul>
<blockquote>
<p>$我们说S_2 能被S_1表示，S_1能被S_0表示，则S_2能被S_0表示$</p>
</blockquote>
<ul>
<li>唯一表示法则</li>
</ul>
<blockquote>
<p>${\alpha_1,……,\alpha_n}无关,{\alpha_1,……,\alpha_n,\beta}相关，则\beta 由{\alpha_1,……,\alpha_n}唯一表示 $</p>
</blockquote>
<ul>
<li>子组相关法则</li>
</ul>
<blockquote>
<p>子组相关，全组必定相关<br>
proof:<br>
$k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p = 0 (k_1,……,k_p不全为零) $<br>
$\therefore k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p + 0\alpha_{p+1} + …… + 0\alpha_n  = 0$</p>
</blockquote>
<ul>
<li>等数法则</li>
</ul>
<blockquote>
<p>${\alpha_1,……\alpha_p},{\beta_1,……\beta_q}两组无关，且能相互表示，则p=q $<br>
由不大法则可证</p>
</blockquote>
<ul>
<li>长短法则</li>
</ul>
<blockquote>
<p>长相关则短相关，短无关则长无关<br>
看具体怎么理解了，有的老师说“如果矩阵A的子矩阵A0的各行（列）线性无关，则由A0的这些行（列）扩充得到的A的行（列）线性无关。”<br>
这是从大到小，从矩阵看问题<br>
也可以这么理解（从小到大，从向量组）</p>
</blockquote>
<ul>
<li>行变再行变，列的关系不改变</li>
</ul>
<h2><span id="空间解空间内积空间">空间(解空间，内积空间)</span></h2>
<p>解空间(初次接触)</p>
<p>张成空间(你已经会很多了)</p>
<p>欧式空间(你会的差不多了)</p>
<p>线性空间(你会了！！)</p>
<ul>
<li>定义</li>
</ul>
<p>满足八条性质，其实就是满足封闭性和线性性</p>
<ul>
<li>生成空间的定义</li>
</ul>
<p>由向量组表示的所有向量的集合<br>
$$<br>
\begin{align}<br>
&amp;\alpha_1\dots\alpha_m\<br>
&amp;L={\lambda_1\alpha_1 \dots \lambda_m\alpha_m|\lambda_1\dots\lambda_m\in R}<br>
\end{align}<br>
$$</p>
<ul>
<li>解空间的理解</li>
</ul>
<p>定义：n元齐次线性方程组的解集是n维向量空间$F^n$的非空子集(易证满足封闭性和线性性)</p>
<p>生成空间角度：基础解的张成空间</p>
<p>矩阵内积的理解：<br>
$$<br>
(\alpha_1,\dots,\alpha_m)<br>
\begin{pmatrix}<br>
x_1\<br>
\vdots\<br>
x_m<br>
\end{pmatrix}\<br>
AX<br>
$$</p>
<blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230223324226.png" alt></p>
</blockquote>
<ul>
<li>空间的交与和（还有<strong>直和</strong>和<strong>并</strong>，应该不考）</li>
</ul>
<p>how to solve？</p>
<p>$V_1:\alpha_1\dots \alpha_p,V_2:\beta_1\dots\beta_q$</p>
<p>空间的交：<br>
$$<br>
\begin{align}<br>
&amp;\gamma = s_1\alpha_1+\dots s_p\alpha_p = t_1\beta_1+\dots t_q\beta_q\<br>
&amp;解出来后得到s_1\dots s_p\<br>
&amp;带入后易得<br>
\end{align}<br>
$$<br>
空间的和：<br>
$$<br>
\begin{align}<br>
&amp;{\alpha_1\dots\alpha_p,\beta_1\dots\beta_q}这个向量组的极大线性无关组\<br>
&amp;和空间的维数即为极大线性无关组的秩<br>
\end{align}<br>
$$<br>
维数公式<br>
$$<br>
\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim (W_1\cap W_2)<br>
$$<br>
其中$W_1+W_2={w_1+w_2:w_1\in W_1,w_2\in W_2}$</p>
<ul>
<li>内积与Gram矩阵</li>
</ul>
<p>$$<br>
\begin{align}<br>
&amp;A={\alpha_1\dots\alpha_n}\<br>
&amp;Gram=<br>
\begin{pmatrix}<br>
(\alpha_1,\alpha_1)&amp;\dots &amp;(\alpha_1,\alpha_n)\<br>
\vdots &amp;  &amp;\vdots\<br>
(\alpha_n,\alpha_1) &amp;\dots &amp;(\alpha_n,\alpha_n)<br>
\end{pmatrix}\<br>
&amp;Gram=A^TA<br>
\end{align}<br>
$$</p>
<p>定义预正交阵和正交阵</p>
<p>预正交阵：列向量两两正交</p>
<p>正交阵：两向量两两正交且每个列向量的模为1</p>
<p>度量阵：由基向量产生的Gram矩阵，特殊情况下是单位阵</p>
<p>二次型<br>
$$<br>
\begin{align}<br>
&amp;f=\sum_{i=1}^n\sum_{j=1}^na_{ij}x_ix_j\<br>
&amp;二次型对应的矩阵为：\<br>
&amp;\begin{pmatrix}<br>
a_{11}&amp;\dots &amp;a_{1n}\<br>
\vdots &amp;  &amp;\vdots\<br>
a_{n1} &amp;\dots &amp;a_{nn}<br>
\end{pmatrix}\<br>
&amp;a_{ij}=a_{ji}<br>
\end{align}<br>
$$</p>
<ul>
<li>线性映射和线性变换</li>
</ul>
<p>线性映射：$R^n\rightarrow R^m$</p>
<p>线性变换：$R^n\rightarrow R^n$</p>
<blockquote>
<p>这个概念挺抽象的</p>
<p>不同书定义也不一样(点名批评同济大学的紫书)</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230234949295.png" alt></p>
<p>这里以《矩阵论》上面的定义为准</p>
</blockquote>
<ul>
<li>
<p>过渡矩阵与坐标变换公式</p>
<p>若两组基$ S=\begin{bmatrix}{\varepsilon_1,\cdots,\varepsilon_n}\end{bmatrix}, T=\begin{bmatrix}{\eta_1,\dots,\eta_n}\end{bmatrix}$满足基变换公式$ T= S P$，则称$ P$是从$\S$到$ T$的过渡矩阵。</p>
<p>设向量$\alpha$在$ S, T$下的坐标分别为$ X, Y$，则满足坐标变换公式$ X= P Y$。</p>
</li>
<li>
<p>线性变换矩阵</p>
<p>对于一组基$\xi_1,\dots,\xi_n$，若存在矩阵$A$使得线性变换$\sigma$满足$\sigma(\xi_1,\dots,\xi_n)=(\xi_1,\dots,\xi_n) A$，则称矩阵$ A$为线性变换$\sigma$在基$\xi_1,\dots,\xi_n$下所对应的矩阵。</p>
<p>若线性空间$V$的线性变换$\sigma$在两组基$\xi_1,\dots,\xi_n$以及$\eta_1,\dots,\eta_n$下对应的矩阵分别为$ A, B$，$\xi_1,\dots,\xi_n$到$\eta_1,\dots,\eta_n$的过渡矩阵为$ P$，则有$ B= P^{-1} A P$。</p>
</li>
</ul>
<blockquote>
<p>虽然这个也有点抽象，但是整理了一下也就这几个公式</p>
<p>理解不了就记住吧</p>
</blockquote>
<h2><span id="矩阵与行列式">矩阵与行列式</span></h2>
<ul>
<li>矩阵的可逆与正交</li>
</ul>
<p>$$<br>
\begin{align}<br>
&amp;A=A_{n\times n}\<br>
&amp;r(A)=n\<br>
\iff&amp;行满秩\<br>
\iff&amp;列满秩\<br>
\iff&amp;A^{-1}存在\<br>
\iff&amp;|A|\ne 0\<br>
\iff&amp;\lambda_i\ne 0|A|=\lambda_1\dots\lambda_n\<br>
\end{align}<br>
$$</p>
<p>正交：$A^T=A^{-1}$或者$A^TA^{-1}=A^{-1}A^T=I_n$</p>
<ul>
<li>矩阵的秩</li>
</ul>
<p>行秩：行向量组的秩</p>
<p>列秩：列向量组的秩</p>
<p>阶梯秩：化为阶梯阵后非零行的个数</p>
<p>古典秩：存在k阶子式的行列式不为0，任意k+1阶子式的行列式都为0</p>
<blockquote>
<p>这四个是等价的</p>
</blockquote>
<ul>
<li>行列式的计算</li>
</ul>
<blockquote>
<p>这个我感觉高阶的也不会让你算</p>
<p>低阶的直接爆算或者化为上三角行列式</p>
</blockquote>
<p>范德蒙德行列式</p>
<p><strong>下降公式/换位公式</strong></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5C3%E6%8D%A2%E4%BD%8D%E5%85%AC%E5%BC%8F%E4%BE%8B%E9%A2%98.png" alt="换位公式例题"></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004939668.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004927501.png" alt></p>
<ul>
<li>相伴秩公式</li>
</ul>
<p>$$<br>
A=A_{n\times n}\<br>
A^*=<br>
\begin{pmatrix}<br>
A_{11} &amp;A_{21}&amp;\dots &amp;A_{n1}\<br>
\vdots &amp;&amp;&amp;\vdots\<br>
A_{1n} &amp;A_{2n}&amp;\dots &amp;A_{nn}<br>
\end{pmatrix}<br>
$$</p>
<p>注意这里还转置了一下</p>
<p>$AA^*=|A|I_n$</p>
<p>可得$|A^*| = |A|^{n-1}$</p>
<p>和伴随矩阵有关的秩的公式<br>
$$<br>
r(A^*) =<br>
\begin{cases}<br>
n,r(A) = n\<br>
1,r(A)=n-1\<br>
0,else<br>
\end{cases}<br>
$$</p>
<blockquote>
<p>proof:由古典秩的含义</p>
<p>第二个用到$AA^<em>=O 有r(A)+r(A^</em>) \le n $</p>
<p>且$r(A^*) \ge 1$</p>
</blockquote>
<h2><span id="特征值与二次型">特征值与二次型</span></h2>
<ul>
<li>根的遗传公式</li>
</ul>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010720537.png" alt></p>
<blockquote>
<p>零化式</p>
</blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010812719.png" alt></p>
<blockquote>
<p>theory</p>
</blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011008818.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011031258.png" alt></p>
<ul>
<li>Cayley定理</li>
</ul>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011404990.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011426721.png" alt></p>
<ul>
<li>许尔公式</li>
<li>相似对角化</li>
</ul>
<p>可对角化</p>
<ol>
<li>n阶矩阵A与对角阵相似（即A能对角化）的充分必要条件是A有n个线性无关的特征向量。</li>
<li>如果n阶矩阵A的n个特征值互不相等，则A与对角阵相似。</li>
<li>对称阵的特征值为实数</li>
<li>不同特征根的特征向量正交</li>
</ol>
<p>对称阵A对角化的步骤</p>
<ol>
<li>
<p>求出A的全部互不相等的特征值$\lambda_1,\dots \lambda_s$，它们的重数依次为$k_1,\dots k_s(k_1+\dots +k_s = n)$。</p>
</li>
<li>
<p>对每个$k_i$重特征值$\lambda_i$，求方程$(A-\lambda_i I)X=O$的基础解系，得$k_i$个线性无关的特征向量。再把它们<strong>正交化</strong>、单位化，得ki个两两正交的单位特征向量。因$k_1+\dots +k_s=n$，故总共可得n个两两正交的单位特征向量。</p>
</li>
</ol>
<p>$Schimidt$正交化方法</p>
<p>若有$n$个线性无关的向量$\alpha_1,\dots,\alpha_n$，则过程分为正交化和单位化</p>
<p>正交化过程<br>
$$<br>
\beta_k=\alpha_k-\sum_{i=1}^{k-1}\frac{(\beta_i,\alpha_k)}{(\beta_i,\beta_i)}\beta_i,\quad k=1,\dots,n<br>
$$<br>
单位化过程<br>
$$<br>
\eta_k=\frac{\beta_k}{||\beta_k||},\quad k=1,\dots,n<br>
$$<br>
从而得到一组单位正交向量$\eta_1\cdots,\eta_n$。</p>
<ol start="3">
<li>把这n个两两正交的单位特征向量构成正交阵P，便有$P^{-1}AP = P^TAP = Λ$。注意Λ中对角元的排列次序应与P中列向量的排列次序相对应。</li>
</ol>
<ul>
<li>实对称阵的性质</li>
</ul>
<p>实对称矩阵的正交相似对角化</p>
<p>（1）实对称矩阵的特征值均为实数；</p>
<p>（2）实对称矩阵对应不同特征值的特征向量相互正交；</p>
<p>（3）实对称矩阵必定可以相似对角化；</p>
<p>（4）若$ A$是$n$阶实对称矩阵，且特征值为$\lambda_1,\cdots,\lambda_n$，则存在正交矩阵$ Q$，使得<br>
$$<br>
Q^T A Q=\begin{bmatrix}\lambda_1&amp;&amp;\&amp;\ddots\&amp;&amp;\lambda_n\end{bmatrix}<br>
$$<br>
（5）若$ A$和$ B$均为$n$阶实对称矩阵，则$ A$和$ B$相似的充要条件是$ A$和$ B$有相同的特征值。</p>
<ul>
<li>二次型与六二条件</li>
</ul>
<p>正定矩阵：</p>
<p>（1）$ A$所有特征值均为正;</p>
<p>（2）$ A$正惯性指数为$n$；</p>
<p>（3）$ A$与单位阵合同；</p>
<p>（4）$ A$的各阶顺序主子式大于零；</p>
<p>（5）存在可逆矩阵$ P$使得$ A= P^T P$。</p>
<p>（6）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&gt;0$</p>
<p>负定矩阵：</p>
<p>（1）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&lt;0$</p>
<p>（2）$ A$的奇数阶主子式为负，偶数阶主子式为正；</p>
<ul>
<li>双合同定理</li>
</ul>
<p>若$A,B$同阶实对称，其中一个为正定，可设$A$正定，存在可逆$W$,$W^TAW=I_n，W^TBW=diag(d_1,\dots,d_n)$,即$W^TAW,W^TBW$都为对角形</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231015741579.png" alt="image-20231231015741579"></p>
<p><a href="https://zhuanlan.zhihu.com/p/376561675">more</a></p>
<h2><span id="一些典型的整理">一些典型的整理</span></h2>
<ul>
<li>秩公式</li>
</ul>
<p>阶梯阵概念，及其与向量组秩的联系。</p>
<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>
我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>
那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>
所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
<p>秩一阵</p>
<blockquote>
<p>我们来看一个矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
<p>我们在最后再来谈秩的各种公式的关系</p>
<blockquote>
<ul>
<li>满秩则有唯一解<br>
$proof: \because r(A) = n $<br>
$\therefore {\alpha_1,……,\alpha_n}可作为一组基 $<br>
$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>
$坐标即为唯一解 $</li>
<li>满秩则可逆<br>
$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>
$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
<p>所以说到这就只需要明确一个事情，满秩，行向量组列向量组无关，行列式不等于0，可逆，只有唯一解，非奇异这都是等价的概念</p>
<blockquote>
<p>分块秩公式</p>
</blockquote>
<p>$$<br>
r\begin{pmatrix}<br>
A &amp;O\<br>
O &amp;B<br>
\end{pmatrix}=r(A)+a(B)\<br>
r\begin{pmatrix}<br>
O &amp;B\<br>
A &amp;O<br>
\end{pmatrix}=r(A)+a(B)\<br>
r\begin{pmatrix}<br>
A &amp;C\<br>
O &amp;B<br>
\end{pmatrix}\ge r(A)+a(B)\<br>
$$</p>
<blockquote>
<p>乘积不增秩公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;r(AB)\le r(A),r(B)\<br>
&amp;A=A_{m\times n} = (\alpha_1,\dots,\alpha_n),B=B_{n\times p} = (\beta_1,\dots,\beta_p)\<br>
&amp;AB=(A\beta_1,\dots,A\beta_p)\<br>
&amp;A\beta_i=\alpha_1b_1+\dots+\alpha_nb_n,\beta_i=\begin{pmatrix}<br>
b_1\b_2\\vdots\b_n<br>
\end{pmatrix}\<br>
&amp;AB可以被{\alpha_1,\dots,\alpha_n}表示<br>
\end{align}<br>
$$</p>
<blockquote>
<p>积0公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;AB=O\<br>
&amp;r(A)+r(B)\le n<br>
\end{align}<br>
$$</p>
<blockquote>
<p>转置积秩公式</p>
</blockquote>
<p>$$<br>
r(A)+r(B)\le r(AB)+n<br>
$$</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231021249979.png" alt></p>
<blockquote>
<p>加减秩公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;r(A+B)\le r(A)+r(B)\<br>
&amp;r(A-B)\le r(A)+r(B)\<br>
&amp;r(A+B)=r(A|B)r\begin{pmatrix}I_n\I_n\end{pmatrix}\le r(A|B)\le r(A)+r(B)<br>
\end{align}<br>
$$</p>
<ul>
<li>可逆的等价表示</li>
</ul>
<ol>
<li>
<p>$A$的行列式不等于0</p>
</li>
<li>
<p>$A$的秩等于$n$，即$A$为满秩矩阵</p>
</li>
<li>
<p>$A$的行（列）向量组线性无关</p>
</li>
<li>
<p>齐次方程组$Ax=0$只有零解</p>
</li>
<li>
<p>对于任意$b$属于$R^n$(表示向量空间)，Ax=b总有唯一解</p>
</li>
<li>
<p>A与单位矩阵等价</p>
</li>
<li>
<p>A可表示成若干个初等矩阵的乘积</p>
</li>
<li>
<p>A的列向量可以作为n维向量空间$R^n$的一组基</p>
</li>
<li>
<p>$R^n$中任意一个向量都可以由$A$的列向量线性表出</p>
</li>
<li>
<p>$A$的特征值全不为0</p>
</li>
<li>
<p>$A^TA$是正定矩阵</p>
</li>
<li>
<p>$A$是非奇异的</p>
</li>
</ol>
<ul>
<li>求逆的方法学</li>
</ul>
<p>初等变换（常用且方便）</p>
<p>伴随矩阵法</p>
<p>分块矩阵法</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231021933921.png" alt="image-20231231021933921"></p>
<p>零化式法</p>
<ul>
<li>下降公式</li>
</ul>
]]></content>
      <categories>
        <category>高等代数</category>
      </categories>
      <tags>
        <tag>高代</tag>
      </tags>
  </entry>
  <entry>
    <title>离散1</title>
    <url>/2023/05/04/%E7%A6%BB%E6%95%A31/</url>
    <content><![CDATA[<p>这里记录了大一下学期的离散作业与答案，我会在每次作业截止后马上把我的答案放上来<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>
<p>$$<br>
\newcommand{\lfa}[0]{\leftrightarrow}\<br>
\newcommand{\w}[0]{\wedge}\<br>
\newcommand{\v}[0]{\vee}\<br>
\newcommand{\an}[0]{\wedge}\<br>
\newcommand{\o}[0]{\vee}\<br>
\newcommand{\n}[0]{\neg}\<br>
\newcommand{\a}[0]{\forall}\<br>
\newcommand{\e}[0]{\exists}\<br>
$$</p>
<h1><span id="第一次作业">第一次作业</span></h1>
<h2><span id="11">$1.1$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/1.png" alt></p>
<blockquote>
<p>a</p>
</blockquote>
<h2><span id="21">$2.1$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/2.png" alt></p>
<ol>
<li>
<p>不是命题；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
</ol>
<h2><span id="22">$2.2$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/3.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.\neg p\<br>
&amp;2.(\neg p)\wedge (\neg q)\<br>
&amp;3.p\oplus q\<br>
&amp;4.p\to q\<br>
&amp;5.p\to q\<br>
&amp;6.(p\wedge q)\to (r\vee s)\<br>
&amp;7.p\leftrightarrow (q \oplus r)\<br>
&amp;8.p\to q\<br>
&amp;9.p\to q\<br>
&amp;10.p\leftrightarrow q\<br>
&amp;11.\neg(p\vee q)\to r<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/4.png" alt></p>
<h2><span id="23">$2.3$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/5.png" alt></p>
<ol>
<li>永真式</li>
<li>可满足式</li>
<li>可满足式</li>
<li>永真式</li>
<li>永真式</li>
<li>永假式</li>
<li>永真式</li>
</ol>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/6.png" alt></p>
<h2><span id="24">$2.4$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/7.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;p\to (q\to r)\<br>
\iff &amp;\neg p\vee(\neg q\vee r)\<br>
\iff &amp;(\neg p \vee \neg q)\vee r\<br>
\iff &amp;(\neg q \vee \neg p)\vee r\<br>
\iff &amp;\neg q \vee (\neg p\vee r)\<br>
\iff &amp;\neg q \vee (p\to r)\<br>
\iff &amp;q\to(p\to r)\<br>
(2)\<br>
&amp;(p\to q)\wedge(p\to r)\<br>
\iff&amp;(\neg p\vee q)\wedge(\neg p\vee r)\<br>
\iff&amp;\neg p \vee (q\wedge r)\<br>
\iff&amp;p\to q\wedge r\<br>
(3)\<br>
&amp;(p\to q)\vee(r\to q)\<br>
\iff&amp;(\neg p\vee q)\vee(\neg r \vee q)\<br>
\iff&amp;\neg  p\vee\neg r\vee (q\vee q)\<br>
\iff&amp;\neg  p\vee\neg r\vee q\<br>
\iff&amp;\neg(p\wedge r)\vee q\<br>
\iff&amp;p\wedge r \to q\<br>
(4)\<br>
&amp;p\to (q \to p)\<br>
\iff&amp;\neg p \vee (\neg q \vee p)\<br>
\iff&amp;(\neg p\vee p)\vee \neg q\<br>
\iff&amp;1\vee \neg q\<br>
\iff&amp;1\<br>
同时又有&amp;\neg p \to (p\to q)\<br>
\iff&amp;\neg \neg p \vee (\neg p \vee q)\<br>
\iff&amp;(p\vee \neg p)\vee q\<br>
\iff&amp;1\vee q\<br>
\iff&amp;1\<br>
&amp;二者均为永真式，且等值与1，故有二者等值<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/8.png" alt></p>
<h2><span id="25">$2.5$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/32.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;易知(q\to r)\iff (\neg r\to\neg q)\<br>
&amp;由替换实例进行替换\<br>
&amp;有(Q\to R)\iff (\neg R\to\neg Q)\<br>
(2)\<br>
&amp;(p\wedge q)\to r\<br>
\iff&amp;\neg(p\wedge q)\vee r\<br>
\iff&amp;\neg p\vee \neg q\vee r\<br>
\iff&amp;\neg p\vee(\neg q\vee r)\<br>
\iff&amp;\neg p\vee(q\to r)\<br>
\iff&amp;p\to(q\to r)\<br>
&amp;由替换实例进行替换\<br>
&amp;有(P\wedge Q)\to R\iff P\to(Q\to R)<br>
\end{align}<br>
$$</p>
<h2><span id="26">$2.6$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/33.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;\neg(Q\wedge R)\wedge (\neg Q \vee \neg R)\<br>
(2)\<br>
&amp;(p\vee(Q\vee R))\wedge((P\vee Q)\vee R)\wedge 1<br>
\end{align}<br>
$$</p>
<h2><span id="27">$2.7$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/9.png" alt><br>
$$<br>
\begin{align}<br>
&amp;由对偶定理\<br>
(1)\<br>
&amp;A是永真式，则取R为1，R^<em>为0\<br>
&amp;有A\iff R&amp;\<br>
&amp;故A^</em>\iff R^<em>\<br>
&amp;即A^</em> \iff 0\<br>
&amp;故A为永假式\<br>
(2)\<br>
(1)\<br>
&amp;A是永假式，则取R为0，R^<em>为1\<br>
&amp;有A\iff R&amp;\<br>
&amp;故A^</em>\iff R^<em>\<br>
&amp;即A^</em> \iff 1\<br>
&amp;故A为永真式\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/10.png" alt></p>
<h1><span id="第二次作业">第二次作业</span></h1>
<h2><span id="text11">$\text{1.1}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/11.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;(q\to p)\wedge(\neg p \to q)\leftrightarrow \neg p\<br>
\iff&amp;(\neg q \vee p)\wedge(\neg(\neg p) \vee q)\leftrightarrow\neg p\<br>
\iff&amp;(\neg q \vee p)\wedge(q\vee p)\leftrightarrow\neg p\<br>
\iff&amp;(\neg q \wedge q)\vee p \leftrightarrow\neg p\<br>
\iff&amp;p\leftrightarrow \neg p\<br>
\iff &amp;0\<br>
&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>
(2)\<br>
&amp;(p\to q)\wedge(q\to r)\wedge\neg(p\to r)\<br>
\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge\neg(\neg p \vee r)\<br>
\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge(p\wedge \neg r)\<br>
\iff&amp;((\neg p \vee q)\wedge p)\wedge((\neg q \vee r)\wedge \neg r)\<br>
\iff&amp;((\neg p \wedge p ) \vee(q \wedge p))\wedge((\neg q \wedge r)\vee (r \wedge \neg r)) \<br>
\iff&amp;(0 \vee(q \wedge p))\wedge((\neg q \wedge r)\vee 0)\<br>
\iff&amp;(q\wedge p)\wedge (\neg q \wedge r)\<br>
\iff&amp;p \wedge (q\wedge \neg q)\wedge r\<br>
\iff&amp;p\wedge 0 \wedge r\<br>
\iff&amp;0\<br>
&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/12.png" alt></p>
<h2><span id="text12">$\text{1.2}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/13.png" alt><br>
$$<br>
\begin{align}<br>
(1)<br>
&amp;\neg(\neg p \wedge \neg q)\vee \neg (\neg p \vee q)\<br>
\iff&amp;(p\wedge q)\vee (p\wedge \neg q)\<br>
\iff&amp;p\wedge (q\vee \neg q)\<br>
\iff&amp;p\<br>
&amp;故即证该等值式，由对偶定理有\<br>
&amp;\neg (\neg p\wedge \neg q)\wedge \neg (\neg p\wedge  q)\iff  p\<br>
(2)<br>
&amp;(p\vee \neg q)\wedge(p\vee q)\wedge(\neg p \vee \neg q)\<br>
\iff&amp;p\vee (\neg q \wedge q)\wedge (\neg p \vee \neg q)\<br>
\iff&amp;(p\wedge \neg p)\vee(p \wedge \neg q)\<br>
\iff&amp;\neg (\neg p \vee q)\<br>
&amp;故即证该等值式，由对偶定理有\<br>
&amp;(p\wedge \neg q)\vee (p\wedge q)\vee(\neg p \wedge \neg q)\iff\neg (\neg p \wedge q)<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/14.png" alt></p>
<h2><span id="text13">$\text{1.3}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/15.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.{0,\to}\<br>
&amp;首先我们有{\neg ,\to }为极小完全集\<br>
&amp;又由于\neg p \iff p\to 0\<br>
&amp;故{\neg ,\to }是完全集\<br>
&amp;同时只含0的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;2.{\oplus ,\to}\<br>
&amp;首先我们有{\neg ,\to }为极小完全集\<br>
&amp;又由于\neg p \iff p\oplus (p\to p)\<br>
&amp;故{\oplus,\to}是完全集\<br>
&amp;又同时只含\oplus的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;3.{\oplus,\wedge,\leftrightarrow}\<br>
&amp;首先我们有{\neg ,\wedge }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集(书上的例题应该可以用吧）\<br>
&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>
&amp;故{\oplus,\wedge,\leftrightarrow}是完全集\<br>
&amp;又同时只含{\oplus，\wedge}的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;只含{\wedge,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;4.{\oplus,\vee,\leftrightarrow}\<br>
&amp;首先我们有{\neg ,\vee }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集\<br>
&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>
&amp;故{\oplus,\vee,\leftrightarrow}是完全集\<br>
&amp;又同时只含{\oplus，\vee}的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = ,即此时无法表示\neg\<br>
&amp;只含{\vee,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/16.png" alt></p>
<h2><span id="text14">$\text{1.4}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/17.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.{\wedge, \vee, \to ,\leftrightarrow}\<br>
&amp;该集合无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;故该集合不是完全集\<br>
&amp;2.{\wedge,\vee,\oplus}\<br>
&amp;该集合无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;故该集合不是完全集\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/18.png" alt></p>
<h2><span id="text15">$\text{1.5}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/19.png" alt><br>
$$<br>
\begin{align}<br>
1.\<br>
&amp;{\uparrow}是完全集\<br>
&amp;首先我们知道{\neg,\wedge}是完全集\<br>
&amp;且有\neg p \iff p \uparrow p\<br>
&amp;p \wedge q\iff \neg(p \uparrow q)\iff(p \uparrow q)\uparrow(p \uparrow q)\<br>
&amp;故即证该集合为完全集\<br>
2.\<br>
&amp;{\downarrow}是完全集\<br>
&amp;首先我们知道{\neg,\vee}是完全集\<br>
&amp;且有\neg p \iff p \downarrow p\<br>
&amp;p \vee q\iff \neg(p \downarrow q)\iff(p \downarrow q)\downarrow(p \downarrow q)\<br>
&amp;故即证该集合为完全集\<br>
3.\<br>
&amp;{\Delta}为完全集\<br>
&amp;首先若有0 \Delta 0 = 0,或者1 \Delta 1 = 1\<br>
&amp;即0 \Delta 0 = 1,且1 \Delta 1 =0\<br>
&amp;那么\Delta无法表示\neg \<br>
&amp;又类似{\oplus,\leftrightarrow},若1\Delta0\neq 0\Delta 1\<br>
&amp;则仅含p,q两个命题变元而不含其他命题变元的公式A的真值情况中1的个数一定是偶数个\<br>
&amp;故该集合无法表示\wedge,\vee\<br>
&amp;于是\<br>
&amp;若1\Delta0=0\Delta1=0,则此时\Delta 即为\downarrow\<br>
&amp;若1\Delta0=0\Delta1=1,故此时\Delta即为\uparrow\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/20.png" alt></p>
<h2><span id="text16">$\text{1.6}$</span></h2>
<img src="/2023/05/04/%E7%A6%BB%E6%95%A31/Pictures\Screenshots\image-20230416203036176.png" width="800" height="200" alt="图片名称" align="left">
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve_formula</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">"False"</span><span class="token punctuation">}</span>

    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>

    has_true <span class="token operator">=</span> <span class="token boolean">False</span>
    has_false <span class="token operator">=</span> <span class="token boolean">False</span>
    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>
        const_exp <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> variables<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">if</span> x <span class="token keyword">in</span> variables <span class="token keyword">else</span> x<span class="token punctuation">,</span> tokens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            has_true <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            has_false <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">if</span> <span class="token keyword">not</span> has_false<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'永真式'</span>
    <span class="token keyword">elif</span> <span class="token keyword">not</span> has_true<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'永假式'</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'可满足式'</span>

s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入一个合式公式，命题变元最多有p,q,r三个，仅包含与、或、非三种运算，用and,or,not来表示: "</span><span class="token punctuation">)</span>
result <span class="token operator">=</span> solve_formula<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/21.png" alt></p>
<h1><span id="第三次作业">第三次作业</span></h1>
<h2><span id="draft">draft</span></h2>
<p>$$<br>
\begin{align}<br>
&amp;p \lfa q\<br>
\iff&amp;(p\to q)\w(q\to p)\<br>
\iff&amp;(\n p \v q)\w(\n q \v  p)\<br>
\iff&amp;((\n p \v q) \w \n q)\v((\n p  \v q) \w p)\<br>
\iff&amp;(\n p\w \n q)\v(q \w \n q)\v (\n p \w p)\v(q\w p)\<br>
\iff&amp;(p\w q)\v(\n p\w \n q)\<br>
&amp;( p\v q\v r)\w( p\v q\v\n r)\w( p\v\n q\v r)\w( p\v\n q\v\n r)\<br>
&amp;\w( p\v q\v r)\w(\n p\v q\v\n r)\w(\n p\v\n q\v r)\w(\n p\v\n q\v\n r)\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/22.png" alt></p>
<h2><span id="text11">$\text{1.1}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/23.png" alt><br>
$$<br>
\begin{align}<br>
&amp;析取范式:\<br>
&amp;p,p\vee q,p\wedge \neg r,p\vee \neg p;\<br>
&amp;合取范式:\<br>
&amp;p,(p\vee q)\wedge r,p\wedge \neg r.p\vee \neg p;<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/24.png" alt></p>
<p>$p \vee q也是合取范式$</p>
<h2><span id="text12">$\text{1.2}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/25.png" alt></p>
<p>$$<br>
\begin{align}<br>
&amp;1.析取范式有:\<br>
&amp;(1),(2),(3),(5)\<br>
&amp;2.合取范式有:\<br>
&amp;(1),(2),(4)\<br>
&amp;3.主析取范式有:\<br>
&amp;(1),(5)\<br>
&amp;4.主合取范式有:\<br>
&amp;(1)<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/26.png" alt></p>
<h2><span id="text13">$\text{1.3}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/27.png" alt></p>
<p>$$<br>
\begin{align}<br>
(1)&amp;\neg p \wedge q \to r\<br>
\iff&amp;\neg(\neg p \wedge q)\vee r\<br>
\iff&amp;p\vee \neg q\vee r\<br>
&amp;可知主合取范式为:p\vee \neg q\vee r\<br>
&amp;主析取范式为:(\neg p\wedge\neg q\wedge\neg r )\vee(\neg p\wedge\neg q\wedge r )\vee(\neg p\wedge q\wedge r )\vee( p\wedge\neg q\wedge\neg r )\<br>
&amp;\vee( p\wedge\neg q\wedge r )\vee( p\wedge q\wedge\neg r )\vee(p\wedge q\wedge r)\<br>
&amp;且该合式公式为可满足式\<br>
(2)&amp;(p\to q)\to r\<br>
\iff&amp;\neg(\neg p \vee q)\vee r\<br>
\iff&amp;(p\wedge q)\vee r\<br>
\iff&amp;(p\vee r)\wedge(q\vee r)\<br>
\iff&amp;(p\wedge(q\vee \neg q)\vee r)\wedge((p\vee \neg p)\wedge q\vee r)\<br>
\iff&amp;(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>
&amp;可知主合取范式为:(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>
&amp;主析取范式为:(\neg p \wedge \neg q \wedge r)\vee(\neg p \wedge q\wedge r)\vee(p \wedge \neg q \wedge r)\vee(p\wedge q\wedge \neg r)\v(p\w q\w r)\<br>
&amp;且该合式公式为可满足式\<br>
(3)&amp;\n p\v \n q\to (p\lfa \n q)\<br>
\iff&amp;\n (\n p \v \n q)\v (p \w \n q)\v(\n p \w q)\<br>
\iff&amp;(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>
&amp;可知主析取范式为:(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>
&amp;主合取范式:p\v q\<br>
&amp;且该合式公式为可满足式\<br>
(4)&amp;p\v(p\to q\v(\n q \to r))\<br>
\iff&amp;p \v(\n p \v q\v (\n(\n q)\v r))\<br>
\iff&amp;p \v(\n p \v q\v q\v r)\<br>
\iff&amp;1\<br>
&amp;可知主合取范式为:1\<br>
&amp;主析取范式为:(\n p\w\n q\w\n r)\v(\n p \w \n q \w r)\v(\n p \w q \w \n r)\v(\n p\w q\w r)\<br>
&amp;\v(p\w \n q \w \n r)\v(p\w \n q \w  r)\v(p\w q\w \n r)\v(p\w q\w r)\<br>
&amp;且该合式公式为永真式\<br>
(5)&amp;(p\to q \w r)\w(\n p\to \n q\w \n r)\<br>
\iff&amp;(\n p\v(q\w r))\w(\n(\n p)\v(\n q\w \n r))\<br>
\iff&amp;(\n p \v q)\w(\n p \v r)\w(p\v \n q)\w(p\v \n r)\<br>
\iff&amp;((\n p \v q)\v(r\w \n r))\w(\n p \v(q\w \n q)\v r)\w((p\v \n q)\v(r\w \n r))\w(p\v(q\w \n q)\v \n r)\<br>
\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v q\v r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\<br>
&amp;\w(p\v \n q\v\n r)\w(p\v q\v \n r)\w(p\v \n q\v \n r)\<br>
\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>
&amp;可知主合取范式为:(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>
&amp;主析取范式为:(p \w q \w r)\v(\n p\w \n q\w \n r)\<br>
&amp;且该合式公式为可满足式\<br>
(6)&amp;p\w q\w (\n p\v \n q)\<br>
\iff&amp;(p\w q\w \n p)\v(p\w q\w \n q)\<br>
\iff&amp;0\<br>
&amp;可知主析取范式为:0\<br>
&amp;主合取范式为:(p\v q)\w(p\v\n q)\w(\n p\v q)\w(\n p\v\n q)\<br>
&amp;且该合式公式为永假式\<br>
\end{align}<br>
$$</p>
<h2><span id="text14">$\text{1.4}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/34.png" alt></p>
<p>有，<code>p</code>既是关于<code>p</code>的主析取范式，又是关于<code>p</code>的主合取范式</p>
<h2><span id="text15">$\text{1.5}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/28.png" alt><br>
$$<br>
Q\v R,\n Q\vDash R<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/29.png" alt></p>
<h2><span id="text16">$\text{1.6}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/30.png" alt></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">terms</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">}</span>

    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>

    cnt_true <span class="token operator">=</span> <span class="token number">0</span>
    cnt_false <span class="token operator">=</span> <span class="token number">0</span>
    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>
        const_exp <span class="token operator">=</span> exp
        <span class="token keyword">for</span> v <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            const_exp <span class="token operator">=</span> const_exp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>v<span class="token punctuation">,</span> variables<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            cnt_true <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            cnt_false <span class="token operator">+=</span> <span class="token number">1</span>
            
    <span class="token keyword">return</span> cnt_false


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>terms<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/31.png" alt></p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散1</tag>
      </tags>
  </entry>
  <entry>
    <title>高数应用</title>
    <url>/2022/10/23/%E9%AB%98%E6%95%B0%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<div align="center"><font size="24" face="宋体">高等数学不等式问题探讨</font></div>
<span id="more"></span>
<div align="center"><font size="6" face="仿宋">hugo</font></div>
<p>​				<font size="4.5" face="楷体">[<b>摘要</b>]</font>:本文将介绍大学高等数学中遇到的相关不等式问题，介绍一些著名的不等式，如算术几何平均不等式、$\text{Bernoulli}$不等式、$\text{Jensen}$不等式、$\text{Cauchy}$不等式、$\text{Young}$不等式、$\text{Holder}$不等式、$\text{Minkowski}$不等式，以及在遇到不等式问题的常用处理办法，利用构造函数，求导分析单调性等方法，最后再结合一些例题进行具体分析讨论。</p>
<p>​				<font size="4.5" face="楷体">[<b>关键词</b>]</font>:算术几何平均不等式；$\text{Jensen}$不等式；$\text{Cauchy}$不等式；$\text{Young}$不等式；$\text{Bernoulli}$不等式；$\text{Holder}$不等式；$\text{Minkowski}$不等式；构造函数；变上限积分</p>
<h1><span id="1-引言">1   引言</span></h1>
<p>​	在第五届全国大学生数学竞赛非数学类决赛第三题是一道与常微分方程有关的不等式问题：<br>
$$<br>
设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\</p>
<p>f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\</p>
<p>试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>
$$<br>
​	在第八届全国大学生数学竞赛非数学类决赛第二题是一道不等式的综合问题：<br>
$$<br>
设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>
$$<br>
​	在第八届全国大学生数学竞赛非数学类初赛第二题是一道构造变上限积分的题目：<br>
$$<br>
设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\<br>
有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>
$$<br>
​	在第十届全国大学生数学竞赛非数学类第三题是一道典型的运用到了积分形式的$Cauchy$不等式的题目：<br>
$$<br>
设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>
1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>
$$<br>
​	可以看到不等式问题在考试中的考察还是比较多的，特别是近年有增多的趋势，其次在课后练习及相关研究中，不等式问题具有其独特的数学魅力。不等式问题是许多证明题的重要内容，涵盖的知识点丰富，有许多重要的不等式，这些经典的不等式的处理方法多种多样，在这里我将介绍其中个别方法，并对其在n维度量空间的推广加以介绍。同时将就大学高等数学中出现的不等式问题常用到的方法进行分析，如在导数部分常常用到的构造函数求导分析单调性，在积分部分通过构造变上限积分来证明不等式的问题，同时部分不等式证明题还可以用到$\text{Taylor}$展开、微分中值定理和积分中值定理进行证明。</p>
<h1><span id="2-几个重要不等式">2   几个重要不等式</span></h1>
<h4><span id="算术几何平均不等式">算术几何平均不等式</span></h4>
<p>设$n\in N^*,a_i&gt;0(i=1,2,3\dots n)$,则有<br>
$$<br>
{n\over\frac1{a_1}+\frac1{a_2}+\dots +\frac1{a_n}}\le\sqrt[n]{a_1a_2\dots a_n}\le{a_1+a_2+\dots+a_n\over n}\le\sqrt{a_1^2+a_2^2+\dots+a_n^2\over n}\<br>
$$<br>
当且仅当$a_1=a_2=\dots=a_n$时等号成立</p>
<p>**证明：**由归纳法易证</p>
<h4><span id="bernoulli不等式">Bernoulli不等式</span></h4>
<p>当$x\ge -1$时，有<br>
$$<br>
\begin{align}<br>
&amp;(1)若\alpha&gt;1,则有(1+x)^\alpha\ge1+\alpha x;\<br>
&amp;(2)若0&lt;\alpha&lt;1,则有(1+x)^\alpha\le1+\alpha x.<br>
\end{align}<br>
$$<br>
**证明：**构造函数求导分析单调性易证</p>
<h4><span id="jensen不等式">Jensen不等式</span></h4>
<p>设f(x)是区间$I$上的凸函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>
$$<br>
f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\le\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).\<br>
$$<br>
如果f(x)是区间I上的凹函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>
$$<br>
f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\ge\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).<br>
$$</p>
<p><strong>证明</strong>：由归纳法易证</p>
<h4><span id="young不等式">Young不等式</span></h4>
<p>设$a,b\ge0,p,q&gt;1,\frac1p+\frac1q=1$,则有<br>
$$<br>
ab\le\frac{a^p}p+\frac{b^q}q<br>
$$<br>
当且仅当$a^{\frac1q}=b^{\frac1p}$时等号成立</p>
<p><strong>证明：</strong></p>
<p>若$a=b=0$，则有不等式成立，否则不妨设$b&gt;0$。</p>
<p>考虑证明$\text{Young}$不等式的等价形式<br>
$$<br>
\begin{align}<br>
&amp;a^{\frac1p}b^{\frac1q}\le\frac ap+\frac bq\<br>
&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab\right)+1-\frac1p\<br>
&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab -1\right)+1<br>
\end{align}<br>
$$<br>
作换元$x=\frac ab$，则等价于<br>
$$<br>
\left(x\right)^{\frac1p}\le\frac1p\cdot\left(x -1\right)+1<br>
$$<br>
构造函数，结合函数的上凸性易证</p>
<h5><span id="n度量空间的young不等式">n度量空间的Young不等式</span></h5>
<p>设$x_i\ge0,p_i\ge1(i=1,2,\dots,n),\sum_{i=1}^n\frac1{p_i}=1$,则有<br>
$$<br>
\prod_{i=1}^n\le\sum_{i=1}^n\frac{x_i^{p_i}}{p_i}<br>
$$<br>
当且仅当$\frac{x_1^{p_1}}{p_1}=\frac{x_2^{p_2}}{p_2}=\dots=\frac{x_n^{p_n}}{p_n}$时等式成立</p>
<p><strong>证明：</strong></p>
<p>与证明2度量空间的$\text{Young}$不等式的方法类似，只不过需要利用$n-1$维函数$f(x_1,x_2,\dots,x_{n-1})$的上凸性<br>
$$<br>
f(x_1,x_2,\dots,x_{n-1})=\prod_{i=1}^{n-1}x_i^{\frac1{p_i}}<br>
$$<br>
易证</p>
<h4><span id="cauchy不等式">Cauchy不等式</span></h4>
<p>设$a_i,b_i\in R,i=1,2,\dots,n$,有<br>
$$<br>
\left(\sum_{i=1}^na_ib_i\right)^2\le\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)<br>
$$<br>
当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立<br>
$$<br>
\frac{a_1}{b_1}=\frac{a_2}{b_2}=\dots=\frac{a_n}{b_n}<br>
$$</p>
<p><strong>证明：</strong><br>
法一:由归纳法易证<br>
法二:构造二次函数证明<br>
做二次函数<br>
$$<br>
\begin{align}<br>
f(x)&amp;=\left(\sum_{i=1}^na_i^2\right)x^2+2\left(\sum_{i=1}^na_ib_i\right)x+\left(\sum_{i=1}^nb_i^2\right)\<br>
&amp;=\sum_{i=1}^n(a_ix+b_i)^2\<br>
&amp;\ge0<br>
\end{align}<br>
$$<br>
由于<br>
$$<br>
\left(\sum_{i=1}^na_i^2\right)&gt;0<br>
$$<br>
则有<br>
$$<br>
\Delta=4\left(\sum_{i=1}^na_ib_i\right)^2-4\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)\le 0<br>
$$<br>
即证</p>
<h4><span id="holder不等式">Holder不等式</span></h4>
<p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q&gt;1,\frac1p+\frac1q=1$，则有<br>
$$<br>
\sum_{i=1}^na_ib_i\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
$$<br>
当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p>
<p>易见$\text{Cauchy}$不等式是$\text{Holder}$不等式的特例。</p>
<p><strong>证明：</strong></p>
<p>若$a_1=\dots=a_n=0$或$b_1=\dots=b_n=0$则显然结论成立，否则不妨设$a_1,b_1&gt;0$。</p>
<p>令<br>
$$<br>
t=\left(\sum_{i=1}^na_i^p\over\sum_{i=1}^nb_i^q\right)^{\frac1{pq}}<br>
$$<br>
于是有<br>
$$<br>
\begin{align}<br>
&amp;\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)=\frac1p\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}\<br>
&amp;\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)=\frac1q\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
\end{align}<br>
$$<br>
由$\text{Young}$不等式易知该不等式成立<br>
$$<br>
\begin{align}<br>
\sum_{i=1}^na_ib_i&amp;=\sum_{i=1}^n(t\cdot a_i)(\frac{b_i}t)\<br>
&amp;\le\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)+\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)<br>
\end{align}<br>
$$<br>
由$\text{Young}$不等式成立的条件易知该不等式成立的条件即为当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时。</p>
<p>即证</p>
<p>$\text{Holder}$不等式还可以做一个小推广</p>
<p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q,r&gt;1,\frac1p+\frac1q=\frac1r$，则有<br>
$$<br>
\left(\sum_{i=1}^na_ib_i\right)^{\frac1r}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
$$<br>
当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p>
<p><strong>证明：</strong></p>
<p>考虑到$r&lt;p,r&lt;q,\frac rp+\frac rq=1$，然后应用$\text{Holder}$不等式即可得证。</p>
<h5><span id="n度量空间的holder不等式">n度量空间的Holder不等式</span></h5>
<p>设$x_{i,j}\ge0,r&gt;1,p_i&gt;1,\sum_{i=1}^n\frac1{p_i}=\frac1r$，其中$(1\le i\le n,1\le j\le m)$，则有<br>
$$<br>
\left(\sum_{j=1}^m\left(\prod_{i=1}^nx_{i,j}\right)^r\right)^{\frac1r}\le\prod_{i=1}^n\left(\sum_{j=1}^mx_{i,j}^{p_i}\right)^{\frac1{p_i}}<br>
$$<br>
定义一组向量$\vec {x_i}=(x_{i,1}^{p_i},x_{i,2}^{p_i},\dots,x_{i,m}^{p_i}),i=1,2,\dots,n$,当且仅当$\vec {x_i}$相互平行时等式成立。</p>
<p><strong>证明：</strong></p>
<p>用$\text{Holder}$不等式和归纳法进行证明即可。</p>
<h4><span id="minkowski不等式">Minkowski不等式</span></h4>
<p>设$a_i,b_i\ge0,p&gt;1$，则有<br>
$$<br>
\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1p}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}+\left(\sum_{i=1}^nb_i^p\right)^{\frac1p}<br>
$$<br>
当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立</p>
<p><strong>证明：</strong></p>
<p>由$\text{Holder}$不等式有<br>
$$<br>
\begin{align}<br>
\left(\sum_{i=1}^n(a_i+b_i)^p\right)&amp;=\sum_{i=1}^n(a_i+b_i)^{p-1}a_i+\sum_{i=1}^n(a_i+b_i)^{p-1}b_i\<br>
&amp;\le\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum a_i^p\right)^{\frac1p}+\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum b_i^p\right)^{\frac1p}\<br>
&amp;=\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)\<br>
&amp;=\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)<br>
\end{align}<br>
$$<br>
由$\text{Holder}$不等式易知不等式的成立当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时。</p>
<p>即证。</p>
<h1><span id="3-不等式证明常用方法">3   不等式证明常用方法</span></h1>
<h3><span id="放缩法">放缩法</span></h3>
<p>如第五届全国大学生数学竞赛非数学类决赛第三题<br>
$$<br>
设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\<br>
f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\<br>
试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>
$$<br>
<strong>解：</strong></p>
<p>在求导和利用分离变量法求得<br>
$$<br>
\begin{align}<br>
&amp;f’(x)=-\frac{e^{-x}}{1+x}\<br>
&amp;f’(x)&lt;0且f(0)=1\<br>
&amp;有f(x)\le1\<br>
&amp;另一方面\<br>
&amp;f(x)=f(0)-\int_0^x\frac{e^{-t}}{1+t}dt\ge1-\int_0^xe^{-t}dt=e^{-x}.<br>
\end{align}<br>
$$<br>
此题就是典型的利用放缩法求证不等式</p>
<h3><span id="求导法">求导法</span></h3>
<p>如第八届全国大学生数学竞赛非数学类决赛第二题<br>
$$<br>
设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>
$$<br>
<strong>解：</strong><br>
$$<br>
\begin{align}<br>
&amp;f(x)=\frac1{x^2}-\frac1{\tan^2 x}\left(0&lt;x&lt;\frac\pi2\right),则\<br>
&amp;f’(x)={2(x^3\cos x-\sin^3x)\over x^3\sin^3x}\<br>
&amp;令g(x)={six\over \sqrt[3]{\cos x}}-x\left(0&lt;x&lt;\frac\pi2\right)\<br>
&amp;g’(x)=\frac23\cos^{\frac23}x+\frac13\cos^{-\frac43}x-1\<br>
&amp;结合均值不等式可得g’(x)&gt;0,又g(0)=0\<br>
&amp;则有g(x)&gt;0\<br>
&amp;故f’(x)&lt;0,从而f(x)单调递减\<br>
&amp;又\lim\limits_{x\rightarrow \frac\pi2-}=\frac4{\pi^2};\lim\limits_{x\rightarrow0+}=\frac23\<br>
&amp;故即可得证<br>
\end{align}<br>
$$</p>
<h3><span id="构造函数变上限积分">构造函数（变上限积分）</span></h3>
<p>如第八届全国大学生数学竞赛非数学类初赛第二题：<br>
$$<br>
设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>
$$<br>
<strong>解：</strong></p>
<p>构造<br>
$$<br>
\begin{align}<br>
&amp;令F(x)=\left(\int_0^xf(t)dt\right)^2-\int_0^xf^3(t)dt\<br>
&amp;求导有，F’(x)=f(x)\left(2\int_0^xf(t)dt-f^2(x)\right)\<br>
&amp;令G(x)=2\int_0^xf(t)dt-f^2(x)\<br>
&amp;G’(x)=2f(x)(1-f’(x))\<br>
&amp;有G’(x)&gt;0,则G(x)单调递增\<br>
&amp;又G(0)=0,则G(x)&gt;0\<br>
&amp;有F’(X)&gt;0,则F(x)单调递增\<br>
&amp;又F(0)=0\<br>
&amp;即可得证<br>
\end{align}<br>
$$</p>
<h3><span id="利用重要不等式">利用重要不等式</span></h3>
<p>如第十届全国大学生数学竞赛非数学类第三题<br>
$$<br>
设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>
1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>
$$<br>
<strong>解：</strong></p>
<p>所证式子的左式由$\text{Cauchy}$不等式即证</p>
<p>右式由于由基本不等式（算术几何平均不等式的二阶形式）<br>
$$<br>
\begin{align}<br>
\int_0^1f(x)dx\int_0^1\frac3{f(x)}dx&amp;\le\frac14\left(\int_0^1f(x)dx+\int_0^1\frac3{f(x)}dx\right)^2\<br>
&amp;\le4<br>
\end{align}<br>
$$<br>
即证</p>
]]></content>
      <categories>
        <category>数学分析</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
</search>
