<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>p7-流水线</title>
      <link href="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1><blockquote><p>这里是hugo的blog</p></blockquote><blockquote><p>P6-P7</p></blockquote><h2><span id="mips微系统">MIPS微系统</span></h2><p>有亿点点麻烦，首先阐释具体的概念，然后是工程化的应用。</p><ul><li>P7的任务是实现一个简单的计算机系统，即“mips微系统”</li><li>为了实现CPU的异常报告和与外设进行复杂的交互</li></ul><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/%E5%BE%AE%E7%B3%BB%E7%BB%9F.png" alt="img"></p><h3><span id="外设">外设</span></h3><p>暂时不重要</p><ul><li>Timer</li><li>Memory</li><li>InterruptGenerator</li></ul><p>Timer那里的是定时产生时钟中断。</p><p>InterruptGenerator是产生随机的外部中断信号，用来模拟外界情形</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/structure-1701416411059-3.svg" alt="structure"></p><blockquote><ul><li><p><strong>Q：我们计组课程一本参考书目标题中有 “硬件 / 软件接口” 接口字样，那么到底什么是 “硬件 / 软件接口”？(Tips：什么是接口？和我们到现在为止所学的有什么联系？)</strong></p><p><strong>A：</strong> 硬件 / 软件接口是指软件和硬件之间数据交互的接口。在我看来，这个应该指的是操作系统，操作系统将外部软件程序的机器码传入 core，由 core 执行；而 core 执行后产生的数据又通过操作系统传给软件。</p></li><li><p><strong>Q：BE 部件对所有的外设都是必要的吗？</strong></p><p><strong>A：</strong> 我认为没有必要，BE 部件是为了实现 DM 按字节访存设置的，而其他的部件例如 Timer 仅仅支持按字访存，因此不需要 BE 部件。</p></li><li><p><strong>Q：请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</strong></p><p><strong>A：</strong> 鼠标和键盘等外设并不是直接与 CPU 相连的，中间需要通过软件来连接，这个软件也就是我们熟知的驱动。驱动和硬件之间通过操作系统进行处理。</p></li><li><p><strong>Q:</strong> 请开发一个主程序以及定时器的 exception handler。整个系统完成如下功能：</p><p>（1）定时器在主程序中被初始化为模式 0；</p><p>（2）定时器倒计数至 0 产生中断；</p><p>（3）handler 设置使能 Enable 为 1 从而再次启动定时器的计数器。(2) 及 (3) 被无限重复。</p><p>（4）主程序在初始化时将定时器初始化为模式 0，设定初值寄存器的初值为某个值，如 100 或 1000。（注意，主程序可能需要涉及对 <a href="http://CP0.SR">CP0.SR</a> 的编程，推荐阅读过后文后再进行。）</p><p><strong>A:</strong></p><p>verilog</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">主程序<span class="token punctuation">:</span><span class="token punctuation">.</span>textori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>xfc01mtc0 <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x0sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">288</span>sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f04ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00addi <span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">1</span>loop<span class="token punctuation">:</span>add <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>add <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>j loop异常处理程序<span class="token punctuation">:</span><span class="token punctuation">.</span>ktext <span class="token number">0</span>x00004180ori <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x1ori <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9sw <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00sw <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></blockquote><blockquote><p>P5-P6</p></blockquote><p>本次迭代新增了不少calc_r,calc_i型指令，这类指令基本上不敲错code基本上没啥问题，对于新增的md,mt,mf类型的指令，新增一个D_MDU进行处理。</p><p>关键这里将IM和DM进行了外置</p><blockquote></blockquote><p>实现五级流水线CPU</p><ul><li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li><li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li><li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li><li>流水线阶段分为IF，ID，EX，MEM，WB五个部分<ul><li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li><li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li><li>E: <code>ALU</code></li><li>M: <code>DM</code></li><li>W: <code>GRF</code></li></ul></li><li>其中用到大部分的宏定义在<code>def.v</code>中定义</li></ul><h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2><h3><span id="实现指令说明">实现指令说明</span></h3><p>将本CPU实现的指令分为以下几类：</p><table><thead><tr><th>classify</th><th>指令set</th></tr></thead><tbody><tr><td>load</td><td>lw//lh,lhu,lb,lbu</td></tr><tr><td>store</td><td>sw//sh,sb</td></tr><tr><td>calc_r</td><td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td></tr><tr><td>calc_i</td><td>ori//addiu,addi,xori,slti,sltiu</td></tr><tr><td>shift_s</td><td>sll//sra,srl</td></tr><tr><td>shift_v</td><td>//sllv,srav,srlv</td></tr><tr><td>b_type</td><td>beq//bne</td></tr><tr><td>j</td><td>jal,j</td></tr><tr><td>特殊</td><td>jr,lui</td></tr></tbody></table><p>基本的数据通路</p><p>IF阶段的pc需要保留到后面继续使用</p><p>重点处理的在于ALU</p><h3><span id="命名规范">命名规范</span></h3><ul><li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li><li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li><li>寄存器文件采用两边的流水线层级加上_REG的方式。</li></ul><h2><span id="数据通路datapath">数据通路DataPath</span></h2><p>同P4，变量命名有稍微修改。</p><p>但没有单独使用一个DataPath的模块，显得比较多余。</p><p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p><h3><span id="ifu取指令单元">IFU取指令单元</span></h3><p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p><blockquote><p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p></blockquote><h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr><td>i_en</td><td>I</td><td>1</td><td>使能信号</td></tr><tr><td>i_npc</td><td>I</td><td>32</td><td>通过计算得到的下一条指令的地址</td></tr><tr><td>or_pc</td><td>O</td><td>32</td><td>状态转移后的地址，输出当前正在执行的地址</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr><td>3</td><td>写 PC 寄存器</td><td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td></tr></tbody></table><h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_pc</td><td>I</td><td>32</td><td>当前正在执行的地址</td></tr><tr><td>o_instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>取指令</td><td>根据当前PC的值从IM中读出对应的指令</td></tr></tbody></table><h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3><p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_pc</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr><td>i_npcOp</td><td>I</td><td>2</td><td>NPC控制信号</td></tr><tr><td>i_imm16</td><td>I</td><td>16</td><td>branch类型的16位立即数</td></tr><tr><td>i_imm26</td><td>I</td><td>26</td><td>jump类型的26位立即数</td></tr><tr><td>i_jumpEn</td><td>I</td><td>1</td><td>用于得到branch类型的跳转条件是否成立</td></tr><tr><td>i_ra_of_jr</td><td>I</td><td>32</td><td>寄存器中存储的地址</td></tr><tr><td>o_npc</td><td>O</td><td>32</td><td>下一条指令地址</td></tr></tbody></table><table><thead><tr><th>选择信号类型</th><th>位宽</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>NPC_PC4</td><td>3</td><td>3‘b000</td><td>pc+4</td></tr><tr><td>NPC_J</td><td>3</td><td>3’b001</td><td>直接跳转，26位立即数拓展后的地址</td></tr><tr><td>NPC_B</td><td>3</td><td>3’b010</td><td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td></tr><tr><td>NPC_JR</td><td>3</td><td>3’b011</td><td>跳转到寄存器存储的地址</td></tr></tbody></table><ul><li><strong>三种跳转指令</strong></li></ul><p><strong>b型跳转指令</strong></p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p><p>均为判断后跳转到label（即Offset）</p><p><strong>JR型跳转指令(jr,jalr)</strong></p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p><p>跳转到寄存器中的存储的地址</p><p><strong>J型跳转指令(j,jal)</strong></p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p><p>跳转到target这个立即数对应的地址</p><p>其实也可以分为：</p><p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p><p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p><h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr><td>i_writeEn</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>i_A1</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td></tr><tr><td>i_A2</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td></tr><tr><td>i_A3</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td></tr><tr><td>i_WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr><td>o_RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的 32 位数据</td></tr><tr><td>o_RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的 32 位数据</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>i_pc</td><td>I</td><td>32</td><td>用于$display</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>Reset 信号有效时，所有寄存器中储存的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td></tr><tr><td>3</td><td>写数据</td><td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td></tr></tbody></table><h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3><p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_imm16</td><td>I</td><td>16</td><td>16位立即数输入信号</td></tr><tr><td>i_unsigned_ext_Sel</td><td>I</td><td>1</td><td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td></tr><tr><td>o_imm32</td><td>O</td><td>32</td><td>32位立即数输出信号</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>符号拓展</td><td>将16位立即数进行符号拓展</td></tr></tbody></table><h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3><p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p><ul><li>端口定义</li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_cmpA</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>i_cmpB</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>i_branchOp</td><td>I</td><td></td><td>比较类型</td></tr><tr><td>jumpOp</td><td>O</td><td>1</td><td>是否满足跳转条件</td></tr></tbody></table><ul><li>功能定义</li></ul><table><thead><tr><th>branchOP</th><th>位宽</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CMP_EQUAL</td><td>4</td><td>4‘b0000</td><td>判断是否相等</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3><p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ALUOp</td><td style="text-align:left">I</td><td style="text-align:left">4</td><td style="text-align:left">ALU 功能选择信号</td></tr><tr><td style="text-align:left">src_A</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">参与 ALU 计算的第一个值</td></tr><tr><td style="text-align:left">src_B</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">参与 ALU 计算的第二个值 S</td></tr><tr><td style="text-align:left">shamt</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">移位数输入</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">输出 ALU 计算结果</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>ALUOp</th><th>指令</th><th>Opcode</th><th>Op</th></tr></thead><tbody><tr><td>加法</td><td>add</td><td>00000</td><td>ALURes = SrcA+SrcB</td></tr><tr><td>减法</td><td>sub</td><td>00001</td><td>ALURes = SrcA-SrcB</td></tr><tr><td>乘法(low)</td><td>mul</td><td>00010</td><td>ALURes = SrcA*SrcB</td></tr><tr><td>除法(商)</td><td>div</td><td>00011</td><td>ALURes = SrcA / SrcB</td></tr><tr><td>与运算</td><td>and</td><td>00100</td><td>ALURes = SrcA &amp; SrcB</td></tr><tr><td>或运算</td><td>or</td><td>00101</td><td>ALURes = SrcA | SrcB</td></tr><tr><td>异或运算</td><td>xor</td><td>00110</td><td>ALURes = SrcA $\oplus$ SrcB</td></tr><tr><td>或非运算</td><td>nor</td><td>00111</td><td>ALURes = ~(SrcA | SrcB)</td></tr><tr><td>逻辑左移</td><td>sll</td><td>01000</td><td>ALURes = SrcB &lt;&lt; Shift</td></tr><tr><td>逻辑右移</td><td>srl</td><td>01001</td><td>ALURes = SrcB &gt;&gt; Shift</td></tr><tr><td>算数右移</td><td>sra</td><td>01010</td><td>ALURes = SrcB &gt;&gt;&gt; Shift</td></tr></tbody></table><h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr><td>i_Addr</td><td>I</td><td>32</td><td>内存中的地址信号</td></tr><tr><td>i_dmOp</td><td>I</td><td>2</td><td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td></tr><tr><td>i_WriteEn</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>i_writeData</td><td>I</td><td>32</td><td>在写入信号有效时，写入内存地址的数据</td></tr><tr><td>o_RD</td><td>O</td><td>32</td><td>输出内存中对应地址的数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器的中存储的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出A地址对应的存储单元的数据，将其加载到RD</td></tr><tr><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td></tr></tbody></table><h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2><p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p><h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3><ul><li><p><strong>端口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v 中的 clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v 中的 reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">D 级寄存器使能信号</td><td style="text-align:left">HCU 中 stall 信号取反</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">D 级寄存器清空信号</td><td style="text-align:left">默认为 1‘b0</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">F_instr</td><td style="text-align:left">32</td><td style="text-align:left">F 级 instr 输入</td><td style="text-align:left">IFU_instr</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">F_pc</td><td style="text-align:left">32</td><td style="text-align:left">F 级 pc 输入</td><td style="text-align:left">IFU_pc</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">D_instr</td><td style="text-align:left">32</td><td style="text-align:left">D 级 instr 输出</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">D_pc</td><td style="text-align:left">32</td><td style="text-align:left">D 级 pc 输出</td><td style="text-align:left"></td></tr></tbody></table></li></ul><h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3><ul><li><p><strong>端口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_grf_RD1</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from GRF</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_grf_RD2</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from GRF</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from EXT</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_grf_RD1</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_grf_RD2</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p></li></ul><h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3><ul><li><p>端口定义</p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_mem_writeData</td><td style="text-align:left">32</td><td style="text-align:left">关于sw的来自GRF_RD2的信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_mem_writeData</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><blockquote><p>我这里暂停部分在专门的一个模块HU中解决了</p></blockquote><p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p></li></ul><h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3><ul><li><p><strong>接口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_dm_RD</td><td style="text-align:left">32</td><td style="text-align:left">来自dm的数据读出信号</td><td style="text-align:left">from M_DM</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_dm_RD</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li></ul><h2><span id="控制单元_cu">控制单元_CU</span></h2><p>输入改为instr，之前为opcode和func</p><table><thead><tr><th>指令</th><th>Opcode[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0]</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>lw</td><td>100011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>sw</td><td>101011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>nop</td><td>000000</td><td>0</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><h3><span id="分支转移实现">分支转移实现</span></h3><h4><span id="b-类指令">B 类指令</span></h4><p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><h4><span id="j-和-jal">j 和 jal</span></h4><p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p><h4><span id="jr">jr</span></h4><p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><h2><span id="冒险处理">冒险处理</span></h2><p>冒险处理我们均通过 “A_T” 法实现 ——</p><h3><span id="转发forward">转发（forward）</span></h3><p><strong>无脑转发策略。</strong></p><p><strong>将所有在该层级后面的均进行转发。</strong></p><p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p><p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p><p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p><ul><li><p><strong>供应者及其产生的数据</strong></p><table><thead><tr><th style="text-align:left">流水级</th><th style="text-align:left">产生数据</th><th style="text-align:left">MUX 名 &amp; 选择信号名</th><th style="text-align:left">MUX 输出名</th></tr></thead><tbody><tr><td style="text-align:left">E</td><td style="text-align:left">E_E32，E_pc8</td><td style="text-align:left">MUX_E_out &amp; SelEMOut</td><td style="text-align:left">E_out</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">M_AO，M_pc8</td><td style="text-align:left">MUX_M_out &amp; SelEMOut</td><td style="text-align:left">M_out</td></tr><tr><td style="text-align:left">W</td><td style="text-align:left">W_AO，W_RD，W_pc8</td><td style="text-align:left">MUX_W_out &amp; SelWOut</td><td style="text-align:left">W_out</td></tr></tbody></table></li><li><p><strong>需求者及其产生的数据</strong></p><table><thead><tr><th style="text-align:left">接收端口</th><th style="text-align:left">选择数据</th><th style="text-align:left">HMUX 名 &amp; 选择信号名</th><th style="text-align:left">MUX 输出名</th></tr></thead><tbody><tr><td style="text-align:left">CMP_D1/NPC_ra</td><td style="text-align:left">D_V1，M_out，E_out</td><td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td><td style="text-align:left">D_V1_f</td></tr><tr><td style="text-align:left">CMP_D2</td><td style="text-align:left">D_v1，M_out，E_out</td><td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td><td style="text-align:left">D_V2_f</td></tr><tr><td style="text-align:left">ALU_A</td><td style="text-align:left">E_V1， W_out，M_out</td><td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td><td style="text-align:left">E_V1_f</td></tr><tr><td style="text-align:left">ALU_B</td><td style="text-align:left">E_V2，W_out，M_out</td><td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td><td style="text-align:left">E_V1_f</td></tr><tr><td style="text-align:left">DM_WD</td><td style="text-align:left">M_V2， W_out</td><td style="text-align:left">HMUX_DM &amp; FwdDM</td><td style="text-align:left">M_V2_f</td></tr></tbody></table></li></ul><p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p><p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p><ul><li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li><li><strong>写使能信号有效</strong></li></ul><p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p><h3><span id="暂停stall">暂停（stall）</span></h3><p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p><p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p><ul><li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li><li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li></ul><p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p><ul><li><p><strong>Tuse 表</strong></p><table><thead><tr><th style="text-align:left">指令类型</th><th style="text-align:left">Tuse_rs</th><th style="text-align:left">Tuse_rt</th></tr></thead><tbody><tr><td style="text-align:left">calc_R</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">calc_I</td><td style="text-align:left">1</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left">X</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">shiftv</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">load</td><td style="text-align:left">1</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">store</td><td style="text-align:left">1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">branch</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">jump</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">jr</td><td style="text-align:left">0</td><td style="text-align:left">X</td></tr></tbody></table></li><li><p><strong>Tnew 表</strong></p><table><thead><tr><th style="text-align:left">指令类型</th><th style="text-align:left">Tnew_D</th><th style="text-align:left">Tnew_E</th><th style="text-align:left">Tnew_M</th><th style="text-align:left">Tnew_W</th></tr></thead><tbody><tr><td style="text-align:left">calc_R</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">calc_I</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">shiftv</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">load</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">store</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">branch</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">jal</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">jr</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">lui</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr></tbody></table></li></ul><p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p><ul><li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li><li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li><li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li></ul><h1><span id="碎碎念">碎碎念</span></h1><ul><li><p>关于slt</p><blockquote><p>下面这种是错的</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> signed_srcA<span class="token punctuation">,</span> signed_srcB<span class="token punctuation">;</span> <span class="token keyword">assign</span> signed_srcB <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">assign</span> signed_srcA <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  signed_srcA <span class="token operator">&lt;</span> signed_srcB<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种是对的</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote></li><li><p>关于lb</p><blockquote><p>不知道这个为什么会有问题</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v<span class="token punctuation">:</span><span class="token constant">`define</span> GRF_WD_PC4          <span class="token number">3'b000</span><span class="token constant">`define</span> GRF_WD_PC8          <span class="token number">3'b001</span><span class="token constant">`define</span> GRF_WD_ALU_RESULT   <span class="token number">3'b010</span><span class="token constant">`define</span> GRF_WD_MEM_RD       <span class="token number">3'b011</span><span class="token constant">`define</span> GRF_WD_EXT          <span class="token number">3'b100</span><span class="token constant">`define</span> GRF_WD_MDU_RESULT   <span class="token number">3'b101</span># CU<span class="token punctuation">.</span>v<span class="token punctuation">:</span><span class="token keyword">assign</span> o_grf_WD_Sel       <span class="token operator">=</span> <span class="token punctuation">(</span>o_load             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MEM_RD</span>     <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_calc_r <span class="token operator">|</span> o_calc_i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_mf               <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MDU_RESULT</span> <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_link             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_PC8</span>        <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_lui              <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_EXT</span>        <span class="token punctuation">:</span>                                                      <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个W级CU的控制信号（我采用的是分布式译码），然后本来是o_calc_r和o_calc_i那个是第一行，为了测试调整了一下，按照仿真结果</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126002548684.png" alt="image-20231126002548684"></p><p>o_load确实是1,但是为什么这个Sel（grf的写入数据写入信号）为什么还是010（也就是ALU的那个呀）</p><p>测试代码如下：</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003114530.png" alt="image-20231126003114530"></p><p>标准输出：</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003204669.png" alt="image-20231126003204669"></p><p>我的输出：</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003137500.png" alt="image-20231126003137500"></p><p>这个0x0000260f正好就是alu_result也就是计算得到的lb的地址</p></blockquote></li><li><p>bne</p><blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v<span class="token constant">`define</span> NPC_PC4       <span class="token number">3'b000</span><span class="token constant">`define</span> NPC_BRANCH    <span class="token number">3'b001</span><span class="token constant">`define</span> NPC_J         <span class="token number">3'b010</span><span class="token constant">`define</span> NPC_JR        <span class="token number">3'b011</span># CU<span class="token punctuation">.</span>v<span class="token keyword">assign</span> o_npcOp        <span class="token operator">=</span> <span class="token punctuation">(</span>o_b_type <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_BRANCH</span> <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_j_imm26<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span>  <span class="token punctuation">:</span>                             <span class="token punctuation">(</span>o_j_r    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_JR</span> <span class="token punctuation">:</span>                                           <span class="token constant">`NPC_PC4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也出现了类似上面的情况</p><p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126010102868.png" alt="image-20231126010102868"></p><p>也就是o_b_type为1,但是npcOp仍然是PC4的000，而不是001</p></blockquote></li></ul><h1><span id="思考题">思考题</span></h1><blockquote><p>1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p></blockquote><ul><li>乘除法都有较高的延迟，若整合进 ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在 D 级，造成了极大的性能损失。单独设置 MDU 的话，无关的指令还能正常的在 ALU 运行，效率较高。</li><li>HI，LO 寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于 GRF 中，内置在 MDU 中即可。</li></ul><blockquote><p>2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p></blockquote><ul><li><p>真实的流水线 CPU 采用的乘法是有加法器和移位器循环，具体实现过程为：</p><blockquote><p>首先 CPU 会初始化三个通用寄存器用来存放被乘数，乘数，部分积。<br>部分积寄存器初始化为 0。<br>判断乘数寄存器的低位是 0|1，如果为 0 则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。<br>在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。<br>同时部分积寄存器高位补 0。如果为 1 则将部分积寄存器加上被乘数寄存器，再进行移位操作。<br>当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。</p></blockquote></li><li><p>还有另一种乘法的方式：</p><blockquote><p>只需两个寄存器，A [31:0],B [63:0]，A 初始化为被乘数，B 初始化为乘数。<br>每一次取 B 的最低位，为 1 则将 A [31:0]+B [63:32] -&gt; B [63:32]，为 0 则不操作。<br>每次将 B &gt;&gt; 1，然后高位补 0。</p></blockquote></li><li><p>除法实现：</p><blockquote><p>与乘法的操作基本相反，首先 CPU 会初始化三个寄存器，用来存放被除数，除数，部分商。余数 (被除数与除数比较的结果) 放到被除数的有效高位上。CPU 做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先 CPU 会把被除数 bit 位与除数 bit 位对齐，然后再让对齐的被除数与除数比较 (双符号位判断)。比如 01-10=11 (前面的 1 是符号位) 1-2=-1 计算机通过符号位和后一位的 bit 位来判断大于和小于，那么 01-10=11 就说明 01 小于 10，如果得数为 01 就代表大于，如果得数为 00 代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位 (上商就是将商的最低位左移 1 位腾出商寄存器最低位上新的商) 如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。</p></blockquote></li></ul><blockquote><p>3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p></blockquote><ul><li>除 cnt—，和 BusyReg 置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li><li>对于乘除指令：<ul><li>将 Busy，start_E，MDUOp_D 传入 HCU</li><li>然后 md 暂停信号为 <code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li></ul></li></ul><blockquote><p>4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p></blockquote><ul><li>对于需要写入的位置更加的直观，相当于将 DMWE、DMOP 写入的 A [1:0] 用四位字节使能信号表示，十分的统一。</li></ul><blockquote><p>5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p></blockquote><ul><li>按字节读写的时候，我们获得的是一字节，但是我们如果要 lw 或 lh 的话我们就需要拼接。如果是 sw 或 sh 的话我们需要多次存入。</li><li>若用 lb，sb，lh，sh 这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。</li></ul><blockquote><p>6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p></blockquote><ul><li>我们根据不同指令之间的相似性将指令分成了几类 ——calc_R、calc_I、shift、shiftv、load、store、B 类、J 类、md 类、mf 类、mt 类， 并设置对应信号帮助译码，防止计算表达式过长，而且在处理数据冲突时我们只需要将表示该类的信号写入表达式即可。此外，我们将相似功能的控制信号用一个多位宽信号来表示，如针对 DM 的访存功能，我们设置一个 3 位 LSOp 信号；针对乘除槽中的 md、mf、mt 功能，我们设置一个 MDUOp 信号来控制，从而减少了流水寄存器的接口数目，从而降低复杂度。</li></ul><blockquote><p>7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p></blockquote><p>tuse和tnew部分有</p><blockquote><p>8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p></blockquote><p>白嫖捏</p><h3><span id="参考">参考</span></h3><p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p7-知识点整理</title>
      <link href="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="mips-微系统">mips 微系统</span></h1><h2><span id="cp0协处理器">CP0协处理器</span></h2><h3><span id="cpu-控制寄存器"><strong>CPU 控制寄存器</strong></span></h3><table><thead><tr><th>寄存器助记符</th><th>寄存器编号</th><th>描述</th></tr></thead><tbody><tr><td>SR</td><td>12</td><td>State Register</td></tr><tr><td>Cause</td><td>13</td><td>记录异常中断的原因</td></tr><tr><td>EPC</td><td>14</td><td>Exception program counter发生异常和中断后从哪里重新开始执行</td></tr></tbody></table><h4><span id="sr"><strong>SR</strong></span></h4><p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206164953902.png" alt="image-20231206164953902"></p><p>这里我们实际使用到的或者说有意义的只有</p><p><strong>IM——SR[15:10]</strong></p><blockquote><p>其实这里应该指的是SR[15:8]的这8位，其中IP1-0也就是SR[9:8]是由CPU内部产生的</p></blockquote><ul><li>中断屏蔽：一个8位的域定义哪些允许中断源活动时产生异常。其中6个中断源由CPU核外部的信号产生。其余两个是Cause寄存器中软件可写的中断位</li></ul><p><strong>EXL——SR[1]</strong></p><ul><li>异常级：任何异常发生时置位，这会强行进入核心态并禁止中断：目的是吧EXL位维持足够长的时间以便软件决定新的CPU特权级和中断屏蔽该设成什么</li></ul><p><strong>IE——SR[0]</strong></p><ul><li>全局的中断使能位：注意不管这位是什么值，EXL和ERL总是禁止所有的中断</li></ul><h4><span id="cause"><strong>Cause</strong></span></h4><p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206170514085.png" alt="image-20231206170514085"></p><p><strong>BD——Cause[31]</strong></p><ul><li><p>分支延迟：EPC保存的是异常处理完之后的返回地址，正常情况下，这也指向异常受害指令。</p></li><li><p>但是如果发生异常的指令是在一条转移指令的延时槽里，EPC得指向那条转移指令：重新执行转移指令没有- 什么害处，但是如果返回到延迟槽指令本身，转移就不会发生，从而这个异常将破坏被中断的程序。</p></li><li><p>只要异常发生在延迟槽的指令，Cause(BD)就会置为，EPC就会指向分支指令。如果想要分析异常受害指令，只要看看Cause(BD)(如果Cause(BD)==1，那么该指令位于EPC+4)就知道了。</p></li></ul><p><strong>IP——Cause[15:10]</strong></p><blockquote><p>这里其实也是IM一个道理</p></blockquote><p>待决的中断：这里表示待发生的中断。IP照抄CPU硬件的输入信号，<code>IP1-0</code>（软件中断位）可读可写包含你最近写入的值。</p><ul><li>当相应的<code>SR(IM)</code>位（还要受到其它禁止中断的条件约束）允许时，这八位中的任意以为活动都会导致一个中断</li></ul><p><strong>BD——Cause[6:2]</strong></p><p>这是一个5位的编码，告诉你发生了哪种异常。</p><table><thead><tr><th>ExcCode</th><th>助记符</th><th>指令与指令类型</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>Int</td><td>所有指令</td><td>中断</td></tr><tr><td>4</td><td>AdEL</td><td>所有指令<br>load型指令（或特指其中某型）</td><td>（取数，取指或者存数时）地址错误：<br>PC地址未字对齐<br>PC地址超过0x3000-0x6ffc<br><br> （取数，取指或者存数时）地址错误：<br><strong>lw</strong>：取数地址未与4字节对齐<br><strong>lh</strong>：取数地址未与2字节对齐<br><strong>lh，lb</strong>：取Timer</td></tr><tr><td>5</td><td>AdES</td><td>store型指令</td><td>（取数，取指或者存数时）地址错误：<br><strong>sw</strong>：存数地址未4字节对齐<br><strong>sh</strong>：存数地址未2字节对齐<br><strong>sh，sb</strong>：存Timer寄存器的值<br>store型指令：<br>计算地址加法溢出<br>向计时器的Count寄存器存值<br>存数地址超过DM，Timer0，Timer1，中断发生器的范围</td></tr><tr><td>8</td><td>Syscall</td><td>syscall</td><td>系统调用，执行了一条syscall指令</td></tr><tr><td>10</td><td>RI</td><td></td><td>出现未知的指令码</td></tr><tr><td>12</td><td>Ov</td><td>add,addi,sub</td><td>算数溢出</td></tr></tbody></table><h4><span id="epc">EPC</span></h4><p>异常返回地址寄存器。这是一个博爱村异常返回点的寄存器。导致（或者遭受）异常的指令地址存入EPC，除非Cause寄存器中的BD位置位了，这种情况下EPC指向前一条（分支）指令</p><p>​<strong>CPU控制指令</strong></p><table><thead><tr><th>指令</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>mtc0</td><td>s,&lt;n&gt;</td><td>把数据传送到CP0<br>把CPU通用寄存器s中的内容传送到CP0的寄存器n<br>数据为32位</td></tr><tr><td>mfc0</td><td>d,&lt;n&gt;</td><td>从协处理器中取出数据<br>通用寄存器d中装入CPU控制寄存器n的值<br>这是查看控制寄存器的值的唯一方式</td></tr></tbody></table><p>关于mfc0</p><p>想要更新控制寄存器中的单个域——比如说——状态寄存器SR</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mfc0 t0, SRand  t0, &lt;要清零的为的反码&gt;or   t0, &lt;要置1的位&gt;mtc0 SR, t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里有一个比较抽象的话后续再来理解一下</p><p>即返回到用户态和改变特权级的操作必须是同步的，不可分的（原文只讲了不可分的，我的理解就是同步的进行操作）</p><p>用软件触发的异常——异常调用——作为用户代码请求（运行在高特权级上的）操作系统内核服务的唯一机制。</p></blockquote><p><strong>什么时候需要用到哪些寄存器</strong></p><blockquote><p>这里是针对CP0中的控制寄存器而言的</p></blockquote><p><strong>上电后：</strong></p><p>设置SR来使CPU进入一个可工作的状态</p><p><strong>处理任意异常：</strong></p><ul><li><p>早期：调用一个固定入口地址的公共的“通用异常处理程序”</p></li><li><p>自那以后：对不同目的使用分开的异常处理程序</p></li></ul><p>在异常入口处：不保存任何程序寄存器，只有返回地址被存在EPC中。</p><p><strong>从异常返回：</strong></p><ol><li>控制最终必须返回到异常入口处保存到EPC中的地址。</li><li>不管是什么异常，返回时都需要报SR寄存器调整回原来的值，恢复用户态特权、允许中断以及消除异常的一般影响</li><li>异常返回指令eret合并完成了返回用户空间和复位SR(EXL)的功能</li></ol><p><strong>中断：</strong></p><p>SR用来调整中断掩码（掩码就是一串二进制码，掩码的作用是用来存储和操作“状态”）</p><p><strong>纯粹为了引发异常的指令：</strong></p><p>比如<code>break</code>和<code>syscall</code></p><h2><span id="异常-中断及初始化">异常、中断及初始化</span></h2><ul><li>外部事件：在CPU核之外的时间——即来自于真实的“连线”上的输入信号，这就是中断。</li><li>存储器地址转换异常</li><li>程序或硬件检测到的错误：这些包括不存在的指令、在用户权限下非法的指令、在相应SR位被禁止是执行的协处理器指令、整数溢出、地址对齐出错、用户态中访问kuseg以外的地址</li><li>系统调用和自陷</li></ul><h3><span id="精确异常">精确异常</span></h3><p>也就是我们的宏观pc的来由，如果某个pc是异常受害指令，那么我们希望在这个指令之前的指令已经全部处理完成，在这个指令之后的还没有开始处理。</p><p>全部内容如下：</p><ul><li>明确的罪证：在任何异常之后，CPU的控制寄存器EPC都指向一个正确的地方，异常处理之后从该处开始重新执行。在大多数情形中，EPC指向异常受害指令，但是如果异常受害指令处于分支延迟槽内，则EPC指向前面的分支指令：返回到分支指令去重新执行受害指令，但是返回到受害指令将导致分支被忽略。<ul><li>当受害指令处于分支延迟槽内时，原因寄存器的Cause(BD)位置位</li></ul></li><li>异常出现在指令序列中：由于是流水线，而且在不同的流水级都有可能会出现问题，但是我们为了实现精确异常，不应该是出现异常就处理，也就是出现第二条指令的异常事件先发生时需要先处理第一条指令<ul><li>为了避免这一个问题，早期发现的异常并不立即采取措施：该事件只是被记录并沿着流水线传递。在大多数CPU设计中，指定一个特定的流水线阶段作为检测异常的地方。如果当我们的异常记录正沿着流水线向下传递，更老的指令的后期检测到的事件到达了这个终点线，此时异常记录就直接丢弃。</li></ul></li><li>后续指令无效：因为流水线的原因，处于EPC中的受害指令之后的指令就已经开始了。</li></ul><h3><span id="非精确异常">非精确异常</span></h3><blockquote><p>这里实际上指的是历史上的MPIS CPU的乘法器，也就是我们P6的内容，采取直接发送一个busy信号的处理方法，这里我们不在进行讨论</p></blockquote><p><strong>异常发生的时机</strong></p><p>因为异常是精确的，那么异常发生的时间应当也是没有歧义的：</p><ul><li>异常之前执行的最后一条指令就是异常受害指令的前一条。</li><li>如果该异常不是中断：受害指令即是引发异常的指令</li></ul><blockquote><p>下面是MIPS CPU决定处理一个异常是所要做的</p></blockquote><ol><li>设置EPC指向重新开始的地址</li><li>设置SR(EXL)位，强制CPU进入内核态（高特权态）并且禁止中断</li><li>设置Cause寄存器这样软件可以看到发生异常的原因。在地址异常时，BadVAddr也要设置<strong>但是我们课程好像没有这个要求</strong></li><li>然后CPU开始从异常入口点取值，此后一切交给软件处理。<strong>其实也就是继续进行handler处理程序的执行部分</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5p6-流水线</title>
      <link href="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1><p>实现五级流水线CPU</p><span id="more"></span><ul><li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li><li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li><li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li><li>流水线阶段分为IF，ID，EX，MEM，WB五个部分<ul><li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li><li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li><li>E: <code>ALU</code></li><li>M: <code>DM</code></li><li>W: <code>GRF</code></li></ul></li><li>其中用到大部分的宏定义在<code>def.v</code>中定义</li></ul><h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2><h3><span id="实现指令说明">实现指令说明</span></h3><p>将本CPU实现的指令分为以下几类：</p><table><thead><tr><th>classify</th><th>指令set</th></tr></thead><tbody><tr><td>load</td><td>lw//lh,lhu,lb,lbu</td></tr><tr><td>store</td><td>sw//sh,sb</td></tr><tr><td>calc_r</td><td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td></tr><tr><td>calc_i</td><td>ori//addiu,addi,xori,slti,sltiu</td></tr><tr><td>shift_s</td><td>sll//sra,srl</td></tr><tr><td>shift_v</td><td>//sllv,srav,srlv</td></tr><tr><td>b_type</td><td>beq//bne</td></tr><tr><td>j</td><td>jal,j</td></tr><tr><td>特殊</td><td>jr,lui</td></tr></tbody></table><p>基本的数据通路</p><p>IF阶段的pc需要保留到后面继续使用</p><p>重点处理的在于ALU</p><h3><span id="命名规范">命名规范</span></h3><ul><li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li><li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li><li>寄存器文件采用两边的流水线层级加上_REG的方式。</li></ul><h2><span id="数据通路datapath">数据通路DataPath</span></h2><p>同P4，变量命名有稍微修改。</p><p>但没有单独使用一个DataPath的模块，显得比较多余。</p><p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p><h3><span id="ifu取指令单元">IFU取指令单元</span></h3><p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p><blockquote><p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p></blockquote><h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr><td>i_en</td><td>I</td><td>1</td><td>使能信号</td></tr><tr><td>i_npc</td><td>I</td><td>32</td><td>通过计算得到的下一条指令的地址</td></tr><tr><td>or_pc</td><td>O</td><td>32</td><td>状态转移后的地址，输出当前正在执行的地址</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr><td>3</td><td>写 PC 寄存器</td><td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td></tr></tbody></table><h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_pc</td><td>I</td><td>32</td><td>当前正在执行的地址</td></tr><tr><td>o_instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>取指令</td><td>根据当前PC的值从IM中读出对应的指令</td></tr></tbody></table><h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3><p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_pc</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr><td>i_npcOp</td><td>I</td><td>2</td><td>NPC控制信号</td></tr><tr><td>i_imm16</td><td>I</td><td>16</td><td>branch类型的16位立即数</td></tr><tr><td>i_imm26</td><td>I</td><td>26</td><td>jump类型的26位立即数</td></tr><tr><td>i_jumpEn</td><td>I</td><td>1</td><td>用于得到branch类型的跳转条件是否成立</td></tr><tr><td>i_ra_of_jr</td><td>I</td><td>32</td><td>寄存器中存储的地址</td></tr><tr><td>o_npc</td><td>O</td><td>32</td><td>下一条指令地址</td></tr></tbody></table><table><thead><tr><th>选择信号类型</th><th>位宽</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>NPC_PC4</td><td>3</td><td>3‘b000</td><td>pc+4</td></tr><tr><td>NPC_J</td><td>3</td><td>3’b001</td><td>直接跳转，26位立即数拓展后的地址</td></tr><tr><td>NPC_B</td><td>3</td><td>3’b010</td><td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td></tr><tr><td>NPC_JR</td><td>3</td><td>3’b011</td><td>跳转到寄存器存储的地址</td></tr></tbody></table><ul><li><strong>三种跳转指令</strong></li></ul><p><strong>b型跳转指令</strong></p><p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p><p>均为判断后跳转到label（即Offset）</p><p><strong>JR型跳转指令(jr,jalr)</strong></p><p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p><p>跳转到寄存器中的存储的地址</p><p><strong>J型跳转指令(j,jal)</strong></p><p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p><p>跳转到target这个立即数对应的地址</p><p>其实也可以分为：</p><p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p><p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p><h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr><td>i_writeEn</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>i_A1</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td></tr><tr><td>i_A2</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td></tr><tr><td>i_A3</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td></tr><tr><td>i_WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr><td>o_RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的 32 位数据</td></tr><tr><td>o_RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的 32 位数据</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>i_pc</td><td>I</td><td>32</td><td>用于$display</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>Reset 信号有效时，所有寄存器中储存的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td></tr><tr><td>3</td><td>写数据</td><td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td></tr></tbody></table><h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3><p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_imm16</td><td>I</td><td>16</td><td>16位立即数输入信号</td></tr><tr><td>i_unsigned_ext_Sel</td><td>I</td><td>1</td><td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td></tr><tr><td>o_imm32</td><td>O</td><td>32</td><td>32位立即数输出信号</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>符号拓展</td><td>将16位立即数进行符号拓展</td></tr></tbody></table><h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3><p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p><ul><li>端口定义</li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_cmpA</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>i_cmpB</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>i_branchOp</td><td>I</td><td></td><td>比较类型</td></tr><tr><td>jumpOp</td><td>O</td><td>1</td><td>是否满足跳转条件</td></tr></tbody></table><ul><li>功能定义</li></ul><table><thead><tr><th>branchOP</th><th>位宽</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CMP_EQUAL</td><td>4</td><td>4‘b0000</td><td>判断是否相等</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3><p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th style="text-align:left">信号名</th><th style="text-align:left">方向</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ALUOp</td><td style="text-align:left">I</td><td style="text-align:left">4</td><td style="text-align:left">ALU 功能选择信号</td></tr><tr><td style="text-align:left">src_A</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">参与 ALU 计算的第一个值</td></tr><tr><td style="text-align:left">src_B</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">参与 ALU 计算的第二个值 S</td></tr><tr><td style="text-align:left">shamt</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">移位数输入</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">输出 ALU 计算结果</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>ALUOp</th><th>指令</th><th>Opcode</th><th>Op</th></tr></thead><tbody><tr><td>加法</td><td>add</td><td>00000</td><td>ALURes = SrcA+SrcB</td></tr><tr><td>减法</td><td>sub</td><td>00001</td><td>ALURes = SrcA-SrcB</td></tr><tr><td>乘法(low)</td><td>mul</td><td>00010</td><td>ALURes = SrcA*SrcB</td></tr><tr><td>除法(商)</td><td>div</td><td>00011</td><td>ALURes = SrcA / SrcB</td></tr><tr><td>与运算</td><td>and</td><td>00100</td><td>ALURes = SrcA &amp; SrcB</td></tr><tr><td>或运算</td><td>or</td><td>00101</td><td>ALURes = SrcA | SrcB</td></tr><tr><td>异或运算</td><td>xor</td><td>00110</td><td>ALURes = SrcA $\oplus$ SrcB</td></tr><tr><td>或非运算</td><td>nor</td><td>00111</td><td>ALURes = ~(SrcA | SrcB)</td></tr><tr><td>逻辑左移</td><td>sll</td><td>01000</td><td>ALURes = SrcB &lt;&lt; Shift</td></tr><tr><td>逻辑右移</td><td>srl</td><td>01001</td><td>ALURes = SrcB &gt;&gt; Shift</td></tr><tr><td>算数右移</td><td>sra</td><td>01010</td><td>ALURes = SrcB &gt;&gt;&gt; Shift</td></tr></tbody></table><h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>i_clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>i_reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr><td>i_Addr</td><td>I</td><td>32</td><td>内存中的地址信号</td></tr><tr><td>i_dmOp</td><td>I</td><td>2</td><td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td></tr><tr><td>i_WriteEn</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>i_writeData</td><td>I</td><td>32</td><td>在写入信号有效时，写入内存地址的数据</td></tr><tr><td>o_RD</td><td>O</td><td>32</td><td>输出内存中对应地址的数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>reset信号有效时，所有寄存器的中存储的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出A地址对应的存储单元的数据，将其加载到RD</td></tr><tr><td>3</td><td>写数据</td><td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td></tr></tbody></table><h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2><p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p><h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3><ul><li><p><strong>端口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v 中的 clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v 中的 reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">D 级寄存器使能信号</td><td style="text-align:left">HCU 中 stall 信号取反</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">D 级寄存器清空信号</td><td style="text-align:left">默认为 1‘b0</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">F_instr</td><td style="text-align:left">32</td><td style="text-align:left">F 级 instr 输入</td><td style="text-align:left">IFU_instr</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">F_pc</td><td style="text-align:left">32</td><td style="text-align:left">F 级 pc 输入</td><td style="text-align:left">IFU_pc</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">D_instr</td><td style="text-align:left">32</td><td style="text-align:left">D 级 instr 输出</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">D_pc</td><td style="text-align:left">32</td><td style="text-align:left">D 级 pc 输出</td><td style="text-align:left"></td></tr></tbody></table></li></ul><h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3><ul><li><p><strong>端口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_grf_RD1</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from GRF</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_grf_RD2</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from GRF</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left">D级产生的有效信号</td><td style="text-align:left">from EXT</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_grf_RD1</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_grf_RD2</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left">传给E级的有效信号</td><td style="text-align:left"></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p></li></ul><h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3><ul><li><p>端口定义</p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_mem_writeData</td><td style="text-align:left">32</td><td style="text-align:left">关于sw的来自GRF_RD2的信号</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_mem_writeData</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li><li><p><strong>运算功能</strong></p><blockquote><p>我这里暂停部分在专门的一个模块HU中解决了</p></blockquote><p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p></li></ul><h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3><ul><li><p><strong>接口定义</strong></p><table><thead><tr><th style="text-align:left">方向</th><th style="text-align:left">信号名</th><th style="text-align:left">位宽</th><th style="text-align:left">描述</th><th style="text-align:left">输入来源</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">i_clk</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号</td><td style="text-align:left">mips.v中的clk</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_reset</td><td style="text-align:left">1</td><td style="text-align:left">同步复位信号</td><td style="text-align:left">mips.v中的reset</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_en</td><td style="text-align:left">1</td><td style="text-align:left">使能信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_flush</td><td style="text-align:left">1</td><td style="text-align:left">清空信号</td><td style="text-align:left">from HU</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_pc</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_instr</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_dm_RD</td><td style="text-align:left">32</td><td style="text-align:left">来自dm的数据读出信号</td><td style="text-align:left">from M_DM</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">i_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_dm_RD</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_alu_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">or_ext_result</td><td style="text-align:left">32</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li></ul><h2><span id="控制单元_cu">控制单元_CU</span></h2><p>输入改为instr，之前为opcode和func</p><table><thead><tr><th>指令</th><th>Opcode[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0]</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>lw</td><td>100011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>sw</td><td>101011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>nop</td><td>000000</td><td>0</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><h3><span id="分支转移实现">分支转移实现</span></h3><h4><span id="b-类指令">B 类指令</span></h4><p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><h4><span id="j-和-jal">j 和 jal</span></h4><p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p><h4><span id="jr">jr</span></h4><p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p><h2><span id="冒险处理">冒险处理</span></h2><p>冒险处理我们均通过 “A_T” 法实现 ——</p><h3><span id="转发forward">转发（forward）</span></h3><p><strong>无脑转发策略。</strong></p><p><strong>将所有在该层级后面的均进行转发。</strong></p><p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p><p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p><p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p><ul><li><p><strong>供应者及其产生的数据</strong></p><table><thead><tr><th style="text-align:left">流水级</th><th style="text-align:left">产生数据</th><th style="text-align:left">MUX 名 &amp; 选择信号名</th><th style="text-align:left">MUX 输出名</th></tr></thead><tbody><tr><td style="text-align:left">E</td><td style="text-align:left">E_E32，E_pc8</td><td style="text-align:left">MUX_E_out &amp; SelEMOut</td><td style="text-align:left">E_out</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">M_AO，M_pc8</td><td style="text-align:left">MUX_M_out &amp; SelEMOut</td><td style="text-align:left">M_out</td></tr><tr><td style="text-align:left">W</td><td style="text-align:left">W_AO，W_RD，W_pc8</td><td style="text-align:left">MUX_W_out &amp; SelWOut</td><td style="text-align:left">W_out</td></tr></tbody></table></li><li><p><strong>需求者及其产生的数据</strong></p><table><thead><tr><th style="text-align:left">接收端口</th><th style="text-align:left">选择数据</th><th style="text-align:left">HMUX 名 &amp; 选择信号名</th><th style="text-align:left">MUX 输出名</th></tr></thead><tbody><tr><td style="text-align:left">CMP_D1/NPC_ra</td><td style="text-align:left">D_V1，M_out，E_out</td><td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td><td style="text-align:left">D_V1_f</td></tr><tr><td style="text-align:left">CMP_D2</td><td style="text-align:left">D_v1，M_out，E_out</td><td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td><td style="text-align:left">D_V2_f</td></tr><tr><td style="text-align:left">ALU_A</td><td style="text-align:left">E_V1， W_out，M_out</td><td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td><td style="text-align:left">E_V1_f</td></tr><tr><td style="text-align:left">ALU_B</td><td style="text-align:left">E_V2，W_out，M_out</td><td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td><td style="text-align:left">E_V1_f</td></tr><tr><td style="text-align:left">DM_WD</td><td style="text-align:left">M_V2， W_out</td><td style="text-align:left">HMUX_DM &amp; FwdDM</td><td style="text-align:left">M_V2_f</td></tr></tbody></table></li></ul><p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p><p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p><ul><li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li><li><strong>写使能信号有效</strong></li></ul><p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p><h3><span id="暂停stall">暂停（stall）</span></h3><p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p><p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p><ul><li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li><li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li></ul><p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p><ul><li><p><strong>Tuse 表</strong></p><table><thead><tr><th style="text-align:left">指令类型</th><th style="text-align:left">Tuse_rs</th><th style="text-align:left">Tuse_rt</th></tr></thead><tbody><tr><td style="text-align:left">calc_R</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">calc_I</td><td style="text-align:left">1</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left">X</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">shiftv</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">load</td><td style="text-align:left">1</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">store</td><td style="text-align:left">1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">branch</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">jump</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">jr</td><td style="text-align:left">0</td><td style="text-align:left">X</td></tr></tbody></table></li><li><p><strong>Tnew 表</strong></p><table><thead><tr><th style="text-align:left">指令类型</th><th style="text-align:left">Tnew_D</th><th style="text-align:left">Tnew_E</th><th style="text-align:left">Tnew_M</th><th style="text-align:left">Tnew_W</th></tr></thead><tbody><tr><td style="text-align:left">calc_R</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">calc_I</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">shift</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">shiftv</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">load</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">store</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">branch</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">jal</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">jr</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">lui</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr></tbody></table></li></ul><p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p><ul><li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li><li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li><li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li></ul><h1><span id="思考题">思考题</span></h1><blockquote><p>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p></blockquote><ul><li>我们使用两个寄存器值的时间最早来到了 D 级，所以很可能会引发暂停.</li><li>如下面这种情况，若 beq 的结果在 E 级产生，则不需要暂停，可以转发，但是现在 beq 在 D 级的时候 lw 还在 M 级，没有产生结果，需要暂停。</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw    $t0, 0($0)nopbeq   $t0, $t0, label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</p></blockquote><ul><li>因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把 PC+8 写入寄存器，不然 jr 时延迟槽内的指令会再执行一次</li></ul><blockquote><p>3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？</p></blockquote><ul><li>因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</li></ul><blockquote><p>4、我们为什么要使用 GPR 内部转发？该如何实现？</p></blockquote><p>如果你W级写入数据的寄存器与D级读寄存器的地址相同时，将会你导致出现错误的数值，因此需要通过内部转发来规避数据冒险。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 内部转发</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_RD1_D<span class="token punctuation">,</span> D_FWD_RD2_D<span class="token punctuation">;</span>    <span class="token keyword">assign</span> D_FWD_RD1_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A1 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A1 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>                                            r_rf<span class="token punctuation">[</span>i_A1<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">assign</span> D_FWD_RD2_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A2 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A2 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>                                            r_rf<span class="token punctuation">[</span>i_A2<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p></blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>                                                D_grf_RD1<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>                                                D_grf_RD2<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>                                                E_grf_RD1<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>                                                E_grf_RD2<span class="token punctuation">;</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> M_FWD_writeData <span class="token operator">=</span> <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>                              <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>                                                   M_dm_writeData  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p></blockquote><ul><li>高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改数据通路</li><li>对于计算类：首先改变 MCU，注意每个指令的控制信号的对应，再改 ALU 的结构，增加输出选择</li><li>对于访存类：改变 MCU + 修改 DM 增加相应的功能</li><li>对于跳转类：修改 MCU+NPC 相应功能修改</li><li>小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。</li></ul><blockquote><p>7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p></blockquote><p>我采用的是分布式译码。我感觉分布式译码器确实从实际运用上讲会造成器件的浪费，但是单从code上来讲，确实会方便很多，其中把每个instr传进去也感觉十分方便。</p><p>但是可能不足在于修改了CU相应的部分，mips.v和HU.v都需要进行比较大的改动。</p><h3><span id="流水线冒险">流水线冒险</span></h3><ol><li><p><strong>在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</strong></p><p><strong>A</strong>：当需要进行暂停时，IFU 的使能信号失效，PC 值不变。当不需要进行分支转移和跳转时，NPC 中将 F_pc 信号加 4 处理返回 IFU，下一时钟沿来临时更新为 F_pc+4。当执行分支指令时，NPC 将 D_pc +4 和符号扩展后的 imm16 相加，返回 IFU，下一时钟沿上升时更新。当执行 j/jal 指令时，NPC 将 imm26 进行扩展（前四位补 D_pc 的前四位，后两位补 0），返回 IFU，下一时钟沿上升时更新。当执行 jr 指令时，NPC 将从 GRF 的 RD1 端口（考虑转发）输出的值输出，返回 IFU 下一时钟沿上升时更新。</p></li><li><p><strong>对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8 ？</strong></p><p><strong>A</strong>：因为需要考虑编译优化，jal 的下一条指令是延迟槽中的指令，在 jal 执行前会被执行。如果回写 PC+4 的话，当出现 “jr $ra” 时，将会回到延迟槽，重复执行延迟槽中的指令。因此需要回写 PC+8。</p></li></ol><h3><span id="数据冒险的分析">数据冒险的分析</span></h3><ol><li><p><strong>为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由 ALU 或者 DM 等部件来提供数据？</strong></p><p><strong>A</strong>：因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</p></li></ol><h3><span id="at-法处理流水线数据冒险">AT 法处理流水线数据冒险</span></h3><ol><li><p><strong>“转发（旁路）机制的构造” 中的 Thinking 1-4；</strong></p><p><strong>Thinking 1</strong>：如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</p><p><strong>A</strong>：例如：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addi    $s0, $0, 4andi$s1, $s0, 5sw      $s1, 4($s0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Thinking 2</strong>：我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</p><p><strong>A</strong>：因为需要使得 W 级保存的将要写入得数据及时反馈到 GRF 的输出端口，从而规避数据冒险。如果不采用内部转发，我们可以在 GRF 的输出端口加入多路选择器，将 W 级的数据进行转发。</p><p><strong>Thinking 3</strong>：为什么 0 号寄存器需要特殊处理？</p><p><strong>A</strong>：因为对 0 号寄存器的写入是无效的，如果不特殊处理，则会使得向 0 号寄存器写入的数据（无效输入）被错误转发，从而造成 BUG。</p><p><strong>Thinking 4</strong>：什么是 “最新产生的数据”？</p><p><strong>A</strong>: 距离当前需求者最近的流水寄存器中储存的数据。</p></li><li><p><strong>在 AT 方法讨论转发条件的时候，只提到了 “供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？</strong></p><p><strong>A</strong>： 因为当 we 信号为 0 时我们就把 RF 写入地址置为 0，因此如果 “供给者的 A 不为 0”，就已经排除了 “写入信号为 0” 的情况。</p></li></ol><h3><span id="在线测试相关说明">在线测试相关说明</span></h3><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略，<strong>比如构造连续数据冒险序列，请你描述一下你使用的策略如何</strong>结合了随机性</strong>达到强测的效果。</p><p>此思考题请同学们结合自己测试 CPU 使用的具体手段，按照自己的实际情况进行回答。</p><p><strong>A</strong>：我是采用半随机生成半手动构造的方法。对于功能型指令，完全通过 python 脚本自动生成。并且为了提高数据冲突的概率，我们仅仅使用 0~7 号寄存器进行测试。对于跳转指令，我们先使用一定模板进行构建，然后为了增加数据冒险和控制冒险，我们又手动进行一定修改，使得测试样例尽可能更多的覆盖所有可能的情况</p><h3><span id="参考">参考</span></h3><p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5-流水线</title>
      <link href="/2024/02/21/p5-%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2024/02/21/p5-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$五级流水线$\mathscr{Design}$</span></h1><p>实现五级流水线CPU</p><span id="more"></span><ul><li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li><li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li><li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li><li>流水线阶段分为IF，ID，EX，MEM，WB五个部分<ul><li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li><li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li><li>E: <code>ALU</code></li><li>M: <code>DM</code></li><li>W: <code>GRF</code></li></ul></li><li>其中用到大部分的宏定义在<code>def.v</code>中定义</li></ul><h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2><p>基本的数据通路</p><p>IF阶段的pc需要保留到后面继续使用</p><p>重点处理的在于ALU</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4-CPU-设计文档</title>
      <link href="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
      <url>/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1><span id="单周期mips架构cpu的verilog实现">单周期mips架构CPU的verilog实现</span></h1><p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p><h2><span id="数据路径">数据路径</span></h2><p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p><h3><span id="ifu取指令单元">IFU取指令单元</span></h3><p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p><blockquote><p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p></blockquote><h4><span id="pc程序计数器">PC（程序计数器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr><td>npc</td><td>I</td><td>32</td><td>通过计算得到的下一条指令的地址</td></tr><tr><td>pc</td><td>O</td><td>32</td><td>状态转移后的地址，输出当前正在执行的地址</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr><td>3</td><td>写 PC 寄存器</td><td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td></tr></tbody></table><h4><span id="im指令存储器">IM（指令存储器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>pc</td><td>I</td><td>32</td><td>当前正在执行的地址</td></tr><tr><td>instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>取指令</td><td>根据当前PC的值从IM中读出对应的指令</td></tr></tbody></table><h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3><p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>pc</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr><td>npcOp</td><td>I</td><td>2</td><td>NPC控制信号</td></tr><tr><td>Imm16</td><td>I</td><td>16</td><td>branch类型的16位立即数</td></tr><tr><td>jumpEn</td><td>I</td><td>1</td><td>用于得到branch类型的跳转条件是否成立</td></tr><tr><td>imm26</td><td>I</td><td>26</td><td>jump类型的26位立即数</td></tr><tr><td>regAddr</td><td>I</td><td>32</td><td>寄存器中存储的地址</td></tr><tr><td>PC+4</td><td>O</td><td>32</td><td>输出PC+4的值</td></tr><tr><td>npc</td><td>O</td><td>32</td><td>下一条指令地址</td></tr></tbody></table><table><thead><tr><th>选择信号类型</th><th>位宽</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>NPC_PC_4</td><td>2</td><td>2‘b00</td><td>pc+4</td></tr><tr><td>NPC_J</td><td>2</td><td>2’b01</td><td>直接跳转，26位立即数拓展后的地址</td></tr><tr><td>NPC_B</td><td>2</td><td>2’b10</td><td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td></tr><tr><td>NPC_JR</td><td>2</td><td>2’b11</td><td>跳转到寄存器存储的地址</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><ul><li><strong>三种跳转指令</strong></li></ul><p><strong>b型跳转指令</strong></p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165229781.png" alt="image-20240221165229781"></p><p>均为判断后跳转到label（即Offset）</p><p><strong>JR型跳转指令(jr,jalr)</strong></p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165224329.png" alt="image-20240221165224329"></p><p>跳转到寄存器中的存储的地址</p><p><strong>J型跳转指令(j,jal)</strong></p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165218734.png" alt="image-20240221165218734"></p><p>跳转到target这个立即数对应的地址</p><p>其实也可以分为：</p><p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p><p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p><h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>Reset</td><td>I</td><td>1</td><td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>A1</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td></tr><tr><td>A2</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td></tr><tr><td>A3</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td></tr><tr><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr><td>RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的 32 位数据</td></tr><tr><td>RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的 32 位数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>Reset 信号有效时，所有寄存器中储存的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td></tr><tr><td>3</td><td>写数据</td><td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td></tr></tbody></table><h3><span id="ext拓展单元">EXT（拓展单元）</span></h3><p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>imm16</td><td>I</td><td>16</td><td>16位立即数输入信号</td></tr><tr><td>extUnsignedSel</td><td>I</td><td>1</td><td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td></tr><tr><td>imm32</td><td>O</td><td>32</td><td>32位立即数输出信号</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>符号拓展</td><td>将16位立即数进行符号拓展</td></tr></tbody></table><h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3><table><thead><tr><th>ALUOp</th><th>指令</th><th>Opcode</th><th>Op</th></tr></thead><tbody><tr><td>加法</td><td>add</td><td>0000</td><td>ALURes = SrcA+SrcB</td></tr><tr><td>减法</td><td>sub</td><td>0001</td><td>ALURes = SrcA-SrcB</td></tr><tr><td>乘法(low)</td><td>mul</td><td>0010</td><td>ALURes = SrcA*SrcB</td></tr><tr><td>除法(商)</td><td>div</td><td>0011</td><td>ALURes = SrcA / SrcB</td></tr><tr><td>与运算</td><td>and</td><td>0100</td><td>ALURes = SrcA &amp; SrcB</td></tr><tr><td>或运算</td><td>or</td><td>0101</td><td>ALURes = SrcA | SrcB</td></tr><tr><td>异或运算</td><td>xor</td><td>0110</td><td>ALURes = SrcA $\oplus$ SrcB</td></tr><tr><td>或非运算</td><td>nor</td><td>0111</td><td>ALURes = ~(SrcA | SrcB)</td></tr><tr><td>逻辑左移</td><td>sll</td><td>1000</td><td>ALURes = SrcB &lt;&lt; Shift</td></tr><tr><td>逻辑右移</td><td>srl</td><td>1001</td><td>ALURes = SrcB &gt;&gt; Shift</td></tr><tr><td>算数右移</td><td>sra</td><td>1010</td><td>ALURes = SrcB &gt;&gt;&gt; Shift</td></tr></tbody></table><h3><span id="dm数据存储器">DM（数据存储器）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>clk</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>1</td><td>复位信号</td></tr><tr><td>addr</td><td>I</td><td>32</td><td>内存中的地址信号</td></tr><tr><td>dmOp</td><td>I</td><td>2</td><td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td></tr><tr><td>dmWriteEn</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>WD</td><td>I</td><td>32</td><td>在写入信号有效时，写入内存地址的数据</td></tr><tr><td>RD</td><td>O</td><td>32</td><td>输出内存中对应地址的数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h3><span id="splitter">Splitter</span></h3><ul><li>端口定义</li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>instr</td><td>I</td><td>32</td><td>输入指令信号</td></tr><tr><td>opcode</td><td>O</td><td>6</td><td>instr[31:26]</td></tr><tr><td>rs</td><td>O</td><td>5</td><td>instr[25:21]</td></tr><tr><td>base</td><td>O</td><td>5</td><td>instr[25:21]</td></tr><tr><td>rt</td><td>O</td><td>5</td><td>instr[20:16]</td></tr><tr><td>rd</td><td>O</td><td>5</td><td>instr[15:11]</td></tr><tr><td>sa</td><td>O</td><td>5</td><td>instr[10:6]</td></tr><tr><td>func</td><td>O</td><td>6</td><td>instr[5:0]</td></tr><tr><td>imm26</td><td>O</td><td>26</td><td>instr[25:0]</td></tr><tr><td>imm16</td><td>O</td><td>16</td><td>instr[15:0]</td></tr></tbody></table><h3><span id="cmp">CMP</span></h3><p>用于生成Branch类跳转信号是否跳转的使能信号</p><ul><li>端口定义</li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>cmpA</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>cmpB</td><td>I</td><td>32</td><td>输入信号</td></tr><tr><td>branchOp</td><td>I</td><td></td><td>比较类型</td></tr><tr><td>jumpOp</td><td>O</td><td>1</td><td>是否满足跳转条件</td></tr></tbody></table><ul><li>功能定义</li></ul><table><thead><tr><th>branchOP</th><th>值</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="控制">控制</span></h2><h3><span id="cu">CU</span></h3><table><thead><tr><th>指令</th><th>Opcode[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>lw</td><td>100011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>sw</td><td>101011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>nop</td><td>000000</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p><p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p><p>其次从CU的角度开始处理指令。</p><p>第一步，<strong>输入信号</strong>。</p><p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p><p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p><p>然后利用<code>Or Logical</code>，来激活相应的接口。</p><p>第二步，对于<strong>lw指令</strong>。</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165208821.png" alt="image-20240221165208821"></p><p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p><p>第三步，对于<strong>sw信号</strong>。</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165204960.png" alt="image-20240221165204960"></p><p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p><p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p><h2><span id="自动化测试">自动化测试</span></h2><h2><span id="思考题">思考题</span></h2><ul><li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024 字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</li></ul><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165157185.png" alt="image-20240221165157185"></p><blockquote><p>addr信号来自于ALU。因为是按字存储的，每四个byte一个字节。</p></blockquote><ul><li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</li></ul><blockquote><p>记录指令的控制信号如何取值</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>     <span class="token function">if</span><span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>         <span class="token function">case</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>              <span class="token number">6'b100000</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>                 npcOp <span class="token operator">==</span> <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span>                 writeRegSel <span class="token operator">==</span> <span class="token constant">`CU_GRF_A3_RD</span><span class="token punctuation">;</span>                 grfWriteEn <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>             <span class="token keyword">end</span>         <span class="token keyword">endcase</span>     <span class="token keyword">end</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span>         <span class="token keyword">case</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">:</span>             <span class="token constant">`CU_add_OP</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>         <span class="token keyword">end</span>     <span class="token keyword">endcase</span>             <span class="token keyword">end</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记录控制信号每种取值所对应的指令</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> npcOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`NPC_B</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>j <span class="token operator">|</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>jr<span class="token punctuation">)</span>      <span class="token operator">?</span> <span class="token constant">`NPC_JR</span><span class="token punctuation">:</span>                           <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span><span class="token keyword">assign</span> writeRegSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> sll<span class="token punctuation">)</span>       <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">:</span>                     <span class="token punctuation">(</span>ori <span class="token operator">|</span> lw  <span class="token operator">|</span> sw <span class="token operator">|</span> lui <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RT</span> <span class="token punctuation">:</span>                     <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                   <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RA</span> <span class="token punctuation">:</span>                                               <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">;</span><span class="token keyword">assign</span> grfWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll <span class="token operator">|</span> jal <span class="token operator">|</span> lw<span class="token punctuation">)</span> <span class="token operator">?</span>  <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> writeRegDataSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_ALURESULT</span> <span class="token punctuation">:</span>                         <span class="token punctuation">(</span>lw<span class="token punctuation">)</span>                          <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_MEMRD</span> <span class="token punctuation">:</span>                         <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                         <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_PC_4</span> <span class="token punctuation">:</span>                                                         <span class="token constant">`CU_GRF_WD_ALURESULT</span><span class="token punctuation">;</span><span class="token keyword">assign</span> extUnsignedSel <span class="token operator">=</span> <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> aluSrcSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> beq <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">:</span>                   <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span>   <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_IMM32</span>  <span class="token punctuation">:</span>                                             <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">;</span><span class="token keyword">assign</span> shamtSel <span class="token operator">=</span> <span class="token punctuation">(</span>lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_16</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span> <span class="token punctuation">:</span>                          <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span><span class="token punctuation">;</span><span class="token keyword">assign</span> aluOp <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ALU_add</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>sub<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_sub</span> <span class="token punctuation">:</span>               <span class="token punctuation">(</span>ori<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_or</span>  <span class="token punctuation">:</span>               <span class="token punctuation">(</span>lui <span class="token operator">|</span> sll<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`ALU_sll</span> <span class="token punctuation">:</span>                                 <span class="token constant">`ALU_add</span><span class="token punctuation">;</span><span class="token keyword">assign</span> dmWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> dmOp <span class="token operator">=</span> <span class="token punctuation">(</span>lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`DM_WORD</span> <span class="token punctuation">:</span>                          <span class="token constant">`DM_WORD</span> <span class="token punctuation">;</span><span class="token keyword">assign</span> branchOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_EQUAL</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>bne<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_NOT_EQUAL</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>bge<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER_OR_EQUAL</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>ble<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS_OR_EQUAL</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>blt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS</span> <span class="token punctuation">:</span>                  <span class="token punctuation">(</span>bgt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER</span> <span class="token punctuation">:</span>                          <span class="token constant">`CMP_EQUAL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>记录指令的控制信号如何取值，更加方便记录追踪每一条指令的问题。这个对于增加指令也比较方便。</li><li>记录控制信号每种取值所对应的指令，方便看某一个控制指令的组成</li></ul></blockquote><ul><li>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</li></ul><blockquote><p>同步复位中，clk信号优先于reset信号。</p><p>异步复位中，reset信号优先于clk信号。</p></blockquote><ul><li>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</li></ul><blockquote><p>addi和addiu的区别，add和addu的区别在于addi和add在溢出是会报溢出异常，忽略溢出二者自然就相同了嘛。</p><ul><li><p>add</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165124611.png" alt="image-20240221165124611"></p></li><li><p>addu</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165132920.png" alt="image-20240221165132920"></p></li><li><p>addi</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165139866.png" alt="image-20240221165139866"></p></li><li><p>addiu</p><p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165148096.png" alt="image-20240221165148096"></p></li></ul></blockquote><h2><span id="命名的合理性">命名的合理性</span></h2><p>元件统一大驼峰（首字母大写）</p><p>接口连线统一小驼峰（首字母小写），单个字母仍然使用大写以保证美观。（想了想GRF还是采用以前的A1这种命名吧，不然感觉好奇怪。</p><p><strong>操作控制</strong>：选择信号以Op结尾</p><p><strong>写使能控制</strong>：使能信号以En结尾</p><p><strong>多路控制</strong>：多路选择器开关信号以Sel结尾。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p3-CPU-设计文档</title>
      <link href="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
      <url>/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1><span id="单周期mips架构cpu的logisim实现">单周期mips架构CPU的logisim实现</span></h1><p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p><span id="more"></span><h2><span id="数据路径">数据路径</span></h2><p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p><h3><span id="ifu取指令单元">IFU取指令单元</span></h3><p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>Reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr><td>Stop</td><td>I</td><td>1</td><td>停止信号</td></tr><tr><td>PC’</td><td>I</td><td>32</td><td>通过计算得到的下一条指令的地址</td></tr><tr><td>PC</td><td>O</td><td>32</td><td>状态转移后的地址，输出当前正在执行的地址</td></tr><tr><td>Instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr><td>3</td><td>写 PC 寄存器</td><td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td></tr><tr><td>4</td><td>取指令</td><td>根据当前 PC 的值从 IM（指令存储器）中读出对应的指令到 Instr 端口</td></tr></tbody></table><h4><span id="pc程序计数器">PC（程序计数器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>Reset</td><td>I</td><td>1</td><td>异步复位信号</td></tr><tr><td>Stop</td><td>I</td><td>1</td><td>停止信号</td></tr><tr><td>PC’</td><td>I</td><td>32</td><td>通过计算得到的下一条指令的地址</td></tr><tr><td>PC</td><td>O</td><td>32</td><td>状态转移后的地址，输出当前正在执行的地址</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td></tr><tr><td>2</td><td>停止</td><td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td></tr><tr><td>3</td><td>写 PC 寄存器</td><td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td></tr></tbody></table><h4><span id="im指令存储器">IM（指令存储器）</span></h4><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>PC</td><td>I</td><td>32</td><td>当前正在执行的地址</td></tr><tr><td>Instr</td><td>O</td><td>32</td><td>输出当前正在执行的指令</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>取指令</td><td>根据当前PC的值从IM中读出对应的指令</td></tr></tbody></table><h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3><p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>PC</td><td>I</td><td>32</td><td>当前指令地址</td></tr><tr><td>Branch</td><td>I</td><td>1</td><td>是否为Branch型指令，控制信号</td></tr><tr><td>Equals</td><td>I</td><td>1</td><td>是否满足Branch跳转判断</td></tr><tr><td>Offset</td><td>I</td><td>32</td><td>进行符号拓展后的立即数信号<br>Branch &amp; Equals==1:b型跳转</td></tr><tr><td>JUMP</td><td>I</td><td>1</td><td>是否为j指令或者jal指令，控制信号<br>1：J型跳转</td></tr><tr><td>Imm_26</td><td>I</td><td>26</td><td>26位立即数信号，拓展后即为跳转地址</td></tr><tr><td>JR</td><td>I</td><td>1</td><td>是否为jr或者jalr指令，控制信号<br>1：JR型跳转</td></tr><tr><td>Ra</td><td>I</td><td>32</td><td>寄存器中存储的地址数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><ul><li><strong>三种跳转指令</strong></li></ul><p><strong>b型跳转指令</strong></p><p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165252314.png" alt="image-20240221165252314"></p><p>均为判断后跳转到label（即Offset）</p><p><strong>JR型跳转指令(jr,jalr)</strong></p><p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165258299.png" alt="image-20240221165258299"></p><p>跳转到寄存器中的存储的地址</p><p><strong>J型跳转指令(j,jal)</strong></p><p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165302941.png" alt="image-20240221165302941"></p><p>跳转到target这个立即数对应的地址</p><p>其实也可以分为：</p><p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p><p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p><h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>Reset</td><td>I</td><td>1</td><td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td></tr><tr><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>A1</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td></tr><tr><td>A2</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td></tr><tr><td>A3</td><td>I</td><td>5</td><td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td></tr><tr><td>WD</td><td>I</td><td>32</td><td>数据输入信号</td></tr><tr><td>RD1</td><td>O</td><td>32</td><td>输出A1指定的寄存器中的 32 位数据</td></tr><tr><td>RD2</td><td>O</td><td>32</td><td>输出A2指定的寄存器中的 32 位数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>Reset 信号有效时，所有寄存器中储存的值均被清零</td></tr><tr><td>2</td><td>读数据</td><td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td></tr><tr><td>3</td><td>写数据</td><td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td></tr></tbody></table><h3><span id="ext拓展单元">EXT（拓展单元）</span></h3><p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>Imm_16</td><td>I</td><td>16</td><td>16位立即数输入信号</td></tr><tr><td>UnsignedExt</td><td>I</td><td>1</td><td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td></tr><tr><td>Imm_32</td><td>O</td><td>32</td><td>32位立即数输出信号</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>符号拓展</td><td>将16位立即数进行符号拓展</td></tr></tbody></table><h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3><table><thead><tr><th>ALUOp</th><th>指令</th><th>Opcode</th><th>Op</th></tr></thead><tbody><tr><td>加法</td><td>add</td><td>0000</td><td>ALURes = SrcA+SrcB</td></tr><tr><td>减法</td><td>sub</td><td>0001</td><td>ALURes = SrcA-SrcB</td></tr><tr><td>乘法(low)</td><td>mul</td><td>0010</td><td>ALURes = SrcA*SrcB</td></tr><tr><td>除法(商)</td><td>div</td><td>0011</td><td>ALURes = SrcA / SrcB</td></tr><tr><td>与运算</td><td>and</td><td>0100</td><td>ALURes = SrcA &amp; SrcB</td></tr><tr><td>或运算</td><td>or</td><td>0101</td><td>ALURes = SrcA | SrcB</td></tr><tr><td>异或运算</td><td>xor</td><td>0110</td><td>ALURes = SrcA $\oplus$ SrcB</td></tr><tr><td>或非运算</td><td>nor</td><td>0111</td><td>ALURes = ~(SrcA | SrcB)</td></tr><tr><td>逻辑左移</td><td>sll</td><td>1000</td><td>ALURes = SrcA &lt;&lt; Shift</td></tr><tr><td>逻辑右移</td><td>srl</td><td>1001</td><td>ALURes = SrcA &gt;&gt; Shift</td></tr><tr><td>算数右移</td><td>sra</td><td>1010</td><td>ALURes = SrcA &gt;&gt; Shift</td></tr><tr><td>相等</td><td>equal</td><td>1011</td><td>ALURes = (SrcA == SrcB) ? 1 : 0</td></tr><tr><td>有符号小于</td><td>signed_less</td><td>1100</td><td>ALURes = (SrcA &lt; SrcB) ? 1 : 0</td></tr><tr><td>无符号小于</td><td>unsigned_less</td><td>1101</td><td>ALURes = (u_SrcA &lt; u_SrcB) ? 1 : 0</td></tr><tr><td>有符号大于</td><td>signed_bigger</td><td>1110</td><td>ALURes = (SrcA &gt; SrcB) ? 1 : 0</td></tr><tr><td>无符号大于</td><td>unsigned_bigger</td><td>1111</td><td>ALURes = (u_SrcA &gt; u_SrcB) ? 1 : 0</td></tr></tbody></table><h3><span id="dm数据存储器">DM（数据存储器）</span></h3><ul><li><strong>端口定义</strong></li></ul><table><thead><tr><th>信号名</th><th>方向</th><th>位宽</th><th>描述</th></tr></thead><tbody><tr><td>CLK</td><td>I</td><td>1</td><td>时钟信号</td></tr><tr><td>Addr</td><td>I</td><td>32</td><td>内存中的地址信号</td></tr><tr><td>WE</td><td>I</td><td>1</td><td>写使能信号<br>1：写入有效<br>0：写入无效</td></tr><tr><td>WD</td><td>I</td><td>32</td><td>在写入信号有效时，写入内存地址的数据</td></tr><tr><td>RD</td><td>O</td><td>32</td><td>输出内存中对应地址的数据</td></tr></tbody></table><ul><li><strong>功能定义</strong></li></ul><table><thead><tr><th>序号</th><th>功能名称</th><th>功能描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h2><span id="控制">控制</span></h2><h3><span id="cu">CU</span></h3><table><thead><tr><th>指令</th><th>Opcode[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>lw</td><td>100011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>sw</td><td>101011</td><td>base</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>offset</td><td>~</td><td>~</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>~</td><td>~</td></tr><tr><td>nop</td><td>000000</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p><p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p><p>其次从CU的角度开始处理指令。</p><p>第一步，<strong>输入信号</strong>。</p><p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p><p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p><p>然后利用<code>Or Logical</code>，来激活相应的接口。</p><p>第二步，对于<strong>lw指令</strong>。</p><p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165310365.png" alt="image-20240221165310365"></p><p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p><p>第三步，对于<strong>sw信号</strong>。</p><p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165317549.png" alt="image-20240221165317549"></p><p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p><p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p><h2><span id="自动化测试">自动化测试</span></h2><h2><span id="思考题">思考题</span></h2><ul><li><p>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p><blockquote><p>状态存储交给寄存器来搞定，包括IFU里面的指令寄存器和GRF里面的32个寄存器。其他的期间几乎都是在完成状态转移功能。</p></blockquote></li><li><p>现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p><blockquote><p>合理的，正确的，中肯定，毋庸置疑的</p></blockquote></li><li><p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p><blockquote><p>如果非要说的，或许可以实现一个分线器Splitter？将各部分信号传出来的一个元件，当然这几个就可以实现一个基本的mips单周期cpu</p></blockquote></li><li><p>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p><blockquote><p>等价于sll 0位，或者认为是不进行任何操作处理。</p></blockquote></li><li><p>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p><blockquote><p>强度不行。指令并有覆盖到所有可能的情况，包括使用到的寄存器，是否考虑溢出情况等。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高代期末</title>
      <link href="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/"/>
      <url>/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<h1><span id="线代期末串讲">线代期末串讲</span></h1><blockquote><p><a href="https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C">https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C</a><br>文件夹名：高代期末串讲<br>有效期限：永久有效</p></blockquote><p>资料如上</p><span id="more"></span><blockquote><p>2023 12.31 <a href="hugohealthy.top">胡健</a></p></blockquote><p>线性代数这门课程的切入点有很多，这里从知识层面上划分出来了线性方程组和向量组，线性空间，矩阵与行列式这三大部分。同时，会讲到几个重要的定理和公式。</p><h2><span id="线性方程组和向量组">线性方程组和向量组</span></h2><ul><li>线性方程组</li></ul><p>齐次解和非齐次解的讨论<br>$$<br>AX=O\<br>AX=\beta<br>$$<br>齐次：有唯一解，有无穷多组解</p><p>非齐次：无解，有唯一解，有无穷多组解<br>$$<br>有解\iff r(A)=r(A|\beta)<br>$$<br><strong>可拓展到矩阵方程的解的情况</strong></p><p>通解问题<br>$$<br>\begin{align}<br>&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p\<br>&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p + X_1<br>\end{align}<br>$$</p><ul><li>向量组</li></ul><p>(列向量组)<br>$$<br>\alpha_i\in R^n,{\alpha_1\dots \alpha_p}<br>$$<br>线性相关与线性无关的含义<br>$$<br>\begin{align}<br>&amp;存在不全为0的k_1\dots k_p,k_1\alpha_1 +\dots k_p\alpha_p = 0\Rightarrow线性相关\<br>&amp;k_1\alpha_1 +\dots k_p\alpha_p = 0\rightarrow k_1\dots k_p = 0\Rightarrow线性无关<br>\end{align}<br>$$</p><ul><li>极大线性无关与秩</li></ul><p>极大线性无关组指的是：<br>$$<br>\alpha_1\dots\alpha_m线性无关，且加上向量组中任一向量\alpha后线性相关<br>$$<br>向量组的秩的含义是极大线性无关组中向量的个数</p><ul><li>向量组的等价</li></ul><p>一个向量组A中的每一个向量可以用另一个向量组B来线性表示，称向量组A能由向量组B线性表示</p><p>向量组的等价指的是可以相互线性表示</p><ul><li><p>向量组的一些性质</p></li><li><p>相关的线性表示（及其逆，单边法则）</p></li></ul><blockquote><p>由线性相关的定义可推出，其中某个向量可以由其余向量线性表示，这又可推出其中的某个向量可以写成前面的向量的线性组合。<br>所以我们逆过来看，线性无关，等价于<br>$每一个向量都不可由前面的向量表示（\alpha_i = 0） $<br>这我们叫做单边法则</p></blockquote><ul><li>大数法则/不大法则</li></ul><blockquote><p>我们先来看，一个向量组被另一个向量组表示被表示的意义。<br>$S_1组被S_2组表示\Leftrightarrow \forall \alpha_i \in S_1 , \alpha_i 可以被 \beta_j \in S_2 表示 $<br>大的向量组可以被小的向量组表示，大组必相关<br>（逆否命题：若A组无关，但可以被B组表示，则A比B小 ——不大法则）<br>为啥可以被表示，我们可以理解了后面的秩再来说，是不是说AX=B有解啊。</p></blockquote><ul><li>表示的传递性</li></ul><blockquote><p>$我们说S_2 能被S_1表示，S_1能被S_0表示，则S_2能被S_0表示$</p></blockquote><ul><li>唯一表示法则</li></ul><blockquote><p>${\alpha_1,……,\alpha_n}无关,{\alpha_1,……,\alpha_n,\beta}相关，则\beta 由{\alpha_1,……,\alpha_n}唯一表示 $</p></blockquote><ul><li>子组相关法则</li></ul><blockquote><p>子组相关，全组必定相关<br>proof:<br>$k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p = 0 (k_1,……,k_p不全为零) $<br>$\therefore k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p + 0\alpha_{p+1} + …… + 0\alpha_n  = 0$</p></blockquote><ul><li>等数法则</li></ul><blockquote><p>${\alpha_1,……\alpha_p},{\beta_1,……\beta_q}两组无关，且能相互表示，则p=q $<br>由不大法则可证</p></blockquote><ul><li>长短法则</li></ul><blockquote><p>长相关则短相关，短无关则长无关<br>看具体怎么理解了，有的老师说“如果矩阵A的子矩阵A0的各行（列）线性无关，则由A0的这些行（列）扩充得到的A的行（列）线性无关。”<br>这是从大到小，从矩阵看问题<br>也可以这么理解（从小到大，从向量组）</p></blockquote><ul><li>行变再行变，列的关系不改变</li></ul><h2><span id="空间解空间内积空间">空间(解空间，内积空间)</span></h2><p>解空间(初次接触)</p><p>张成空间(你已经会很多了)</p><p>欧式空间(你会的差不多了)</p><p>线性空间(你会了！！)</p><ul><li>定义</li></ul><p>满足八条性质，其实就是满足封闭性和线性性</p><ul><li>生成空间的定义</li></ul><p>由向量组表示的所有向量的集合<br>$$<br>\begin{align}<br>&amp;\alpha_1\dots\alpha_m\<br>&amp;L={\lambda_1\alpha_1 \dots \lambda_m\alpha_m|\lambda_1\dots\lambda_m\in R}<br>\end{align}<br>$$</p><ul><li>解空间的理解</li></ul><p>定义：n元齐次线性方程组的解集是n维向量空间$F^n$的非空子集(易证满足封闭性和线性性)</p><p>生成空间角度：基础解的张成空间</p><p>矩阵内积的理解：<br>$$<br>(\alpha_1,\dots,\alpha_m)<br>\begin{pmatrix}<br>x_1\<br>\vdots\<br>x_m<br>\end{pmatrix}\<br>AX<br>$$</p><blockquote><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230223324226.png" alt></p></blockquote><ul><li>空间的交与和（还有<strong>直和</strong>和<strong>并</strong>，应该不考）</li></ul><p>how to solve？</p><p>$V_1:\alpha_1\dots \alpha_p,V_2:\beta_1\dots\beta_q$</p><p>空间的交：<br>$$<br>\begin{align}<br>&amp;\gamma = s_1\alpha_1+\dots s_p\alpha_p = t_1\beta_1+\dots t_q\beta_q\<br>&amp;解出来后得到s_1\dots s_p\<br>&amp;带入后易得<br>\end{align}<br>$$<br>空间的和：<br>$$<br>\begin{align}<br>&amp;{\alpha_1\dots\alpha_p,\beta_1\dots\beta_q}这个向量组的极大线性无关组\<br>&amp;和空间的维数即为极大线性无关组的秩<br>\end{align}<br>$$<br>维数公式<br>$$<br>\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim (W_1\cap W_2)<br>$$<br>其中$W_1+W_2={w_1+w_2:w_1\in W_1,w_2\in W_2}$</p><ul><li>内积与Gram矩阵</li></ul><p>$$<br>\begin{align}<br>&amp;A={\alpha_1\dots\alpha_n}\<br>&amp;Gram=<br>\begin{pmatrix}<br>(\alpha_1,\alpha_1)&amp;\dots &amp;(\alpha_1,\alpha_n)\<br>\vdots &amp;  &amp;\vdots\<br>(\alpha_n,\alpha_1) &amp;\dots &amp;(\alpha_n,\alpha_n)<br>\end{pmatrix}\<br>&amp;Gram=A^TA<br>\end{align}<br>$$</p><p>定义预正交阵和正交阵</p><p>预正交阵：列向量两两正交</p><p>正交阵：两向量两两正交且每个列向量的模为1</p><p>度量阵：由基向量产生的Gram矩阵，特殊情况下是单位阵</p><p>二次型<br>$$<br>\begin{align}<br>&amp;f=\sum_{i=1}^n\sum_{j=1}^na_{ij}x_ix_j\<br>&amp;二次型对应的矩阵为：\<br>&amp;\begin{pmatrix}<br>a_{11}&amp;\dots &amp;a_{1n}\<br>\vdots &amp;  &amp;\vdots\<br>a_{n1} &amp;\dots &amp;a_{nn}<br>\end{pmatrix}\<br>&amp;a_{ij}=a_{ji}<br>\end{align}<br>$$</p><ul><li>线性映射和线性变换</li></ul><p>线性映射：$R^n\rightarrow R^m$</p><p>线性变换：$R^n\rightarrow R^n$</p><blockquote><p>这个概念挺抽象的</p><p>不同书定义也不一样(点名批评同济大学的紫书)</p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230234949295.png" alt></p><p>这里以《矩阵论》上面的定义为准</p></blockquote><ul><li><p>过渡矩阵与坐标变换公式</p><p>若两组基$ S=\begin{bmatrix}{\varepsilon_1,\cdots,\varepsilon_n}\end{bmatrix}, T=\begin{bmatrix}{\eta_1,\dots,\eta_n}\end{bmatrix}$满足基变换公式$ T= S P$，则称$ P$是从$\S$到$ T$的过渡矩阵。</p><p>设向量$\alpha$在$ S, T$下的坐标分别为$ X, Y$，则满足坐标变换公式$ X= P Y$。</p></li><li><p>线性变换矩阵</p><p>对于一组基$\xi_1,\dots,\xi_n$，若存在矩阵$A$使得线性变换$\sigma$满足$\sigma(\xi_1,\dots,\xi_n)=(\xi_1,\dots,\xi_n) A$，则称矩阵$ A$为线性变换$\sigma$在基$\xi_1,\dots,\xi_n$下所对应的矩阵。</p><p>若线性空间$V$的线性变换$\sigma$在两组基$\xi_1,\dots,\xi_n$以及$\eta_1,\dots,\eta_n$下对应的矩阵分别为$ A, B$，$\xi_1,\dots,\xi_n$到$\eta_1,\dots,\eta_n$的过渡矩阵为$ P$，则有$ B= P^{-1} A P$。</p></li></ul><blockquote><p>虽然这个也有点抽象，但是整理了一下也就这几个公式</p><p>理解不了就记住吧</p></blockquote><h2><span id="矩阵与行列式">矩阵与行列式</span></h2><ul><li>矩阵的可逆与正交</li></ul><p>$$<br>\begin{align}<br>&amp;A=A_{n\times n}\<br>&amp;r(A)=n\<br>\iff&amp;行满秩\<br>\iff&amp;列满秩\<br>\iff&amp;A^{-1}存在\<br>\iff&amp;|A|\ne 0\<br>\iff&amp;\lambda_i\ne 0|A|=\lambda_1\dots\lambda_n\<br>\end{align}<br>$$</p><p>正交：$A^T=A^{-1}$或者$A^TA^{-1}=A^{-1}A^T=I_n$</p><ul><li>矩阵的秩</li></ul><p>行秩：行向量组的秩</p><p>列秩：列向量组的秩</p><p>阶梯秩：化为阶梯阵后非零行的个数</p><p>古典秩：存在k阶子式的行列式不为0，任意k+1阶子式的行列式都为0</p><blockquote><p>这四个是等价的</p></blockquote><ul><li>行列式的计算</li></ul><blockquote><p>这个我感觉高阶的也不会让你算</p><p>低阶的直接爆算或者化为上三角行列式</p></blockquote><p>范德蒙德行列式</p><p><strong>下降公式/换位公式</strong></p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5C3%E6%8D%A2%E4%BD%8D%E5%85%AC%E5%BC%8F%E4%BE%8B%E9%A2%98.png" alt="换位公式例题"></p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004939668.png" alt></p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004927501.png" alt></p><ul><li>相伴秩公式</li></ul><p>$$<br>A=A_{n\times n}\<br>A^*=<br>\begin{pmatrix}<br>A_{11} &amp;A_{21}&amp;\dots &amp;A_{n1}\<br>\vdots &amp;&amp;&amp;\vdots\<br>A_{1n} &amp;A_{2n}&amp;\dots &amp;A_{nn}<br>\end{pmatrix}<br>$$</p><p>注意这里还转置了一下</p><p>$AA^*=|A|I_n$</p><p>可得$|A^*| = |A|^{n-1}$</p><p>和伴随矩阵有关的秩的公式<br>$$<br>r(A^*) =<br>\begin{cases}<br>n,r(A) = n\<br>1,r(A)=n-1\<br>0,else<br>\end{cases}<br>$$</p><blockquote><p>proof:由古典秩的含义</p><p>第二个用到$AA^<em>=O 有r(A)+r(A^</em>) \le n $</p><p>且$r(A^*) \ge 1$</p></blockquote><h2><span id="特征值与二次型">特征值与二次型</span></h2><ul><li>根的遗传公式</li></ul><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010720537.png" alt></p><blockquote><p>零化式</p></blockquote><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010812719.png" alt></p><blockquote><p>theory</p></blockquote><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011008818.png" alt></p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011031258.png" alt></p><ul><li>Cayley定理</li></ul><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011404990.png" alt></p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011426721.png" alt></p><ul><li>许尔公式</li><li>相似对角化</li></ul><p>可对角化</p><ol><li>n阶矩阵A与对角阵相似（即A能对角化）的充分必要条件是A有n个线性无关的特征向量。</li><li>如果n阶矩阵A的n个特征值互不相等，则A与对角阵相似。</li><li>对称阵的特征值为实数</li><li>不同特征根的特征向量正交</li></ol><p>对称阵A对角化的步骤</p><ol><li><p>求出A的全部互不相等的特征值$\lambda_1,\dots \lambda_s$，它们的重数依次为$k_1,\dots k_s(k_1+\dots +k_s = n)$。</p></li><li><p>对每个$k_i$重特征值$\lambda_i$，求方程$(A-\lambda_i I)X=O$的基础解系，得$k_i$个线性无关的特征向量。再把它们<strong>正交化</strong>、单位化，得ki个两两正交的单位特征向量。因$k_1+\dots +k_s=n$，故总共可得n个两两正交的单位特征向量。</p></li></ol><p>$Schimidt$正交化方法</p><p>若有$n$个线性无关的向量$\alpha_1,\dots,\alpha_n$，则过程分为正交化和单位化</p><p>正交化过程<br>$$<br>\beta_k=\alpha_k-\sum_{i=1}^{k-1}\frac{(\beta_i,\alpha_k)}{(\beta_i,\beta_i)}\beta_i,\quad k=1,\dots,n<br>$$<br>单位化过程<br>$$<br>\eta_k=\frac{\beta_k}{||\beta_k||},\quad k=1,\dots,n<br>$$<br>从而得到一组单位正交向量$\eta_1\cdots,\eta_n$。</p><ol start="3"><li>把这n个两两正交的单位特征向量构成正交阵P，便有$P^{-1}AP = P^TAP = Λ$。注意Λ中对角元的排列次序应与P中列向量的排列次序相对应。</li></ol><ul><li>实对称阵的性质</li></ul><p>实对称矩阵的正交相似对角化</p><p>（1）实对称矩阵的特征值均为实数；</p><p>（2）实对称矩阵对应不同特征值的特征向量相互正交；</p><p>（3）实对称矩阵必定可以相似对角化；</p><p>（4）若$ A$是$n$阶实对称矩阵，且特征值为$\lambda_1,\cdots,\lambda_n$，则存在正交矩阵$ Q$，使得<br>$$<br>Q^T A Q=\begin{bmatrix}\lambda_1&amp;&amp;\&amp;\ddots\&amp;&amp;\lambda_n\end{bmatrix}<br>$$<br>（5）若$ A$和$ B$均为$n$阶实对称矩阵，则$ A$和$ B$相似的充要条件是$ A$和$ B$有相同的特征值。</p><ul><li>二次型与六二条件</li></ul><p>正定矩阵：</p><p>（1）$ A$所有特征值均为正;</p><p>（2）$ A$正惯性指数为$n$；</p><p>（3）$ A$与单位阵合同；</p><p>（4）$ A$的各阶顺序主子式大于零；</p><p>（5）存在可逆矩阵$ P$使得$ A= P^T P$。</p><p>（6）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&gt;0$</p><p>负定矩阵：</p><p>（1）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&lt;0$</p><p>（2）$ A$的奇数阶主子式为负，偶数阶主子式为正；</p><ul><li>双合同定理</li></ul><p>若$A,B$同阶实对称，其中一个为正定，可设$A$正定，存在可逆$W$,$W^TAW=I_n，W^TBW=diag(d_1,\dots,d_n)$,即$W^TAW,W^TBW$都为对角形</p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231015741579.png" alt="image-20231231015741579"></p><p><a href="https://zhuanlan.zhihu.com/p/376561675">more</a></p><h2><span id="一些典型的整理">一些典型的整理</span></h2><ul><li>秩公式</li></ul><p>阶梯阵概念，及其与向量组秩的联系。</p><blockquote><p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>所以三种同解变形，其实就代表着三种初等变换。</p></blockquote><p>秩一阵</p><blockquote><p>我们来看一个矩阵，秩一阵，可分解为两个向量之间的乘积。</p></blockquote><p>我们在最后再来谈秩的各种公式的关系</p><blockquote><ul><li>满秩则有唯一解<br>$proof: \because r(A) = n $<br>$\therefore {\alpha_1,……,\alpha_n}可作为一组基 $<br>$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>$坐标即为唯一解 $</li><li>满秩则可逆<br>$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li></ul></blockquote><p>所以说到这就只需要明确一个事情，满秩，行向量组列向量组无关，行列式不等于0，可逆，只有唯一解，非奇异这都是等价的概念</p><blockquote><p>分块秩公式</p></blockquote><p>$$<br>r\begin{pmatrix}<br>A &amp;O\<br>O &amp;B<br>\end{pmatrix}=r(A)+a(B)\<br>r\begin{pmatrix}<br>O &amp;B\<br>A &amp;O<br>\end{pmatrix}=r(A)+a(B)\<br>r\begin{pmatrix}<br>A &amp;C\<br>O &amp;B<br>\end{pmatrix}\ge r(A)+a(B)\<br>$$</p><blockquote><p>乘积不增秩公式</p></blockquote><p>$$<br>\begin{align}<br>&amp;r(AB)\le r(A),r(B)\<br>&amp;A=A_{m\times n} = (\alpha_1,\dots,\alpha_n),B=B_{n\times p} = (\beta_1,\dots,\beta_p)\<br>&amp;AB=(A\beta_1,\dots,A\beta_p)\<br>&amp;A\beta_i=\alpha_1b_1+\dots+\alpha_nb_n,\beta_i=\begin{pmatrix}<br>b_1\b_2\\vdots\b_n<br>\end{pmatrix}\<br>&amp;AB可以被{\alpha_1,\dots,\alpha_n}表示<br>\end{align}<br>$$</p><blockquote><p>积0公式</p></blockquote><p>$$<br>\begin{align}<br>&amp;AB=O\<br>&amp;r(A)+r(B)\le n<br>\end{align}<br>$$</p><blockquote><p>转置积秩公式</p></blockquote><p>$$<br>r(A)+r(B)\le r(AB)+n<br>$$</p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231021249979.png" alt></p><blockquote><p>加减秩公式</p></blockquote><p>$$<br>\begin{align}<br>&amp;r(A+B)\le r(A)+r(B)\<br>&amp;r(A-B)\le r(A)+r(B)\<br>&amp;r(A+B)=r(A|B)r\begin{pmatrix}I_n\I_n\end{pmatrix}\le r(A|B)\le r(A)+r(B)<br>\end{align}<br>$$</p><ul><li>可逆的等价表示</li></ul><ol><li><p>$A$的行列式不等于0</p></li><li><p>$A$的秩等于$n$，即$A$为满秩矩阵</p></li><li><p>$A$的行（列）向量组线性无关</p></li><li><p>齐次方程组$Ax=0$只有零解</p></li><li><p>对于任意$b$属于$R^n$(表示向量空间)，Ax=b总有唯一解</p></li><li><p>A与单位矩阵等价</p></li><li><p>A可表示成若干个初等矩阵的乘积</p></li><li><p>A的列向量可以作为n维向量空间$R^n$的一组基</p></li><li><p>$R^n$中任意一个向量都可以由$A$的列向量线性表出</p></li><li><p>$A$的特征值全不为0</p></li><li><p>$A^TA$是正定矩阵</p></li><li><p>$A$是非奇异的</p></li></ol><ul><li>求逆的方法学</li></ul><p>初等变换（常用且方便）</p><p>伴随矩阵法</p><p>分块矩阵法</p><p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231021933921.png" alt="image-20231231021933921"></p><p>零化式法</p><ul><li>下降公式</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 高代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散2</title>
      <link href="/2023/11/24/%E7%A6%BB%E6%95%A32/"/>
      <url>/2023/11/24/%E7%A6%BB%E6%95%A32/</url>
      
        <content type="html"><![CDATA[<h1><span id="离散2">离散2</span></h1><p>这里会放上我的一些作业</p><span id="more"></span><h2><span id="作业5">作业5</span></h2><ol><li></li></ol><p>$$<br>\begin{align}<br>&amp;(1)不是\<br>&amp;A = {1, 2, 3}\<br>&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;1,2&gt;,&lt;2,1&gt;, &lt;1,3&gt;,&lt;3,1&gt;,&lt;2,3&gt;,&lt;3,2&gt;}\<br>&amp;R_2 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;1,2&gt;,&lt;2,1&gt;}\<br>&amp;则r(R_1 - R_2) = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;2,3&gt;,&lt;3,2&gt;,&lt;1,3&gt;,&lt;3,1&gt;}\<br>&amp;而有&lt;1,3&gt;,&lt;3,2&gt;\in r(R_1 - R_2) 但是&lt;1,2&gt; \notin r(R_1 - R_2),故r(R_1-R_2)不是传递的，因而不是等价关系\<br>&amp;(2)不是\<br>&amp; 上课已经讲过，R_1 , R_2是对称时，R_1 \circ R_2 不一定对称\<br>&amp; 比如取A = {1, 2, 3}\<br>&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;,&lt;1,2&gt;,&lt;2,1&gt;,}\<br>&amp;R_2 = {&lt;2,2&gt;, &lt;3,3&gt;, &lt;2,3&gt;,&lt;3,2&gt;}\<br>&amp;则R_1\circ R_2 = {&lt;2,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;,&lt;1,2&gt;}显然不是等价关系\<br>&amp;(3)是\<br>&amp;R_1,R_2都是等价关系，那么都是自反，对称，传递的\<br>&amp;就有R_1\cup R_2是自反的，对称的\<br>&amp;同时如果R_1 \cup R_2 是自反的，对称的，那么t(R_1,R_2)仍然是自反、对称的，同时还是传递的\<br>&amp;由等价关系的定义可知t(R_1, R_2)是等价关系<br>\end{align}<br>$$</p><ol start="2"><li></li></ol><p>$$<br>\begin{align}<br>&amp;(a)\<br>&amp;左到右:\<br>&amp;S_1 \in A/R1,则\forall s_1 \in S_1\<br>&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>&amp;又R_1\subseteq R_2,及&lt;x,y&gt; \in R_1 有&lt;x,y&gt; \in R_2，即xR_2y\<br>&amp;故s_1 \in S_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y}\<br>&amp;即S_1 \subseteq S_2,由加细的定义有A/R_1 \le A/R_2\<br>&amp;右到左:\<br>&amp;A/R_1 \le A/R_2\<br>&amp;有\forall S_1 \in A/R_1 , \exist S_2 \in A/R_2 , s.t. S_1 \subseteq S_2\<br>&amp;\forall s_1 \in S_1\<br>&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>&amp;故\exist s_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y},s_1 \subseteq s_2 \<br>&amp;即\forall xR_1y,有xR_2y,即R_1 \subseteq R_2\<br>&amp;综上即可得证\<br>&amp;(b)\<br>&amp;左到右:\<br>&amp;R_1 \subset R_2 必然有R_1 \subseteq R_2，则A/R_1 \le A/R_2\<br>&amp;又R_1\ne R_2,即\exist &lt;x_0,y&gt; \in R_2,&lt;x_0,y&gt;\notin R_1\<br>&amp;取s_2 = [x_0]<em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2 \in S_2，其中S_2 \in A/R_2\<br>&amp;且由于&lt;x_0,y&gt;\notin R_1 ,s_2 \notin S_1,故S_1 \ne S_2,其中S_1 \in A/R_1\<br>&amp;即A/R_1 \ne A/R_2\<br>&amp;右到左:\<br>&amp;A/R_1 \subset A/R_2,则同样易有R_1\subseteq R_2\<br>&amp;A/R_1 \ne A/R_2\<br>&amp;则存在S_2 \in A/R_2,找不到S_1 \in A/R_1,s.t. S_2 \subseteq S_1,\<br>&amp;同样取s_2 = [x_0]</em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2\in S_2，且s_2 \notin S_1\<br>&amp;即\exist &lt;x_0,y_0&gt;,s.t. x_0R_2y_0,x_0\overline{R_1}y_0\<br>&amp;即R_1 \ne R_2\<br>&amp;故R_1 \subset R_2\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><ol start="3"><li></li></ol><p>$$<br>\begin{align}<br>&amp;看法不对,证明就不可能对了嘛。\<br>&amp;若R是非空集合A的空关系，由于前件为0，R是对称和传递的，但是\forall x \in A, &lt;x,x&gt;\notin R\<br>&amp;R不是自反的\<br>&amp;故即可完成论证\<br>\end{align}<br>$$</p><ol start="4"><li></li></ol><p>$$<br>\begin{align}<br>&amp;必要性:\<br>&amp;(显然bushi)R是等价关系，且&lt;a,b&gt;\in R,&lt;a,c&gt; \in R\<br>&amp;由于R是对称的，有&lt;b,a&gt;\in R\<br>&amp;由于R是传递的，有&lt;b,c&gt;\in R\<br>&amp;必要性即证\<br>&amp;充分性:\<br>&amp;若&lt;a,b&gt;\in R,&lt;a,c&gt;\in R,则&lt;b,c&gt;\in R\<br>&amp;同时R是自反的\<br>&amp;\forall &lt;a,b&gt;\in R, 且由自反性有&lt;a,a&gt; \in R \<br>&amp;由条件可得，&lt;b,a&gt; \in R，故R是对称的\<br>&amp;\forall &lt;a,b&gt; \in R , &lt;b,c&gt; \in R\<br>&amp;证明了对称性，有&lt;b,a&gt;\in R,则结合条件可得\<br>&amp;&lt;a,c&gt;\in R，故R是传递的\<br>&amp;由等价关系的定义可知R是等价关系\<br>&amp;充分性得证\<br>&amp;综上即可得证\<br>\end{align}<br>$$</p><ol start="5"><li></li></ol><p>$$<br>\begin{align}<br>&amp;必要性:\<br>&amp;(也挺显然的)&lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>&amp;则由传递性，&lt;x,z&gt;\in R\<br>&amp;再由对称性，&lt;z,x&gt;\in R\<br>&amp;必要性即证\<br>&amp;充分性:\<br>&amp;R是自反的，且R是循环的\<br>&amp;\forall &lt;x,y&gt; \in R, 由自反性&lt;y,y&gt;\in R\<br>&amp;再有循环性，有&lt;y,x&gt;\in R，即R是对称的\<br>&amp;\forall &lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>&amp;由循环性,&lt;z,x&gt;\in R,又已经证明R是对称的\<br>&amp;则有&lt;x,z&gt;\in R，故R是传递的\<br>&amp;必要性得证\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><h2><span id="作业六">作业六</span></h2><ol><li></li></ol><p>$$<br>\begin{align}<br>&amp;(1)能够\<br>&amp;dom = {1,2,3,4}\<br>&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;1,4&gt;}\<br>&amp;(2)能够\<br>&amp;dom = {1,2,3}\<br>&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;3,2&gt;}\<br>&amp;(3)不能够\<br>&amp;(4)能够\<br>&amp;dom = {1,2,3}\<br>&amp;ran = {&lt;2,3&gt;}\<br>\end{align}<br>$$</p><ol start="2"><li></li></ol><p>$$<br>\begin{align}<br>&amp; (1)\forall y \in f[A] - f[B]\<br>&amp;\Rightarrow y \in f[A] \wedge y \notin f[B]\<br>&amp;\exist x\in A \quad s.t. \quad y = f(x)\<br>&amp;若x\in B,则与y\notin f[B]矛盾,故x\in A - B\<br>&amp;即y \in f[A- B]\<br>&amp;反例:\<br>&amp;X= {1,2},Y = {0}\<br>&amp;f = {&lt;1,0&gt;,&lt;2,0&gt;}\<br>&amp;A = {1,2}, B = {1}\<br>&amp;此时f[A] = {0},f[B] = {0},f[A] - f[B] = \varnothing\<br>&amp;f[A-B] = {0}，等号不成立\<br>&amp;(2)\forall x \in f^{-1}[C-D]\<br>&amp;\exist y \in C- D , y = f(x)\<br>&amp;\Rightarrow y\in C\wedge y\notin D\<br>&amp;\Rightarrow x\in f^{-1}[C] \wedge x \notin f^{-1}[D]\<br>&amp;\Rightarrow x \in f^{-1}[C]-f^{-1}[D]\<br>&amp;因此有f^{-1}[C-D]\subseteq f^{-1}[C]-f^{-1}[D]\<br>&amp;\forall x \in f^{-1}[C]-f^{-1}[D]\<br>&amp;\exist y \in C ,y = f(x)\<br>&amp;若y\in D,则x\in f^{-1}[D],矛盾，因此y\notin D\<br>&amp;\Rightarrow y\in C-D\<br>&amp;即x \in f^{-1}[C-D]\<br>&amp;因此有f^{-1}[C]-f^{-a}[D] \subseteq f^{-a}[C-D]\<br>&amp;故综上有f^{-1}[C-D] = f^{-1}[C]- f^{-1}[D]\<br>\end{align}<br>$$</p><ol start="3"><li></li></ol><p>$$<br>\begin{align}<br>&amp;单射：(1),(2)\<br>&amp;满射：(2),(3)\<br>&amp;双射：(2)\<br>\end{align}<br>$$</p><h2><span id="作业七">作业七</span></h2><ol><li></li></ol><p>$$<br>\begin{align}<br>&amp;由上课讲的定理显然可得：\<br>&amp;(定理如下，课上证明了，课下就不证了了吧)\<br>&amp;f:X ⟶ Y 和 g: Y ⟶ Z，则\<br>&amp;(1) 若 f 和 g 都是满射，则 g\circ ƒ 也是满射\<br>&amp;(2) 若 f 和 g 都是单射，则 g\circ ƒ 也是单射\<br>&amp;(3) 若 f 和 g 都是双射，则 g\circ ƒ 也是双射\<br>&amp;用数学归纳法显然可证\<br>&amp;n = 1时，结论成立 \<br>&amp;若n时结论成立，则n+1时\<br>&amp;f^{n+1} = f^n \circ f\<br>&amp;f^n和f都是满射，单射或双射，则f^{n+1}时满射，单射或双射\<br>&amp;由数学归纳法即可得证<br>\end{align}<br>$$</p><ol start="2"><li></li></ol><p>$$<br>\begin{align}<br>&amp;(1)g\circ f为满射，g为单射\<br>&amp;则ran(g\circ f) = Z\<br>&amp;且由课上结论,g为满射，故g为1-1映射\<br>&amp;dom(g) = Y,g^{-1}[Z] = Y \<br>&amp;又g[ran(f)] = Z\<br>&amp;即ran(f) = Y\<br>&amp;故f为满射\<br>&amp;综上即可得证\<br>&amp;(2)g\circ f为单射,f为满射\<br>&amp;且由课上结论，f为单射，故f为1-1映射\<br>&amp;\forall y_1 ,y_2\in Y,且y_1 \ne y_2\<br>&amp;由于f为1-1映射,故存在唯一x_1,x_2,s.t.y_1 = f(x_1),y_2 = f(x_2)\<br>&amp;若x_1 = x_2 ,则显然y_1 = y_2，故有x_1 \ne x_2\<br>&amp;则g\circ f(x_1) = g(y_1)  = z_1,g\circ f(x_2) = g(y_2) = z_2\<br>&amp;由g\circ f为单射,故z_1\ne z_2\<br>&amp;故可得g也为单射\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><ol start="3"><li></li></ol><p>$$<br>\begin{align}<br>&amp;dom(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>&amp;ran(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>&amp;dom(h\circ g) = {x | x\in \R}\<br>&amp;ran(h\circ g) = {x | x\in \R_+ | x = 0}\<br>&amp;dom(g\circ h) = {x|x \in \R_+ | x = 0}\<br>&amp;ran(g\circ h) = {x|x \in \R_+ | x = 0}\</p><p>\end{align}<br>$$</p><h2><span id="作业7">作业7</span></h2><ol><li></li></ol><p>$$<br>\begin{align}<br>&amp;左推右\<br>&amp;显然!!f可逆等价于f有唯一的左逆和右逆\<br>&amp;右推左\<br>&amp;若f有唯一的左逆(右逆证明类似)\<br>&amp;那么可以推出f是单射\<br>&amp;需要证明f是可逆的，那么只需要证明f是右可逆的\<br>&amp;这里采用反证法，假设f不是右可逆的，那么等价于f不是满射\<br>&amp;设A中至少有的两个元素为a_1, a_2,由于f是单射\<br>&amp;设f(a_1) = b_1, f(a_2) = b_2,且有b_1 \ne b_2，同时由于不是满射\<br>&amp;B中至少存在一个元素，设为b_3,A中没有元素映射到b_3\<br>&amp;接下来我们构造g_1,g_2,使得g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2\<br>&amp;g_1(x) = \begin{cases}<br>a_i, &amp; if, x = b_i,i=1,2\<br>a_1, &amp; if, x = b_3\<br>f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>\end{cases}\<br>&amp;g_2(x) = \begin{cases}<br>a_i, &amp; if, x = b_i,i=1,2\<br>a_2, &amp; if, x = b_3\<br>f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>\end{cases}\<br>&amp;那么就有g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2成立，与f有唯一的左逆矛盾\<br>&amp;故有上面的反证法可以得到f是右可逆的，那么f是可逆，即可得证\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><ol start="2"><li></li></ol><p>$$<br>\begin{align}<br>(1)&amp;f是左可逆，右可逆，可逆的\<br>&amp;显然f是单射，满射，因此是可逆的。同时求出f的逆即为f的左逆和右逆\<br>&amp;构造g(x) = \begin{cases}<br>4,&amp; if, x= 0\<br>x-1,&amp; if, x = 1,2,3,4\<br>x,&amp; if, x &gt; 5<br>\end{cases}\<br>&amp;可以验证f\circ g = I_N, g\circ f = I_N\<br>&amp;即为所求\<br>(2)&amp;f是右可逆，不是左可逆，不是可逆\<br>&amp;由于f(1)  = f(3) =  3,因此f不是单射，f不是左可逆\<br>&amp;f是满射，\forall x \in N,\exist f(2x) = x,2x \in N;<br>&amp;下面构造f的右逆g\<br>&amp;g(x) = 2x, x \in N;即为右逆之一<br>\end{align}<br>$$</p><ol start="3"><li></li></ol><p>$$<br>\begin{align}<br>&amp;\chi_{A-B\cap C}\<br>&amp;= \chi_A - \chi_A <em>\chi_{B\cap C}\<br>&amp;= \chi_A - \chi_A</em>\chi_B*\chi_C\<br>&amp;\chi_{(A-B)\cup (A-C)}\<br>&amp;=\chi_{A-B} + \chi_{A-C}-\chi_{A-B}<em>\chi_{A-C}\<br>&amp;=\chi_A-\chi_A</em>\chi_B+\chi_A-\chi_A*\chi_C - (\chi_A-\chi_A*\chi_B)<em>(\chi_A-\chi_A</em>\chi_C)\<br>&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_A*\chi_C-\chi_A*\chi_B*\chi_A+\chi_A*\chi_B*\chi_A*\chi_C)\<br>&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_C-\chi_A*\chi_B+\chi_A*\chi_B*\chi_C)\<br>&amp;=\chi_A - \chi_A*\chi_B*\chi_C\<br>&amp;于是显然有\chi_{A-B\cap C} = \chi_{(A-B)\cup (A-C)}\<br>&amp;于是可以证明A-B\cap C = (A-B)\cup(A-C)\<br>\end{align}<br>$$</p><ol start="4"><li></li></ol><p>$$<br>\begin{align}<br>&amp;\chi_{A\oplus B}\<br>&amp;=\chi_{A} - \chi_{A\cap B} + \chi_{B}-\chi_{A\cap B}\<br>&amp;=\chi_{A} + \chi_{B} - 2*\chi_{A}<em>\chi_{B}\<br>&amp;=0\<br>&amp;那么有\chi_{A}</em>(1-\chi_{B}) = \chi_B*(1-\chi_{A})\<br>&amp;\iff \chi_{A}<em>\chi_{\sim B} = \chi_{B}</em>\chi_{\sim A}\<br>&amp;\iff \chi_{A\cap \sim B} = \chi_{B\cap \sim A}\<br>&amp;\iff A\cap \sim B = B \cap \sim A\<br>&amp;即为所求<br>\end{align}<br>$$</p><h2><span id="作业8">作业8</span></h2><ol><li></li></ol><p>$$<br>\begin{align}<br>&amp;利用第一数学归纳法进行证明\<br>&amp;(1)由于为自然数序列，所以显然有0\le a_0\<br>&amp;(2)\forall n\ge 0,若n \le a_n,下面证明n^+\le a_{n^+}\<br>&amp;由于为单调递增序列，因此显然有a_n &lt;a_{n^+}\<br>&amp;同时为正整数序列，由于正整数是不稠密的\<br>&amp;有a_n + 1 \le a_{n^+}\<br>&amp;n^+ = n + 1 \le a_n + 1\le a_{n^+}\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><ol start="2"><li></li></ol><p>$$<br>\begin{align}<br>&amp;对于本题我们先证明如下结论:\<br>&amp;\forall i \in n, 有i \subseteq n\<br>&amp;使用第一数学归纳法进行证明\<br>&amp;(1)n = 0时显然成立。\<br>&amp;(2)\forall n \ge 0,若结论成立，即\forall i \in n, 有i\subseteq n\<br>&amp;那么对于n^+,有n^+ = {n,{n}}\<br>&amp;\forall i \in n^+, 有i = n 或者i \in n(由三歧性可得)\<br>&amp;若i = n,显然有i\subseteq n^+\<br>&amp;若i\in n,由归纳假设，i\in n\<br>&amp;又n\in n^=,则又i\in n^+\<br>&amp;故该结论得证\<br>&amp;对于本题,\forall a \in n,\forall x \in a\<br>&amp;由于可推出a \in n, 于是显然有x \in n\<br>&amp;故综上即可得证\forall n \in N 是传递的<br>\end{align}<br>$$</p><ol start="3"><li></li></ol><p>$$<br>\begin{align}<br>&amp;本题应该是想用二重归纳法做，但是太麻烦了，我就直接用构造法哈(goutou)\<br>&amp;设n = k(m+1) + t,(t &lt; m+1)\<br>&amp;由于n &gt; m 且(m+1)\nmid n\<br>&amp;可得k \ge 1, t \ne 0\<br>&amp;那么甲第一次取t个球，然后每次乙取x个球\<br>&amp;甲取(m+1-x)个球，一轮取球数维m+1，故经过k轮\<br>&amp;恰好甲取完最后的球，获胜<br>\end{align}<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 离散2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOpre</title>
      <link href="/2023/11/10/OOpre/"/>
      <url>/2023/11/10/OOpre/</url>
      
        <content type="html"><![CDATA[<h1><span id="buaa-oopre总结">BUAA-OOpre总结</span></h1><blockquote><p>即面向对象先导课程，<strong>绝世好课！！</strong>！</p></blockquote><p>所有的代码均可以前往我的<a href="https://github.com/hjzts/BUAA_OO">github</a>中获取</p><span id="more"></span><h2><span id="part1-作业背景">Part1-作业背景</span></h2><blockquote><p>一个非常经典的冒险类游戏</p></blockquote><p>你是一个穿越到魔法大陆上的冒险者，在旅途中，你需要收集各种<strong>道具</strong>（药水瓶和事物），使用各种<strong>装备</strong>，招募其他<strong>冒险者</strong>加入队伍，提升自己的<strong>等级</strong>并体验各种<strong>战斗</strong>，你可以雇佣冒险者，雇佣者会在适当的时候向你提供<strong>帮助</strong>。同时加入了商店功能，在这里可以进行各种商品的购买与出售。</p><h2><span id="part2-架构设计">Part2-架构设计</span></h2><h3><span id="最终的架构设计">最终的架构设计</span></h3><p>从<code>Main</code>类出发。</p><ul><li>对于IO，首先对于输入使用<code>MyScanner</code>进行处理，将结果得到一个<code>ArrayList</code>里面，再对这个进行解析，然后调用Manager类进行具体操作。</li></ul><p>主要操作在<code>Manager</code>类中，主要的方法也在<code>Manager</code>类中:happy::happy::happy:</p><ul><li><p>对于要求，我主要是三个大的类进行处理，<code>Adventurer，Backpack，FightMode</code>这几个来进行处理。</p></li><li><p>对于每个<code>Adventurer</code>的管理再<code>Manager</code>里面用一个<code>HashMap</code>来实现。对于每个<code>adventurer</code>，在这里面管理<strong>调度<code>Bottle，Food，Equipment</code>等</strong>，同时对于放进背包的则将其<strong>放到<code>Backpack</code>里面</strong>进行管理调度。</p></li><li><p>进入战斗模式则有一个专门<code>FightMode</code>管理进入的<code>adventurer</code>和进行的操作，对于每个<code>adventurer</code>状态的改变都是在<code>Adventurer</code>类里面实现的，实现<strong>高内聚</strong>。同时后续的增加接口和继承也是直接在<code>Bottle</code>的基础上继承，每次调用都只需要在相应的方法里面实现。</p></li></ul><p>总体还是非常<strong>优雅</strong>的，尽可能的实现了高内聚和低耦合，每次修改代码时感觉上是非常方便的，或许能够间接体现比较好的一个架构建造。</p><p>（我也是几乎到最后才知道有<code>package</code>这个东西，虽然加上后文件结构会更加好看，但对于代码架构本身帮助不大）</p><h3><span id="架构设计中的调整">架构设计中的调整</span></h3><blockquote><p>主要是学到什么或者看到其他同学有什么好的就思考一下是否比我的好，并进行相关学习后进行调整</p></blockquote><ul><li>IO处理</li></ul><p>其中一大调整在于输入处理，随着输入变得更加复杂，需要加入正则表达式进行操作处理后（主要是其中某一个功能有不定行输入），我便将输入处理专门用了一个<code>Scanner</code>类进行处理，以下为具体实现细节：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyScanner</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取行数</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInputInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解析后的输入将会存进该容器中, 类似于c语言的二维数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> nextLine <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取本行指令</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> nextLine<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" +"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按空格对行进行分割</span>            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"14"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">String</span> nextLine1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    operation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextLine1<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// System.out.println(operation);</span>            inputInfo<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>operation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将指令分割后的各个部分存进容器中</span>        <span class="token punctuation">}</span>        <span class="token comment">// System.out.println(inputInfo);</span>        <span class="token keyword">return</span> inputInfo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>结构调整</li></ul><p>在老师讲解完不要再Main里面进行 太多具体的操作后，我便将之前大量的属性和方法移动到了<code>Mynager</code>类中，在这个类中进行不同指令的操作处理，以及正则表达式匹配等。具体实现细节如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Adventurer</span><span class="token punctuation">&gt;</span></span> adventurersMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FightMode</span> fightMode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FightMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> printTestFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token function">getShopInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            strings <span class="token operator">=</span> inputInfo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取第i行指令</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 获取第i行指令的第一个部分</span>                <span class="token keyword">case</span> <span class="token string">"1"</span><span class="token operator">:</span>                    <span class="token comment">// Adventurer.add();</span>                    <span class="token function">adventurerAdd</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接口与继承</li></ul><p>后面在要求实现对<code>Bottle</code>类和<code>Equipment</code>类进行继承，以及对几个价值体实现接口时都有对结构进行相应的调整，大体上也是正常不过的基于教程的修改<s>感觉大家的应该都大差不差</s></p><h3><span id="以下为uml类图">以下为<strong>UML类图</strong></span></h3><p><img src="/2023/11/10/OOpre/1.png" alt></p><p>各个类的属性</p><p><img src="/2023/11/10/OOpre/2.png" alt></p><p>各个类的方法概览</p><p><img src="/2023/11/10/OOpre/3.png" alt></p><h2><span id="part2-使用junit的心得体会">Part2-使用Junit的心得体会</span></h2><blockquote><p>上一次用到这种模块性检测的还是在matlab里面</p></blockquote><p>这种模块化的测试确实会方便于去<strong>寻找具体是哪一方面有问题</strong>，但是我自己本人对于这种工程量很大之后如何处理这些测试指令<strong>感到犯难</strong>，不太懂得具体如何使用。</p><p>同时我觉得很好的一点是主动去想办法提高测试的覆盖率，会帮助我狠狠地<strong>提高代码的鲁棒性</strong>，增加很多对于特殊情况的考虑。</p><h2><span id="part3-学习oopre的心得体会">Part3-学习OOpre的心得体会</span></h2><blockquote><p>很早之前就已经听6系学长讲过OO这一种编程方法，当时对于所谓的高内聚低耦合方面还不太懂，当时学长讲的大多数是基于C语言如何进行类似的开发的</p></blockquote><p>当自己真正开始学习之后，面向对象确实是很好的一种编程理念，特别是中间利用到继承这些时更加感受到了一种代码上的很爽的感觉。</p><p>当然，Java真的是一种非常接近自然语言的函数语言，用起来很爽！</p><h2><span id="part4-对oopre课程的建议">Part4-对OOpre课程的建议</span></h2><ol><li>感觉可以讲一些java本身的一些高级的语法，我也是后来才了解到一些，感觉用起来真的很爽</li><li>我刚开始写Junit和后来写Junit都有点使用取巧的办法，自己也是为了满足测试率去编写的，中间几次甚至是讲几百行的中测数据直接作为输入处理后的二维数组进行处理，或许可以想办法提高Junit的实用性</li></ol><p>OOpre绝世好课！！真的在这个过程中学到了很多东西，也非常感谢助教、老师、同学给我提供的帮助。</p><p>谢谢nrjj！syf大佬！！还有董佬教了我好多新鲜的东西……谢谢各位！</p>]]></content>
      
      
      
        <tags>
            
            <tag> OOpre </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CO-P0-logisim相关</title>
      <link href="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于本次P0,提供我个人的一点拙见</p></blockquote><span id="more"></span><h2><span id="第一题">第一题</span></h2><p><strong>题目描述：</strong></p><p>给定五个8bit输入，输出一个8bit的在五个输入中没出现的最小正整数。</p><p>这里首先考虑到这里必然最大的输出也只是6（因为只有5个数），那么这思路就来了。利用一个6bit的中间量<code>hot</code>(有点独热码的那个意思，因为只会有一项为1，其余为0）来处理。</p><p>如果某一个数小于等于5，那就将这个<code>hot</code>的对应位置为1。然后将每个输入的<code>hot</code><strong>或</strong>起来，那么就得到了个6bit 2进制数，其中有1的位置代表存在该数（由于计数是从0开始，所以最终得到结果的时候需要加个1）</p><p><strong>电路图如图所示：</strong></p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/1.png" alt></p><p>把这个作为一个子电路，对每一个input进行处理，再将得到的<code>hot</code><strong>或</strong>起来。</p><p>最后利用一个bit finder找最低位的0就可以了。这里因为引入的是6位，就能够解决输入为1 2 3 4 5的问题。如果使用5位就需要特判。</p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/2.png" alt></p><h2><span id="第二题">第二题</span></h2><p><strong>题目描述：</strong></p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/3.png" alt></p><p>输入为2bit方向信号，1bit clk，1bit reset(异步复位，直接接在寄存器reset端即可)。</p><p>类似课下的navigation的题目，这里题目要求使用mealy状态机。最开始位于1处，根据输入的2bit方向信息前往下一个位置，如果没有（或者撞墙）则停留在当前位置。输出为下一步的位置标号。</p><p>输出4bit位置信号</p><p>**状态转移图：**直接根据题目信息即可得到状态转移图。这里直接使用4bit二进制码或者3bit二进制码来表示状态即可。</p><p>**打真值表：**略</p><p>Mealy型状态机：</p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/4.png" alt></p><p>补充好status状态转移部分和output输出逻辑即可。</p><p><strong>需要注意的是：</strong></p><p>这里可以直接在寄存器前面接输出（如上图红线部分，当然这里是使用状态的编码从1开始而且为4bit的情况，其他状态也可以进行修改），在计组讨论区中也有讨论，其实也就是Mealy机的实现模式~~，具体可参见这篇<a href="https://www.hugohealthy.top">博客</a>~~（还没写）。</p><p><strong>还有一些打表的小细节：</strong></p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/5.png" alt></p><blockquote><p>第三题</p></blockquote><p><strong>题目描述：</strong></p><p>输入：多个4bit二进制数作为一个16进制数</p><p>判断输入的序列中是否存在指定的序列，并得到对应输出。</p><table><thead><tr><th>输入序列</th><th>输出</th></tr></thead><tbody><tr><td>EEE</td><td>1</td></tr><tr><td>A0E</td><td>2</td></tr><tr><td>0A0</td><td>3</td></tr><tr><td>其他</td><td>0</td></tr></tbody></table><p>输出：2bit output</p><p>题目要求使用<code>moore机</code>实现</p><p><strong>状态转移图：</strong></p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/6.png" alt></p><p>**打真值表：**略</p><p><strong><code>moore机</code></strong>：</p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/7.png" alt></p><p>当然这里还有更加偷巧的办法，比如：</p><p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/8.png" alt></p><p>然后对每个state进行判断就睡简单的组合逻辑了(这里我并没有测试过，不知道具体实施能否行得通，欢迎批评指正)</p>]]></content>
      
      
      <categories>
          
          <category> CO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hammingDistance</title>
      <link href="/2023/05/25/hammingDistance/"/>
      <url>/2023/05/25/hammingDistance/</url>
      
        <content type="html"><![CDATA[<p>分享一下大作业优化的技巧</p><span id="more"></span><h1><span id="__uint128_t_"><code>__uint128_t_</code></span></h1><p>最近越来越多的协议会定义 16 字节长的整形，gcc 在 4.6 以上版本就可以使用 __int128_t &amp; __uint128_t 了。</p><p>但需要注意的是，_uint128_t &amp; __int128_t 仅对 64 位程序才有定义，因此如果编译选项中加入了 -m32，会出现找不到定义的编译错误。</p><p>另外 _uint128_t &amp; __int128_t  并非 c/c++ 标准，所以 gcc 目前只支持基本运算符的操作，printf 这些都需要另外实现。</p><h1><span id="快速计算汉明距离">快速计算汉明距离</span></h1><blockquote><p>在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p><p>汉明距离是以<strong>理查德・卫斯里・汉明</strong>的名字命名的。在通信传输过程中，累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明距离在包括信息论、编码理论、密码学等领域都有应用。</p></blockquote><p>对于两个字符串计算汉明距离，那肯定也就只能是逐位比较</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//s1,s2为两个字符串，M为这两个字符串的长度</span><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l1 <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dist <span class="token operator">+=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么这样肯定是很慢的，如果可以转化两个整型的数，我们很容易想到利用到异或运算。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__uint128_t fingerprint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sumsignedweight <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样可以转换最高128位的两个01字符串。</p><p>那么就可以利用<code>^</code>运算来就算汉明距离了,由于异或运算的性质，得到的c的数位上为1说明ab的对应位不相同，反之则相同，那么我们就之需要计算c的二进制表示中数位为1的数目。这里可以按位采取<code>&amp;</code>运算。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        c <span class="token operator">=</span> c <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>布莱恩·克尼根算法</strong></p><p>我们先观察如下一个现象：对于任意一个非零的二进制数 <code>a</code>（将其看作无符号数），考虑 <code>a</code> 和 <code>a-1</code> 的关系。由于 <code>a</code> 非零，那么 <code>a</code> 中总有一些位为 <code>1</code>。假设 <code>a</code> 中最低位的 <code>1</code> 处于从右向左数的第 <code>N</code> 位。那么，<code>a</code> 的第 <code>N</code> 位以及第 <code>N</code> 位以后的每一位的值和 <code>a-1</code> 的第 <code>N</code> 位及第 <code>N</code> 位以后的每一位的值均不同。</p><p>举个例子就很容易理解了。我们以 8 位数来描述。假设 <code>a=10010000</code>，根据上述描述，从右往左数的第一个 <code>1</code> 出现在第 <code>5</code> 位，那么有 <code>N=5</code>。同时可以计算出 <code>a-1=10001111</code>，可以看到，从第 <code>N</code> 位开始，<code>a</code> 的后缀是 <code>10000</code>，而 <code>a-1</code> 的后缀是 <code>01111</code>。满足上述描述的现象。</p><p>进一步地，我们可以发现，如果对 <code>a</code> 和 <code>a-1</code> 进行与操作，就会直接消去位于最后一位，也就是第 <code>N</code> 位的 <code>1</code>。还以上面的 <code>a</code> 为例，<code>a &amp; (a-1)=10000000</code>。可以看到，我们不需要遍历，而是通过一次运算，就可以把 <code>a</code> 中的最后一个 <code>1</code> 消掉。如果我们一直重复这项操作，那么 <code>a</code> 里有多少个 <code>1</code>，我们就仅需要多少次 <code>a &amp; (a-1)</code> 的操作，就能把 <code>a</code> 化为 <code>0</code> 了。而这个操作的次数正是我们所要求的。</p><p>那么计算汉明距离就可以改进为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大作业优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序</title>
      <link href="/2023/05/25/%E5%AD%97%E5%85%B8%E5%BA%8F/"/>
      <url>/2023/05/25/%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="字典序">字典序</span></h1><h2><span id="说在前面">说在前面</span></h2><blockquote><p>字典序(dictionary order)，又称字母序(alphabetical order)，原意是表示英文单词在字典中的先后顺序，后引申为任意两个字符串的大小关系</p></blockquote><p>那么大家就清楚了这指的是一种大小关系，一种序，正如我们数学分析中的有序集的序有类似的概念，这里大家需要与字典树(Tire)区分开来，字典树实质上是一种数据结构中的用于存储和查找单词的一种树状结构，详情可以看这个<a href="https://www.hugohealthy.top/2023/05/25/Trie/">tire</a>。(在我的另一篇blog可以看到哦)</p><h2><span id="字典序算法相关">字典序算法相关</span></h2><h3><span id="字典序全排列问题">字典序全排列问题</span></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token comment">//交换两个字符，注意这里传过去的是地址，改变的是地址对应的值</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//将一个字符串begin到end的部分逆序</span><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        begin<span class="token operator">++</span><span class="token punctuation">;</span>        end<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">next_permutation</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> str<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">//从后往前找到第一个正序的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//表示找完了，已经全部是逆序了</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//从i开始找到前面的第一个比str[i]大的，那么就进行交换</span><span class="token comment">//再把i+1以后的逆序一遍</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abd"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该代码可以实现一个<strong>顺序的字符串</strong>的所有字母的按字典序输出的全排列。</p><p>否则的话就是输出比改字符串的字典序大于等于的字符串。</p><p>当然简单调整当然可以是任意顺序的一个字符串的操作。</p><h3><span id="字典序排序">字典序排序</span></h3><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/qq_37050329/article/details/86637183">https://blog.csdn.net/qq_37050329/article/details/86637183</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="/2023/05/25/Trie/"/>
      <url>/2023/05/25/Trie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Tire树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。</p></blockquote><span id="more"></span><p>说白了，就是一棵大树，这棵树的每个除了根节点的结点都存储了一个字符。</p><h2><span id="说在前面">说在前面</span></h2><p>字典树有两种实现方式，一种是利用指针实现，也就是一个实实在在的二十六叉树；另一种就是利用数组实现。（在这里分别称之为指针版字典树和数组版字典树）</p><p>两种实现方式各有优劣，指针版本的清晰明了，空间占用率相对较小（空间占用小就可以用剩下的空间干其他很多事）；而数组版字典树就是一次性把空间开好了，比较方便。</p><h2><span id="指针版字典树">指针版字典树</span></h2><p>结构体定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">datatype</span> <span class="token expression"><span class="token keyword">int</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    bool isEnd<span class="token punctuation">;</span>    datatype data<span class="token punctuation">;</span><span class="token comment">//一般是计数</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>letter<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">,</span><span class="token operator">*</span>List<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建一个结点的初始化：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，一种更加推荐的方式是使用<code>calloc()</code>函数，<code>malloc()</code>有更多自己操控的空间</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建一棵<code>Trie</code>:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span></span></span><span class="token keyword">void</span> <span class="token function">createStopTrie</span><span class="token punctuation">(</span>List <span class="token operator">*</span>root<span class="token punctuation">,</span> FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSIZE<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    List end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ch <span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">islower</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            end <span class="token operator">=</span> end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            pos<span class="token operator">++</span><span class="token punctuation">;</span>            depth<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            end<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> true<span class="token punctuation">;</span>            pos<span class="token operator">++</span><span class="token punctuation">;</span>            end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> Depth<span class="token punctuation">)</span> Depth <span class="token operator">=</span> depth<span class="token punctuation">;</span>            depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用前需要</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Root <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">createArticleTrie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Root<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>三个基本性质：</strong></p><ul><li>根节点不包含字符，除根节点的每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><p>我觉得这个像是一个26叉树，也有一点想26进制的一个东西。</p><p>我们这里存储的都是小写字母，如果包含又大写字母的话可能就是一个52叉树了。一般不会出现这种情况吧，<s>出现了也不怪我</s></p><blockquote><p>主要实现单词的高效存储与高效查找</p></blockquote><p>利用<code>cout[i]</code>来记录以<code>i</code>为编号的字符结尾的字符串的个数。</p><p>就有两个基本操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> tr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cou<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>      tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/forever_dreams/article/details/81009580">https://blog.csdn.net/forever_dreams/article/details/81009580</a></li><li><a href="https://zhuanlan.zhihu.com/p/28891541">https://zhuanlan.zhihu.com/p/28891541</a></li><li><a href="https://blog.csdn.net/weixin_42815609/article/details/102692411">https://blog.csdn.net/weixin_42815609/article/details/102692411</a></li><li>用C++讲得很清楚：<a href="https://blog.csdn.net/weixin_44176696/article/details/104716191">https://blog.csdn.net/weixin_44176696/article/details/104716191</a></li><li>这个有头文件诶，高级！：<a href="https://blog.csdn.net/A951860555/article/details/108716487">https://blog.csdn.net/A951860555/article/details/108716487</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一下数据结构大作业</title>
      <link href="/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>暂时嘛，啥也没有</p><p>蒟蒻博主啥也不会捏</p><p>会了也不告诉你</p></blockquote><span id="more"></span><h2><span id="bug">bug</span></h2><blockquote><p>这里是大家可能会遇到的一些问题，我分享一些我的想法</p></blockquote><h2><span id="读题">读题</span></h2><p>要注意理解题目意思。大致就是首先统计article的词频。接着得到单词中非停用词的词频最多的前N个。（要注意不是每个网页的前N个，而是将所有article的网页的词频统计好之后的前N个（这个也就是特征向量）。然后通过<strong>题目描述的计算方式</strong>得到指纹。然后对每个sample的网页，同样统计特征向量中每个单词（注意这里变成了特征向量中的单词，而不需要所有的）的词频，通过<strong>题目描述的计算方式</strong>再次得到指纹。最后将每一个sample网页的指纹与所有article的指纹进行汉明距离的计算，然后统计输出。</p><h3><span id="第一种本地不对">第一种，本地不对</span></h3><p>本地不管是输出错误还是运行时错误，都可以采取打印调试法和逐步调试法。(debug是必修课喔~~)</p><h3><span id="第二种本地对小数据不对">第二种，本地对小数据不对</span></h3><p>嗯，这种情况其实到后面可以向助教祈求小数据的内容。</p><p>首先可能是windows与linux的差异。</p><p>也就是linux中每一行结束时\r\n，而windows是\n。</p><p>可以将文件打开Mode改为rb，看本地输出是否正确。</p><h3><span id="第三种小数据对大数据不对">第三种，小数据对大数据不对</span></h3><blockquote><p>这一种是最恼火的</p></blockquote><p>如果是输出错误，</p><ul><li>千万要注意article和sample的网页名。如果是直接以为就是样例中的1-%d这种的，那么就会出问题。建议改为从数组中解析或者fscanf。</li></ul><p>如果是运行时错误，</p><p>多半是数组开小了，或者malloc多了。</p><ul><li>这种情况下关键是找到哪里运行时错误了。可以在代码的不同位置return 0强制结束然。后看在哪个之前显示的是输出错误，过了那个就变成了运行时错误，那么就仔细看看应该如何解决。</li></ul><h2><span id="题目">题目</span></h2><p><img src="/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E4%BD%9C%E4%B8%9A.png" alt></p><h2><span id="code">code</span></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// N 5000</span><span class="token comment">// M 64</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span></span><span class="token string">"Ofast"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">low</span><span class="token expression"><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">&gt;=</span><span class="token number">65</span><span class="token operator">&amp;&amp;</span>c<span class="token operator">&lt;=</span><span class="token number">90</span> <span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">32</span><span class="token operator">+</span>c<span class="token operator">:</span>c<span class="token punctuation">)</span></span></span><span class="token comment">//#define low(c) (c|0x20)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NMAX</span> <span class="token expression"><span class="token number">10005</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MMAX</span> <span class="token expression"><span class="token number">130</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXHASH</span> <span class="token expression"><span class="token number">1280010</span></span></span><span class="token keyword">char</span> bufferHash<span class="token punctuation">[</span>MAXHASH<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSTOPCHARS</span> <span class="token expression"><span class="token number">10000</span></span></span><span class="token keyword">char</span> bufferStopChars<span class="token punctuation">[</span>MAXSTOPCHARS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXARTICLECHARS</span> <span class="token expression"><span class="token number">350000000</span></span></span><span class="token keyword">char</span> bufferArticleChars<span class="token punctuation">[</span>MAXARTICLECHARS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGENUMMAX</span> <span class="token expression"><span class="token number">16000</span></span></span><span class="token keyword">int</span> hash_better<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span><span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">myatoi</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> tmp <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">!=</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">-</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p1<span class="token operator">++</span><span class="token punctuation">;</span>        p2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mystrcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mymemset_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mystrcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p1<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>        p1<span class="token operator">++</span><span class="token punctuation">;</span>        p2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">readHash</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferHash<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXHASH<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferHash<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hash_better<span class="token punctuation">[</span>hash_i_line<span class="token punctuation">]</span><span class="token punctuation">[</span>hash_i<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">==</span> <span class="token number">48</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            hash_i_line<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                hash_i<span class="token operator">++</span><span class="token punctuation">;</span>                hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> trie_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos_stopWords <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">search_stopwords</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//就是1</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferStopChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSTOPCHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferStopChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_stopWords<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> trie_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aword</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span> word<span class="token punctuation">;</span>word word_num_article<span class="token punctuation">[</span><span class="token number">106010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos_word <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> name_page<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_page <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> len_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    len_article <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pos<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_article<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p <span class="token operator">=</span> trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search_stopwords</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">mystrcpy</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> p<span class="token punctuation">;</span>                pos_word<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                num_page<span class="token operator">++</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pos<span class="token operator">++</span><span class="token punctuation">;</span>                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>                    pos<span class="token operator">++</span><span class="token punctuation">;</span>                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    word <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>    word <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">-</span> num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>str<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> trie_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">^</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> weightArticle<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> sumSignedWeightArticle<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>__uint128_t fingerprintArticle<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> isNWords <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isNWords <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                weightArticle<span class="token punctuation">[</span>isNWords <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//0.96429S</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span> weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span> __uint128_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> weightSample<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> sumSignWeightSample<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>__uint128_t fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> name_sample<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10005</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> num_sample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> flag_ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>space <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">readSample</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">,</span> FILE <span class="token operator">*</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> flag_f<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">!=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>                n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ppage <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ppage <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            weightSample<span class="token punctuation">[</span>ppage <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            flag_f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> N<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token punctuation">(</span>num_page <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                distance <span class="token operator">=</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>fingerprintSample<span class="token punctuation">,</span> fingerprintArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> name_page<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span>                    flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> name_sample<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n%d:"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">fwrite</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            num_sample<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    N <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    M <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>pp_result <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"result.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp_stop <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"stopwords.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp_article <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"article.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp_sample <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"sample.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp_hashvalue <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"hashvalue.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">readHash</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//0.01427S</span>    <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//0.39820S</span>    <span class="token function">qsort</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">,</span> pos_word <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//0.49212S</span>    <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//0.50967</span>    <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//3.53592S</span>    <span class="token function">readSample</span><span class="token punctuation">(</span>fp_sample<span class="token punctuation">,</span> pp_result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//    fclose(fp_sample);</span><span class="token comment">//    fclose(pp_result);</span>    <span class="token comment">//3.63961S</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="version5说明">version5说明</span></h2><p>这里我优化了计算指纹的部分。我将计算的循环次序进行了交换，同时我判断weight是否为0，如果是就不需要进行循环了。</p><p>这个版本在优化后最终也是跑到了<code>1.15s</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大作业优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2023/05/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2023/05/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1><span id="使用两个栈实现一个队列两个队列实现一个栈">使用两个栈实现一个队列，两个队列实现一个栈</span></h1><blockquote><p>总感觉这像是一个面试题——hugo</p></blockquote><span id="more"></span><p>栈是一种后入先出(Last In First Out, LIFO)的数据结构，队列是一种先进先出(First In First Out, FIFO)的数据结构。</p><h2><span id="两个栈实现一个队列">两个栈实现一个队列</span></h2><p>思路一：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p><p>入队：</p><p><code>push_s1(item)</code></p><p>出队：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>top_s2 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp <span class="token operator">=</span> <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">push_s1</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即<code>s1</code>式负责元素的存储，<code>s2</code>作为过渡栈，每次元素出队矩利用到<code>s2</code>;</p><p>但是整个过程中出队入队显然太麻烦了，那么对此进行优化有：</p><p>我们其实可以发现对<code>s2</code>中的<code>top</code>元素<code>pop</code>后其实不一定需要再全部倒回<code>s1</code>，</p><p>那么就有：</p><p>思路二：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p><p>入队：</p><p><code>push_s1(item)</code></p><p>出队：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top_s2 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路二主要就是减少了两个栈之间元素的转移。</p><h2><span id="两个队列实现一个栈">两个队列实现一个栈</span></h2><p>思路一：<code>q1</code>负责出栈，<code>q2</code>只是一个中转</p><p>入栈：</p><p><code>q1[rear1++]=item</code></p><p>出栈：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>front1 <span class="token operator">&lt;</span> rear1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span>    q2<span class="token punctuation">[</span>rear2<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span>item <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>front2 <span class="token operator">&lt;</span> rear2<span class="token punctuation">)</span><span class="token punctuation">{</span>    tmp <span class="token operator">=</span> q2<span class="token punctuation">[</span><span class="token operator">++</span>front2<span class="token punctuation">]</span><span class="token punctuation">;</span>    q1<span class="token punctuation">[</span>rear1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路二：<code>q1</code>和<code>q2</code>都负责进出栈</p><p>入栈：</p><p>如果<code>q1</code>和<code>q2</code>都为空，随便入一个队即可，这里选择入<code>q1</code>；</p><p>如果一个队列为空，另一个队列非空，则入非空队；</p><p>如果都非空，则入<code>q1</code>即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>rear1 <span class="token operator">==</span> front <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    q2<span class="token punctuation">[</span><span class="token operator">++</span>rear2<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出栈：</p><p>如果一个队列为空，另一个队列非空，则仿造思路1将非空队列的队尾元素出队；</p><p>如果两个队列都非空，则将<code>q1</code>的队尾元素出队，其他元素入队<code>q2</code>。即把不为空的队列中除最后一个元素外的所有元素移动到另一个队列中，然后出队最后一个元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散1</title>
      <link href="/2023/05/04/%E7%A6%BB%E6%95%A31/"/>
      <url>/2023/05/04/%E7%A6%BB%E6%95%A31/</url>
      
        <content type="html"><![CDATA[<p>这里记录了大一下学期的离散作业与答案，我会在每次作业截止后马上把我的答案放上来<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><span id="more"></span><p>$$<br>\newcommand{\lfa}[0]{\leftrightarrow}\<br>\newcommand{\w}[0]{\wedge}\<br>\newcommand{\v}[0]{\vee}\<br>\newcommand{\an}[0]{\wedge}\<br>\newcommand{\o}[0]{\vee}\<br>\newcommand{\n}[0]{\neg}\<br>\newcommand{\a}[0]{\forall}\<br>\newcommand{\e}[0]{\exists}\<br>$$</p><h1><span id="第一次作业">第一次作业</span></h1><h2><span id="11">$1.1$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/1.png" alt></p><blockquote><p>a</p></blockquote><h2><span id="21">$2.1$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/2.png" alt></p><ol><li><p>不是命题；</p></li><li><p>不是命题；</p></li><li><p>是命题，真值为0；</p></li><li><p>不是命题；</p></li><li><p>不是命题；</p></li><li><p>是命题，真值为0；</p></li><li><p>是命题，真值为0；</p></li></ol><h2><span id="22">$2.2$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/3.png" alt><br>$$<br>\begin{align}<br>&amp;1.\neg p\<br>&amp;2.(\neg p)\wedge (\neg q)\<br>&amp;3.p\oplus q\<br>&amp;4.p\to q\<br>&amp;5.p\to q\<br>&amp;6.(p\wedge q)\to (r\vee s)\<br>&amp;7.p\leftrightarrow (q \oplus r)\<br>&amp;8.p\to q\<br>&amp;9.p\to q\<br>&amp;10.p\leftrightarrow q\<br>&amp;11.\neg(p\vee q)\to r<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/4.png" alt></p><h2><span id="23">$2.3$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/5.png" alt></p><ol><li>永真式</li><li>可满足式</li><li>可满足式</li><li>永真式</li><li>永真式</li><li>永假式</li><li>永真式</li></ol><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/6.png" alt></p><h2><span id="24">$2.4$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/7.png" alt><br>$$<br>\begin{align}<br>(1)\<br>&amp;p\to (q\to r)\<br>\iff &amp;\neg p\vee(\neg q\vee r)\<br>\iff &amp;(\neg p \vee \neg q)\vee r\<br>\iff &amp;(\neg q \vee \neg p)\vee r\<br>\iff &amp;\neg q \vee (\neg p\vee r)\<br>\iff &amp;\neg q \vee (p\to r)\<br>\iff &amp;q\to(p\to r)\<br>(2)\<br>&amp;(p\to q)\wedge(p\to r)\<br>\iff&amp;(\neg p\vee q)\wedge(\neg p\vee r)\<br>\iff&amp;\neg p \vee (q\wedge r)\<br>\iff&amp;p\to q\wedge r\<br>(3)\<br>&amp;(p\to q)\vee(r\to q)\<br>\iff&amp;(\neg p\vee q)\vee(\neg r \vee q)\<br>\iff&amp;\neg  p\vee\neg r\vee (q\vee q)\<br>\iff&amp;\neg  p\vee\neg r\vee q\<br>\iff&amp;\neg(p\wedge r)\vee q\<br>\iff&amp;p\wedge r \to q\<br>(4)\<br>&amp;p\to (q \to p)\<br>\iff&amp;\neg p \vee (\neg q \vee p)\<br>\iff&amp;(\neg p\vee p)\vee \neg q\<br>\iff&amp;1\vee \neg q\<br>\iff&amp;1\<br>同时又有&amp;\neg p \to (p\to q)\<br>\iff&amp;\neg \neg p \vee (\neg p \vee q)\<br>\iff&amp;(p\vee \neg p)\vee q\<br>\iff&amp;1\vee q\<br>\iff&amp;1\<br>&amp;二者均为永真式，且等值与1，故有二者等值<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/8.png" alt></p><h2><span id="25">$2.5$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/32.png" alt><br>$$<br>\begin{align}<br>(1)\<br>&amp;易知(q\to r)\iff (\neg r\to\neg q)\<br>&amp;由替换实例进行替换\<br>&amp;有(Q\to R)\iff (\neg R\to\neg Q)\<br>(2)\<br>&amp;(p\wedge q)\to r\<br>\iff&amp;\neg(p\wedge q)\vee r\<br>\iff&amp;\neg p\vee \neg q\vee r\<br>\iff&amp;\neg p\vee(\neg q\vee r)\<br>\iff&amp;\neg p\vee(q\to r)\<br>\iff&amp;p\to(q\to r)\<br>&amp;由替换实例进行替换\<br>&amp;有(P\wedge Q)\to R\iff P\to(Q\to R)<br>\end{align}<br>$$</p><h2><span id="26">$2.6$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/33.png" alt><br>$$<br>\begin{align}<br>(1)\<br>&amp;\neg(Q\wedge R)\wedge (\neg Q \vee \neg R)\<br>(2)\<br>&amp;(p\vee(Q\vee R))\wedge((P\vee Q)\vee R)\wedge 1<br>\end{align}<br>$$</p><h2><span id="27">$2.7$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/9.png" alt><br>$$<br>\begin{align}<br>&amp;由对偶定理\<br>(1)\<br>&amp;A是永真式，则取R为1，R^<em>为0\<br>&amp;有A\iff R&amp;\<br>&amp;故A^</em>\iff R^<em>\<br>&amp;即A^</em> \iff 0\<br>&amp;故A为永假式\<br>(2)\<br>(1)\<br>&amp;A是永假式，则取R为0，R^<em>为1\<br>&amp;有A\iff R&amp;\<br>&amp;故A^</em>\iff R^<em>\<br>&amp;即A^</em> \iff 1\<br>&amp;故A为永真式\<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/10.png" alt></p><h1><span id="第二次作业">第二次作业</span></h1><h2><span id="text11">$\text{1.1}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/11.png" alt><br>$$<br>\begin{align}<br>(1)\<br>&amp;(q\to p)\wedge(\neg p \to q)\leftrightarrow \neg p\<br>\iff&amp;(\neg q \vee p)\wedge(\neg(\neg p) \vee q)\leftrightarrow\neg p\<br>\iff&amp;(\neg q \vee p)\wedge(q\vee p)\leftrightarrow\neg p\<br>\iff&amp;(\neg q \wedge q)\vee p \leftrightarrow\neg p\<br>\iff&amp;p\leftrightarrow \neg p\<br>\iff &amp;0\<br>&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>(2)\<br>&amp;(p\to q)\wedge(q\to r)\wedge\neg(p\to r)\<br>\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge\neg(\neg p \vee r)\<br>\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge(p\wedge \neg r)\<br>\iff&amp;((\neg p \vee q)\wedge p)\wedge((\neg q \vee r)\wedge \neg r)\<br>\iff&amp;((\neg p \wedge p ) \vee(q \wedge p))\wedge((\neg q \wedge r)\vee (r \wedge \neg r)) \<br>\iff&amp;(0 \vee(q \wedge p))\wedge((\neg q \wedge r)\vee 0)\<br>\iff&amp;(q\wedge p)\wedge (\neg q \wedge r)\<br>\iff&amp;p \wedge (q\wedge \neg q)\wedge r\<br>\iff&amp;p\wedge 0 \wedge r\<br>\iff&amp;0\<br>&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/12.png" alt></p><h2><span id="text12">$\text{1.2}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/13.png" alt><br>$$<br>\begin{align}<br>(1)<br>&amp;\neg(\neg p \wedge \neg q)\vee \neg (\neg p \vee q)\<br>\iff&amp;(p\wedge q)\vee (p\wedge \neg q)\<br>\iff&amp;p\wedge (q\vee \neg q)\<br>\iff&amp;p\<br>&amp;故即证该等值式，由对偶定理有\<br>&amp;\neg (\neg p\wedge \neg q)\wedge \neg (\neg p\wedge  q)\iff  p\<br>(2)<br>&amp;(p\vee \neg q)\wedge(p\vee q)\wedge(\neg p \vee \neg q)\<br>\iff&amp;p\vee (\neg q \wedge q)\wedge (\neg p \vee \neg q)\<br>\iff&amp;(p\wedge \neg p)\vee(p \wedge \neg q)\<br>\iff&amp;\neg (\neg p \vee q)\<br>&amp;故即证该等值式，由对偶定理有\<br>&amp;(p\wedge \neg q)\vee (p\wedge q)\vee(\neg p \wedge \neg q)\iff\neg (\neg p \wedge q)<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/14.png" alt></p><h2><span id="text13">$\text{1.3}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/15.png" alt><br>$$<br>\begin{align}<br>&amp;1.{0,\to}\<br>&amp;首先我们有{\neg ,\to }为极小完全集\<br>&amp;又由于\neg p \iff p\to 0\<br>&amp;故{\neg ,\to }是完全集\<br>&amp;同时只含0的集合，无法表示真值赋值v(A) = 1\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p><p>&amp;2.{\oplus ,\to}\<br>&amp;首先我们有{\neg ,\to }为极小完全集\<br>&amp;又由于\neg p \iff p\oplus (p\to p)\<br>&amp;故{\oplus,\to}是完全集\<br>&amp;又同时只含\oplus的集合，无法表示真值赋值v(A) = 1\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p><p>&amp;3.{\oplus,\wedge,\leftrightarrow}\<br>&amp;首先我们有{\neg ,\wedge }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集(书上的例题应该可以用吧）\<br>&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>&amp;故{\oplus,\wedge,\leftrightarrow}是完全集\<br>&amp;又同时只含{\oplus，\wedge}的集合，无法表示真值赋值v(A) = 1\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>&amp;只含{\wedge,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p><p>&amp;4.{\oplus,\vee,\leftrightarrow}\<br>&amp;首先我们有{\neg ,\vee }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集\<br>&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>&amp;故{\oplus,\vee,\leftrightarrow}是完全集\<br>&amp;又同时只含{\oplus，\vee}的集合，无法表示真值赋值v(A) = 1\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = ,即此时无法表示\neg\<br>&amp;只含{\vee,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/16.png" alt></p><h2><span id="text14">$\text{1.4}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/17.png" alt><br>$$<br>\begin{align}<br>&amp;1.{\wedge, \vee, \to ,\leftrightarrow}\<br>&amp;该集合无法表示真值赋值v(A) = 0\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>&amp;故该集合不是完全集\<br>&amp;2.{\wedge,\vee,\oplus}\<br>&amp;该集合无法表示真值赋值v(A) = 1\<br>&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>&amp;故该集合不是完全集\<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/18.png" alt></p><h2><span id="text15">$\text{1.5}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/19.png" alt><br>$$<br>\begin{align}<br>1.\<br>&amp;{\uparrow}是完全集\<br>&amp;首先我们知道{\neg,\wedge}是完全集\<br>&amp;且有\neg p \iff p \uparrow p\<br>&amp;p \wedge q\iff \neg(p \uparrow q)\iff(p \uparrow q)\uparrow(p \uparrow q)\<br>&amp;故即证该集合为完全集\<br>2.\<br>&amp;{\downarrow}是完全集\<br>&amp;首先我们知道{\neg,\vee}是完全集\<br>&amp;且有\neg p \iff p \downarrow p\<br>&amp;p \vee q\iff \neg(p \downarrow q)\iff(p \downarrow q)\downarrow(p \downarrow q)\<br>&amp;故即证该集合为完全集\<br>3.\<br>&amp;{\Delta}为完全集\<br>&amp;首先若有0 \Delta 0 = 0,或者1 \Delta 1 = 1\<br>&amp;即0 \Delta 0 = 1,且1 \Delta 1 =0\<br>&amp;那么\Delta无法表示\neg \<br>&amp;又类似{\oplus,\leftrightarrow},若1\Delta0\neq 0\Delta 1\<br>&amp;则仅含p,q两个命题变元而不含其他命题变元的公式A的真值情况中1的个数一定是偶数个\<br>&amp;故该集合无法表示\wedge,\vee\<br>&amp;于是\<br>&amp;若1\Delta0=0\Delta1=0,则此时\Delta 即为\downarrow\<br>&amp;若1\Delta0=0\Delta1=1,故此时\Delta即为\uparrow\<br>&amp;综上即可得证<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/20.png" alt></p><h2><span id="text16">$\text{1.6}$</span></h2><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/Pictures\Screenshots\image-20230416203036176.png" width="800" height="200" alt="图片名称" align="left"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve_formula</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">"False"</span><span class="token punctuation">}</span>    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    has_true <span class="token operator">=</span> <span class="token boolean">False</span>    has_false <span class="token operator">=</span> <span class="token boolean">False</span>    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>        const_exp <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> variables<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">if</span> x <span class="token keyword">in</span> variables <span class="token keyword">else</span> x<span class="token punctuation">,</span> tokens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>            has_true <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            has_false <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> has_false<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'永真式'</span>    <span class="token keyword">elif</span> <span class="token keyword">not</span> has_true<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'永假式'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'可满足式'</span>s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入一个合式公式，命题变元最多有p,q,r三个，仅包含与、或、非三种运算，用and,or,not来表示: "</span><span class="token punctuation">)</span>result <span class="token operator">=</span> solve_formula<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/21.png" alt></p><h1><span id="第三次作业">第三次作业</span></h1><h2><span id="draft">draft</span></h2><p>$$<br>\begin{align}<br>&amp;p \lfa q\<br>\iff&amp;(p\to q)\w(q\to p)\<br>\iff&amp;(\n p \v q)\w(\n q \v  p)\<br>\iff&amp;((\n p \v q) \w \n q)\v((\n p  \v q) \w p)\<br>\iff&amp;(\n p\w \n q)\v(q \w \n q)\v (\n p \w p)\v(q\w p)\<br>\iff&amp;(p\w q)\v(\n p\w \n q)\<br>&amp;( p\v q\v r)\w( p\v q\v\n r)\w( p\v\n q\v r)\w( p\v\n q\v\n r)\<br>&amp;\w( p\v q\v r)\w(\n p\v q\v\n r)\w(\n p\v\n q\v r)\w(\n p\v\n q\v\n r)\<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/22.png" alt></p><h2><span id="text11">$\text{1.1}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/23.png" alt><br>$$<br>\begin{align}<br>&amp;析取范式:\<br>&amp;p,p\vee q,p\wedge \neg r,p\vee \neg p;\<br>&amp;合取范式:\<br>&amp;p,(p\vee q)\wedge r,p\wedge \neg r.p\vee \neg p;<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/24.png" alt></p><p>$p \vee q也是合取范式$</p><h2><span id="text12">$\text{1.2}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/25.png" alt></p><p>$$<br>\begin{align}<br>&amp;1.析取范式有:\<br>&amp;(1),(2),(3),(5)\<br>&amp;2.合取范式有:\<br>&amp;(1),(2),(4)\<br>&amp;3.主析取范式有:\<br>&amp;(1),(5)\<br>&amp;4.主合取范式有:\<br>&amp;(1)<br>\end{align}<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/26.png" alt></p><h2><span id="text13">$\text{1.3}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/27.png" alt></p><p>$$<br>\begin{align}<br>(1)&amp;\neg p \wedge q \to r\<br>\iff&amp;\neg(\neg p \wedge q)\vee r\<br>\iff&amp;p\vee \neg q\vee r\<br>&amp;可知主合取范式为:p\vee \neg q\vee r\<br>&amp;主析取范式为:(\neg p\wedge\neg q\wedge\neg r )\vee(\neg p\wedge\neg q\wedge r )\vee(\neg p\wedge q\wedge r )\vee( p\wedge\neg q\wedge\neg r )\<br>&amp;\vee( p\wedge\neg q\wedge r )\vee( p\wedge q\wedge\neg r )\vee(p\wedge q\wedge r)\<br>&amp;且该合式公式为可满足式\<br>(2)&amp;(p\to q)\to r\<br>\iff&amp;\neg(\neg p \vee q)\vee r\<br>\iff&amp;(p\wedge q)\vee r\<br>\iff&amp;(p\vee r)\wedge(q\vee r)\<br>\iff&amp;(p\wedge(q\vee \neg q)\vee r)\wedge((p\vee \neg p)\wedge q\vee r)\<br>\iff&amp;(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>&amp;可知主合取范式为:(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>&amp;主析取范式为:(\neg p \wedge \neg q \wedge r)\vee(\neg p \wedge q\wedge r)\vee(p \wedge \neg q \wedge r)\vee(p\wedge q\wedge \neg r)\v(p\w q\w r)\<br>&amp;且该合式公式为可满足式\<br>(3)&amp;\n p\v \n q\to (p\lfa \n q)\<br>\iff&amp;\n (\n p \v \n q)\v (p \w \n q)\v(\n p \w q)\<br>\iff&amp;(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>&amp;可知主析取范式为:(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>&amp;主合取范式:p\v q\<br>&amp;且该合式公式为可满足式\<br>(4)&amp;p\v(p\to q\v(\n q \to r))\<br>\iff&amp;p \v(\n p \v q\v (\n(\n q)\v r))\<br>\iff&amp;p \v(\n p \v q\v q\v r)\<br>\iff&amp;1\<br>&amp;可知主合取范式为:1\<br>&amp;主析取范式为:(\n p\w\n q\w\n r)\v(\n p \w \n q \w r)\v(\n p \w q \w \n r)\v(\n p\w q\w r)\<br>&amp;\v(p\w \n q \w \n r)\v(p\w \n q \w  r)\v(p\w q\w \n r)\v(p\w q\w r)\<br>&amp;且该合式公式为永真式\<br>(5)&amp;(p\to q \w r)\w(\n p\to \n q\w \n r)\<br>\iff&amp;(\n p\v(q\w r))\w(\n(\n p)\v(\n q\w \n r))\<br>\iff&amp;(\n p \v q)\w(\n p \v r)\w(p\v \n q)\w(p\v \n r)\<br>\iff&amp;((\n p \v q)\v(r\w \n r))\w(\n p \v(q\w \n q)\v r)\w((p\v \n q)\v(r\w \n r))\w(p\v(q\w \n q)\v \n r)\<br>\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v q\v r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\<br>&amp;\w(p\v \n q\v\n r)\w(p\v q\v \n r)\w(p\v \n q\v \n r)\<br>\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>&amp;可知主合取范式为:(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>&amp;主析取范式为:(p \w q \w r)\v(\n p\w \n q\w \n r)\<br>&amp;且该合式公式为可满足式\<br>(6)&amp;p\w q\w (\n p\v \n q)\<br>\iff&amp;(p\w q\w \n p)\v(p\w q\w \n q)\<br>\iff&amp;0\<br>&amp;可知主析取范式为:0\<br>&amp;主合取范式为:(p\v q)\w(p\v\n q)\w(\n p\v q)\w(\n p\v\n q)\<br>&amp;且该合式公式为永假式\<br>\end{align}<br>$$</p><h2><span id="text14">$\text{1.4}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/34.png" alt></p><p>有，<code>p</code>既是关于<code>p</code>的主析取范式，又是关于<code>p</code>的主合取范式</p><h2><span id="text15">$\text{1.5}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/28.png" alt><br>$$<br>Q\v R,\n Q\vDash R<br>$$</p><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/29.png" alt></p><h2><span id="text16">$\text{1.6}$</span></h2><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/30.png" alt></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">terms</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">}</span>    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    cnt_true <span class="token operator">=</span> <span class="token number">0</span>    cnt_false <span class="token operator">=</span> <span class="token number">0</span>    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>        const_exp <span class="token operator">=</span> exp        <span class="token keyword">for</span> v <span class="token keyword">in</span> variables<span class="token punctuation">:</span>            const_exp <span class="token operator">=</span> const_exp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>v<span class="token punctuation">,</span> variables<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt_true <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            cnt_false <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">return</span> cnt_false<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>terms<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/31.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 离散 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数应用</title>
      <link href="/2022/10/23/%E9%AB%98%E6%95%B0%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/23/%E9%AB%98%E6%95%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div align="center"><font size="24" face="宋体">高等数学不等式问题探讨</font></div><span id="more"></span><div align="center"><font size="6" face="仿宋">hugo</font></div><p>​<font size="4.5" face="楷体">[<b>摘要</b>]</font>:本文将介绍大学高等数学中遇到的相关不等式问题，介绍一些著名的不等式，如算术几何平均不等式、$\text{Bernoulli}$不等式、$\text{Jensen}$不等式、$\text{Cauchy}$不等式、$\text{Young}$不等式、$\text{Holder}$不等式、$\text{Minkowski}$不等式，以及在遇到不等式问题的常用处理办法，利用构造函数，求导分析单调性等方法，最后再结合一些例题进行具体分析讨论。</p><p>​<font size="4.5" face="楷体">[<b>关键词</b>]</font>:算术几何平均不等式；$\text{Jensen}$不等式；$\text{Cauchy}$不等式；$\text{Young}$不等式；$\text{Bernoulli}$不等式；$\text{Holder}$不等式；$\text{Minkowski}$不等式；构造函数；变上限积分</p><h1><span id="1-引言">1   引言</span></h1><p>​在第五届全国大学生数学竞赛非数学类决赛第三题是一道与常微分方程有关的不等式问题：<br>$$<br>设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\</p><p>f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\</p><p>试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>$$<br>​在第八届全国大学生数学竞赛非数学类决赛第二题是一道不等式的综合问题：<br>$$<br>设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>$$<br>​在第八届全国大学生数学竞赛非数学类初赛第二题是一道构造变上限积分的题目：<br>$$<br>设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\<br>有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>$$<br>​在第十届全国大学生数学竞赛非数学类第三题是一道典型的运用到了积分形式的$Cauchy$不等式的题目：<br>$$<br>设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>$$<br>​可以看到不等式问题在考试中的考察还是比较多的，特别是近年有增多的趋势，其次在课后练习及相关研究中，不等式问题具有其独特的数学魅力。不等式问题是许多证明题的重要内容，涵盖的知识点丰富，有许多重要的不等式，这些经典的不等式的处理方法多种多样，在这里我将介绍其中个别方法，并对其在n维度量空间的推广加以介绍。同时将就大学高等数学中出现的不等式问题常用到的方法进行分析，如在导数部分常常用到的构造函数求导分析单调性，在积分部分通过构造变上限积分来证明不等式的问题，同时部分不等式证明题还可以用到$\text{Taylor}$展开、微分中值定理和积分中值定理进行证明。</p><h1><span id="2-几个重要不等式">2   几个重要不等式</span></h1><h4><span id="算术几何平均不等式">算术几何平均不等式</span></h4><p>设$n\in N^*,a_i&gt;0(i=1,2,3\dots n)$,则有<br>$$<br>{n\over\frac1{a_1}+\frac1{a_2}+\dots +\frac1{a_n}}\le\sqrt[n]{a_1a_2\dots a_n}\le{a_1+a_2+\dots+a_n\over n}\le\sqrt{a_1^2+a_2^2+\dots+a_n^2\over n}\<br>$$<br>当且仅当$a_1=a_2=\dots=a_n$时等号成立</p><p>**证明：**由归纳法易证</p><h4><span id="bernoulli不等式">Bernoulli不等式</span></h4><p>当$x\ge -1$时，有<br>$$<br>\begin{align}<br>&amp;(1)若\alpha&gt;1,则有(1+x)^\alpha\ge1+\alpha x;\<br>&amp;(2)若0&lt;\alpha&lt;1,则有(1+x)^\alpha\le1+\alpha x.<br>\end{align}<br>$$<br>**证明：**构造函数求导分析单调性易证</p><h4><span id="jensen不等式">Jensen不等式</span></h4><p>设f(x)是区间$I$上的凸函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>$$<br>f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\le\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).\<br>$$<br>如果f(x)是区间I上的凹函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>$$<br>f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\ge\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).<br>$$</p><p><strong>证明</strong>：由归纳法易证</p><h4><span id="young不等式">Young不等式</span></h4><p>设$a,b\ge0,p,q&gt;1,\frac1p+\frac1q=1$,则有<br>$$<br>ab\le\frac{a^p}p+\frac{b^q}q<br>$$<br>当且仅当$a^{\frac1q}=b^{\frac1p}$时等号成立</p><p><strong>证明：</strong></p><p>若$a=b=0$，则有不等式成立，否则不妨设$b&gt;0$。</p><p>考虑证明$\text{Young}$不等式的等价形式<br>$$<br>\begin{align}<br>&amp;a^{\frac1p}b^{\frac1q}\le\frac ap+\frac bq\<br>&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab\right)+1-\frac1p\<br>&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab -1\right)+1<br>\end{align}<br>$$<br>作换元$x=\frac ab$，则等价于<br>$$<br>\left(x\right)^{\frac1p}\le\frac1p\cdot\left(x -1\right)+1<br>$$<br>构造函数，结合函数的上凸性易证</p><h5><span id="n度量空间的young不等式">n度量空间的Young不等式</span></h5><p>设$x_i\ge0,p_i\ge1(i=1,2,\dots,n),\sum_{i=1}^n\frac1{p_i}=1$,则有<br>$$<br>\prod_{i=1}^n\le\sum_{i=1}^n\frac{x_i^{p_i}}{p_i}<br>$$<br>当且仅当$\frac{x_1^{p_1}}{p_1}=\frac{x_2^{p_2}}{p_2}=\dots=\frac{x_n^{p_n}}{p_n}$时等式成立</p><p><strong>证明：</strong></p><p>与证明2度量空间的$\text{Young}$不等式的方法类似，只不过需要利用$n-1$维函数$f(x_1,x_2,\dots,x_{n-1})$的上凸性<br>$$<br>f(x_1,x_2,\dots,x_{n-1})=\prod_{i=1}^{n-1}x_i^{\frac1{p_i}}<br>$$<br>易证</p><h4><span id="cauchy不等式">Cauchy不等式</span></h4><p>设$a_i,b_i\in R,i=1,2,\dots,n$,有<br>$$<br>\left(\sum_{i=1}^na_ib_i\right)^2\le\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)<br>$$<br>当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立<br>$$<br>\frac{a_1}{b_1}=\frac{a_2}{b_2}=\dots=\frac{a_n}{b_n}<br>$$</p><p><strong>证明：</strong><br>法一:由归纳法易证<br>法二:构造二次函数证明<br>做二次函数<br>$$<br>\begin{align}<br>f(x)&amp;=\left(\sum_{i=1}^na_i^2\right)x^2+2\left(\sum_{i=1}^na_ib_i\right)x+\left(\sum_{i=1}^nb_i^2\right)\<br>&amp;=\sum_{i=1}^n(a_ix+b_i)^2\<br>&amp;\ge0<br>\end{align}<br>$$<br>由于<br>$$<br>\left(\sum_{i=1}^na_i^2\right)&gt;0<br>$$<br>则有<br>$$<br>\Delta=4\left(\sum_{i=1}^na_ib_i\right)^2-4\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)\le 0<br>$$<br>即证</p><h4><span id="holder不等式">Holder不等式</span></h4><p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q&gt;1,\frac1p+\frac1q=1$，则有<br>$$<br>\sum_{i=1}^na_ib_i\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>$$<br>当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p><p>易见$\text{Cauchy}$不等式是$\text{Holder}$不等式的特例。</p><p><strong>证明：</strong></p><p>若$a_1=\dots=a_n=0$或$b_1=\dots=b_n=0$则显然结论成立，否则不妨设$a_1,b_1&gt;0$。</p><p>令<br>$$<br>t=\left(\sum_{i=1}^na_i^p\over\sum_{i=1}^nb_i^q\right)^{\frac1{pq}}<br>$$<br>于是有<br>$$<br>\begin{align}<br>&amp;\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)=\frac1p\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}\<br>&amp;\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)=\frac1q\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>\end{align}<br>$$<br>由$\text{Young}$不等式易知该不等式成立<br>$$<br>\begin{align}<br>\sum_{i=1}^na_ib_i&amp;=\sum_{i=1}^n(t\cdot a_i)(\frac{b_i}t)\<br>&amp;\le\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)+\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)<br>\end{align}<br>$$<br>由$\text{Young}$不等式成立的条件易知该不等式成立的条件即为当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时。</p><p>即证</p><p>$\text{Holder}$不等式还可以做一个小推广</p><p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q,r&gt;1,\frac1p+\frac1q=\frac1r$，则有<br>$$<br>\left(\sum_{i=1}^na_ib_i\right)^{\frac1r}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>$$<br>当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p><p><strong>证明：</strong></p><p>考虑到$r&lt;p,r&lt;q,\frac rp+\frac rq=1$，然后应用$\text{Holder}$不等式即可得证。</p><h5><span id="n度量空间的holder不等式">n度量空间的Holder不等式</span></h5><p>设$x_{i,j}\ge0,r&gt;1,p_i&gt;1,\sum_{i=1}^n\frac1{p_i}=\frac1r$，其中$(1\le i\le n,1\le j\le m)$，则有<br>$$<br>\left(\sum_{j=1}^m\left(\prod_{i=1}^nx_{i,j}\right)^r\right)^{\frac1r}\le\prod_{i=1}^n\left(\sum_{j=1}^mx_{i,j}^{p_i}\right)^{\frac1{p_i}}<br>$$<br>定义一组向量$\vec {x_i}=(x_{i,1}^{p_i},x_{i,2}^{p_i},\dots,x_{i,m}^{p_i}),i=1,2,\dots,n$,当且仅当$\vec {x_i}$相互平行时等式成立。</p><p><strong>证明：</strong></p><p>用$\text{Holder}$不等式和归纳法进行证明即可。</p><h4><span id="minkowski不等式">Minkowski不等式</span></h4><p>设$a_i,b_i\ge0,p&gt;1$，则有<br>$$<br>\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1p}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}+\left(\sum_{i=1}^nb_i^p\right)^{\frac1p}<br>$$<br>当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立</p><p><strong>证明：</strong></p><p>由$\text{Holder}$不等式有<br>$$<br>\begin{align}<br>\left(\sum_{i=1}^n(a_i+b_i)^p\right)&amp;=\sum_{i=1}^n(a_i+b_i)^{p-1}a_i+\sum_{i=1}^n(a_i+b_i)^{p-1}b_i\<br>&amp;\le\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum a_i^p\right)^{\frac1p}+\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum b_i^p\right)^{\frac1p}\<br>&amp;=\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)\<br>&amp;=\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)<br>\end{align}<br>$$<br>由$\text{Holder}$不等式易知不等式的成立当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时。</p><p>即证。</p><h1><span id="3-不等式证明常用方法">3   不等式证明常用方法</span></h1><h3><span id="放缩法">放缩法</span></h3><p>如第五届全国大学生数学竞赛非数学类决赛第三题<br>$$<br>设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\<br>f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\<br>试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>$$<br><strong>解：</strong></p><p>在求导和利用分离变量法求得<br>$$<br>\begin{align}<br>&amp;f’(x)=-\frac{e^{-x}}{1+x}\<br>&amp;f’(x)&lt;0且f(0)=1\<br>&amp;有f(x)\le1\<br>&amp;另一方面\<br>&amp;f(x)=f(0)-\int_0^x\frac{e^{-t}}{1+t}dt\ge1-\int_0^xe^{-t}dt=e^{-x}.<br>\end{align}<br>$$<br>此题就是典型的利用放缩法求证不等式</p><h3><span id="求导法">求导法</span></h3><p>如第八届全国大学生数学竞赛非数学类决赛第二题<br>$$<br>设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>$$<br><strong>解：</strong><br>$$<br>\begin{align}<br>&amp;f(x)=\frac1{x^2}-\frac1{\tan^2 x}\left(0&lt;x&lt;\frac\pi2\right),则\<br>&amp;f’(x)={2(x^3\cos x-\sin^3x)\over x^3\sin^3x}\<br>&amp;令g(x)={six\over \sqrt[3]{\cos x}}-x\left(0&lt;x&lt;\frac\pi2\right)\<br>&amp;g’(x)=\frac23\cos^{\frac23}x+\frac13\cos^{-\frac43}x-1\<br>&amp;结合均值不等式可得g’(x)&gt;0,又g(0)=0\<br>&amp;则有g(x)&gt;0\<br>&amp;故f’(x)&lt;0,从而f(x)单调递减\<br>&amp;又\lim\limits_{x\rightarrow \frac\pi2-}=\frac4{\pi^2};\lim\limits_{x\rightarrow0+}=\frac23\<br>&amp;故即可得证<br>\end{align}<br>$$</p><h3><span id="构造函数变上限积分">构造函数（变上限积分）</span></h3><p>如第八届全国大学生数学竞赛非数学类初赛第二题：<br>$$<br>设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>$$<br><strong>解：</strong></p><p>构造<br>$$<br>\begin{align}<br>&amp;令F(x)=\left(\int_0^xf(t)dt\right)^2-\int_0^xf^3(t)dt\<br>&amp;求导有，F’(x)=f(x)\left(2\int_0^xf(t)dt-f^2(x)\right)\<br>&amp;令G(x)=2\int_0^xf(t)dt-f^2(x)\<br>&amp;G’(x)=2f(x)(1-f’(x))\<br>&amp;有G’(x)&gt;0,则G(x)单调递增\<br>&amp;又G(0)=0,则G(x)&gt;0\<br>&amp;有F’(X)&gt;0,则F(x)单调递增\<br>&amp;又F(0)=0\<br>&amp;即可得证<br>\end{align}<br>$$</p><h3><span id="利用重要不等式">利用重要不等式</span></h3><p>如第十届全国大学生数学竞赛非数学类第三题<br>$$<br>设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>$$<br><strong>解：</strong></p><p>所证式子的左式由$\text{Cauchy}$不等式即证</p><p>右式由于由基本不等式（算术几何平均不等式的二阶形式）<br>$$<br>\begin{align}<br>\int_0^1f(x)dx\int_0^1\frac3{f(x)}dx&amp;\le\frac14\left(\int_0^1f(x)dx+\int_0^1\frac3{f(x)}dx\right)^2\<br>&amp;\le4<br>\end{align}<br>$$<br>即证</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
