<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CO-P0-logisim相关</title>
    <url>/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>关于本次P0,提供我个人的一点拙见</p>
</blockquote>
<span id="more"></span>
<h2><span id="第一题">第一题</span></h2>
<p><strong>题目描述：</strong></p>
<p>给定五个8bit输入，输出一个8bit的在五个输入中没出现的最小正整数。</p>
<p>这里首先考虑到这里必然最大的输出也只是6（因为只有5个数），那么这思路就来了。利用一个6bit的中间量<code>hot</code>(有点独热码的那个意思，因为只会有一项为1，其余为0）来处理。</p>
<p>如果某一个数小于等于5，那就将这个<code>hot</code>的对应位置为1。然后将每个输入的<code>hot</code><strong>或</strong>起来，那么就得到了个6bit 2进制数，其中有1的位置代表存在该数（由于计数是从0开始，所以最终得到结果的时候需要加个1）</p>
<p><strong>电路图如图所示：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/1.png" alt></p>
<p>把这个作为一个子电路，对每一个input进行处理，再将得到的<code>hot</code><strong>或</strong>起来。</p>
<p>最后利用一个bit finder找最低位的0就可以了。这里因为引入的是6位，就能够解决输入为1 2 3 4 5的问题。如果使用5位就需要特判。</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/2.png" alt></p>
<h2><span id="第二题">第二题</span></h2>
<p><strong>题目描述：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/3.png" alt></p>
<p>输入为2bit方向信号，1bit clk，1bit reset(异步复位，直接接在寄存器reset端即可)。</p>
<p>类似课下的navigation的题目，这里题目要求使用mealy状态机。最开始位于1处，根据输入的2bit方向信息前往下一个位置，如果没有（或者撞墙）则停留在当前位置。输出为下一步的位置标号。</p>
<p>输出4bit位置信号</p>
<p>**状态转移图：**直接根据题目信息即可得到状态转移图。这里直接使用4bit二进制码或者3bit二进制码来表示状态即可。</p>
<p>**打真值表：**略</p>
<p>Mealy型状态机：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/4.png" alt></p>
<p>补充好status状态转移部分和output输出逻辑即可。</p>
<p><strong>需要注意的是：</strong></p>
<p>这里可以直接在寄存器前面接输出（如上图红线部分，当然这里是使用状态的编码从1开始而且为4bit的情况，其他状态也可以进行修改），在计组讨论区中也有讨论，其实也就是Mealy机的实现模式~~，具体可参见这篇<a href="https://www.hugohealthy.top">博客</a>~~（还没写）。</p>
<p><strong>还有一些打表的小细节：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/5.png" alt></p>
<blockquote>
<p>第三题</p>
</blockquote>
<p><strong>题目描述：</strong></p>
<p>输入：多个4bit二进制数作为一个16进制数</p>
<p>判断输入的序列中是否存在指定的序列，并得到对应输出。</p>
<table>
<thead>
<tr>
<th>输入序列</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>EEE</td>
<td>1</td>
</tr>
<tr>
<td>A0E</td>
<td>2</td>
</tr>
<tr>
<td>0A0</td>
<td>3</td>
</tr>
<tr>
<td>其他</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>输出：2bit output</p>
<p>题目要求使用<code>moore机</code>实现</p>
<p><strong>状态转移图：</strong></p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/6.png" alt></p>
<p>**打真值表：**略</p>
<p><strong><code>moore机</code></strong>：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/7.png" alt></p>
<p>当然这里还有更加偷巧的办法，比如：</p>
<p><img src="/2023/10/10/CO-P0-logisim%E7%9B%B8%E5%85%B3/8.png" alt></p>
<p>然后对每个state进行判断就睡简单的组合逻辑了(这里我并没有测试过，不知道具体实施能否行得通，欢迎批评指正)</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2023/05/25/Trie/</url>
    <content><![CDATA[<blockquote>
<p>Tire树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。</p>
</blockquote>
<span id="more"></span>
<p>说白了，就是一棵大树，这棵树的每个除了根节点的结点都存储了一个字符。</p>
<h2><span id="说在前面">说在前面</span></h2>
<p>字典树有两种实现方式，一种是利用指针实现，也就是一个实实在在的二十六叉树；另一种就是利用数组实现。（在这里分别称之为指针版字典树和数组版字典树）</p>
<p>两种实现方式各有优劣，指针版本的清晰明了，空间占用率相对较小（空间占用小就可以用剩下的空间干其他很多事）；而数组版字典树就是一次性把空间开好了，比较方便。</p>
<h2><span id="指针版字典树">指针版字典树</span></h2>
<p>结构体定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">datatype</span> <span class="token expression"><span class="token keyword">int</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
    bool isEnd<span class="token punctuation">;</span>
    datatype data<span class="token punctuation">;</span>		<span class="token comment">//一般是计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>letter<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>Node<span class="token punctuation">,</span><span class="token operator">*</span>List<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新建一个结点的初始化：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，一种更加推荐的方式是使用<code>calloc()</code>函数，<code>malloc()</code>有更多自己操控的空间</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">List <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List p <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一棵<code>Trie</code>:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span></span></span>
<span class="token keyword">void</span> <span class="token function">createStopTrie</span><span class="token punctuation">(</span>List <span class="token operator">*</span>root<span class="token punctuation">,</span> FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSIZE<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    List end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ch <span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">islower</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            end <span class="token operator">=</span> end<span class="token operator">-&gt;</span>letter<span class="token punctuation">[</span>ch <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
            depth<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            end<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> true<span class="token punctuation">;</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
            end <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> Depth<span class="token punctuation">)</span> Depth <span class="token operator">=</span> depth<span class="token punctuation">;</span>
            depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用前需要</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Root <span class="token operator">=</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">createArticleTrie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Root<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>三个基本性质：</strong></p>
<ul>
<li>根节点不包含字符，除根节点的每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
<p>我觉得这个像是一个26叉树，也有一点想26进制的一个东西。</p>
<p>我们这里存储的都是小写字母，如果包含又大写字母的话可能就是一个52叉树了。一般不会出现这种情况吧，<s>出现了也不怪我</s></p>
<blockquote>
<p>主要实现单词的高效存储与高效查找</p>
</blockquote>
<p>利用<code>cout[i]</code>来记录以<code>i</code>为编号的字符结尾的字符串的个数。</p>
<p>就有两个基本操作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cou<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span>
<span class="token keyword">char</span> str<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
      tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>
    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    p <span class="token operator">=</span> tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> cou<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/forever_dreams/article/details/81009580">https://blog.csdn.net/forever_dreams/article/details/81009580</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">https://zhuanlan.zhihu.com/p/28891541</a></li>
<li><a href="https://blog.csdn.net/weixin_42815609/article/details/102692411">https://blog.csdn.net/weixin_42815609/article/details/102692411</a></li>
<li>用C++讲得很清楚：<a href="https://blog.csdn.net/weixin_44176696/article/details/104716191">https://blog.csdn.net/weixin_44176696/article/details/104716191</a></li>
<li>这个有头文件诶，高级！：<a href="https://blog.csdn.net/A951860555/article/details/108716487">https://blog.csdn.net/A951860555/article/details/108716487</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre</title>
    <url>/2023/11/10/OOpre/</url>
    <content><![CDATA[<h1><span id="buaa-oopre总结">BUAA-OOpre总结</span></h1>
<blockquote>
<p>即面向对象先导课程，<strong>绝世好课！！</strong>！</p>
</blockquote>
<p>所有的代码均可以前往我的<a href="https://github.com/hjzts/BUAA_OO">github</a>中获取</p>
<span id="more"></span>
<h2><span id="part1-作业背景">Part1-作业背景</span></h2>
<blockquote>
<p>一个非常经典的冒险类游戏</p>
</blockquote>
<p>你是一个穿越到魔法大陆上的冒险者，在旅途中，你需要收集各种<strong>道具</strong>（药水瓶和事物），使用各种<strong>装备</strong>，招募其他<strong>冒险者</strong>加入队伍，提升自己的<strong>等级</strong>并体验各种<strong>战斗</strong>，你可以雇佣冒险者，雇佣者会在适当的时候向你提供<strong>帮助</strong>。同时加入了商店功能，在这里可以进行各种商品的购买与出售。</p>
<h2><span id="part2-架构设计">Part2-架构设计</span></h2>
<h3><span id="最终的架构设计">最终的架构设计</span></h3>
<p>从<code>Main</code>类出发。</p>
<ul>
<li>对于IO，首先对于输入使用<code>MyScanner</code>进行处理，将结果得到一个<code>ArrayList</code>里面，再对这个进行解析，然后调用Manager类进行具体操作。</li>
</ul>
<p>主要操作在<code>Manager</code>类中，主要的方法也在<code>Manager</code>类中:happy::happy::happy:</p>
<ul>
<li>
<p>对于要求，我主要是三个大的类进行处理，<code>Adventurer，Backpack，FightMode</code>这几个来进行处理。</p>
</li>
<li>
<p>对于每个<code>Adventurer</code>的管理再<code>Manager</code>里面用一个<code>HashMap</code>来实现。对于每个<code>adventurer</code>，在这里面管理<strong>调度<code>Bottle，Food，Equipment</code>等</strong>，同时对于放进背包的则将其<strong>放到<code>Backpack</code>里面</strong>进行管理调度。</p>
</li>
<li>
<p>进入战斗模式则有一个专门<code>FightMode</code>管理进入的<code>adventurer</code>和进行的操作，对于每个<code>adventurer</code>状态的改变都是在<code>Adventurer</code>类里面实现的，实现<strong>高内聚</strong>。同时后续的增加接口和继承也是直接在<code>Bottle</code>的基础上继承，每次调用都只需要在相应的方法里面实现。</p>
</li>
</ul>
<p>总体还是非常<strong>优雅</strong>的，尽可能的实现了高内聚和低耦合，每次修改代码时感觉上是非常方便的，或许能够间接体现比较好的一个架构建造。</p>
<p>（我也是几乎到最后才知道有<code>package</code>这个东西，虽然加上后文件结构会更加好看，但对于代码架构本身帮助不大）</p>
<h3><span id="架构设计中的调整">架构设计中的调整</span></h3>
<blockquote>
<p>主要是学到什么或者看到其他同学有什么好的就思考一下是否比我的好，并进行相关学习后进行调整</p>
</blockquote>
<ul>
<li>IO处理</li>
</ul>
<p>其中一大调整在于输入处理，随着输入变得更加复杂，需要加入正则表达式进行操作处理后（主要是其中某一个功能有不定行输入），我便将输入处理专门用了一个<code>Scanner</code>类进行处理，以下为具体实现细节：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyScanner</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取行数</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getOperationLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInputInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解析后的输入将会存进该容器中, 类似于c语言的二维数组</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> nextLine <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取本行指令</span>
            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> nextLine<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" +"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按空格对行进行分割</span>
            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> operation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"14"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operation<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">String</span> nextLine1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    operation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextLine1<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// System.out.println(operation);</span>
            inputInfo<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>operation<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将指令分割后的各个部分存进容器中</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// System.out.println(inputInfo);</span>
        <span class="token keyword">return</span> inputInfo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>结构调整</li>
</ul>
<p>在老师讲解完不要再Main里面进行 太多具体的操作后，我便将之前大量的属性和方法移动到了<code>Mynager</code>类中，在这个类中进行不同指令的操作处理，以及正则表达式匹配等。具体实现细节如下:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Adventurer</span><span class="token punctuation">&gt;</span></span> adventurersMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FightMode</span> fightMode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FightMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> printTestFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token function">getShopInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> inputInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            strings <span class="token operator">=</span> inputInfo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取第i行指令</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 获取第i行指令的第一个部分</span>
                <span class="token keyword">case</span> <span class="token string">"1"</span><span class="token operator">:</span>
                    <span class="token comment">// Adventurer.add();</span>
                    <span class="token function">adventurerAdd</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>接口与继承</li>
</ul>
<p>后面在要求实现对<code>Bottle</code>类和<code>Equipment</code>类进行继承，以及对几个价值体实现接口时都有对结构进行相应的调整，大体上也是正常不过的基于教程的修改<s>感觉大家的应该都大差不差</s></p>
<h3><span id="以下为uml类图">以下为<strong>UML类图</strong></span></h3>
<p><img src="/2023/11/10/OOpre/1.png" alt></p>
<p>各个类的属性</p>
<p><img src="/2023/11/10/OOpre/2.png" alt></p>
<p>各个类的方法概览</p>
<p><img src="/2023/11/10/OOpre/3.png" alt></p>
<h2><span id="part2-使用junit的心得体会">Part2-使用Junit的心得体会</span></h2>
<blockquote>
<p>上一次用到这种模块性检测的还是在matlab里面</p>
</blockquote>
<p>这种模块化的测试确实会方便于去<strong>寻找具体是哪一方面有问题</strong>，但是我自己本人对于这种工程量很大之后如何处理这些测试指令<strong>感到犯难</strong>，不太懂得具体如何使用。</p>
<p>同时我觉得很好的一点是主动去想办法提高测试的覆盖率，会帮助我狠狠地<strong>提高代码的鲁棒性</strong>，增加很多对于特殊情况的考虑。</p>
<h2><span id="part3-学习oopre的心得体会">Part3-学习OOpre的心得体会</span></h2>
<blockquote>
<p>很早之前就已经听6系学长讲过OO这一种编程方法，当时对于所谓的高内聚低耦合方面还不太懂，当时学长讲的大多数是基于C语言如何进行类似的开发的</p>
</blockquote>
<p>当自己真正开始学习之后，面向对象确实是很好的一种编程理念，特别是中间利用到继承这些时更加感受到了一种代码上的很爽的感觉。</p>
<p>当然，Java真的是一种非常接近自然语言的函数语言，用起来很爽！</p>
<h2><span id="part4-对oopre课程的建议">Part4-对OOpre课程的建议</span></h2>
<ol>
<li>感觉可以讲一些java本身的一些高级的语法，我也是后来才了解到一些，感觉用起来真的很爽</li>
<li>我刚开始写Junit和后来写Junit都有点使用取巧的办法，自己也是为了满足测试率去编写的，中间几次甚至是讲几百行的中测数据直接作为输入处理后的二维数组进行处理，或许可以想办法提高Junit的实用性</li>
</ol>
<p>OOpre绝世好课！！真的在这个过程中学到了很多东西，也非常感谢助教、老师、同学给我提供的帮助。</p>
<p>谢谢nrjj！syf大佬！！还有董佬教了我好多新鲜的东西……谢谢各位！</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>os_lab0笔记</title>
    <url>/2024/04/24/os-lab0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="操作系统lab0">操作系统lab0</span></h1>
<h2><span id="1linux操作">1.Linux操作</span></h2>
<h3><span id="11-查看文件">1.1 查看文件</span></h3>
<blockquote>
<p>ls<br>
用法: ls [选项]… [文件]…<br>
选项（常用）：<br>
-a 不隐藏任何以 . 开始的项目<br>
-l 每行只列出一个文件</p>
</blockquote>
<p>示例：<code>ls -al</code></p>
<h3><span id="12-创建一个新的空文件">1.2 创建一个新的空文件</span></h3>
<blockquote>
<p>touch<br>
用法: touch [选项]… 文件…</p>
</blockquote>
<p>示例：<code>touch hello_world.c</code>成功创建一个新的文件</p>
<h3><span id="13-创建并打开一个文件">1.3 (创建并打开一个文件)</span></h3>
<blockquote>
<p>vim [文件名]</p>
</blockquote>
<h3><span id="14-创建文件目录">1.4 创建文件目录</span></h3>
<blockquote>
<p>mkdir<br>
用法：mkdir [选项]… 目录…</p>
</blockquote>
<p>示例：<code>mkdir newdir</code>在目录下创建了一个名为<code>newdir</code>的目录</p>
<h3><span id="15-进入目录">1.5 进入目录</span></h3>
<blockquote>
<p>cd<br>
用法：cd [目录]</p>
</blockquote>
<p>示例：<code>cd newdir</code>进入<code>newdir</code>目录，<code>cd ..</code>返回上一级目录,<code>cd</code>返回主目录,<code>cd -</code>返回上一次所在的目录<br>
输入<code>pwd</code>可以查看当前所在的绝对路径。</p>
<h3><span id="16-删除一个空目录">1.6 删除一个空目录</span></h3>
<blockquote>
<p>rmdir<br>
用法：rmdir [选项]… 目录…</p>
</blockquote>
<p>示例：<code>rmdir newdir</code>删除<code>newdir</code>目录</p>
<h3><span id="17-删除">1.7 删除</span></h3>
<blockquote>
<p>rm<br>
用法：rm [选项]… 文件…<br>
选项：<br>
-r 递归删除目录及其内容<br>
-f 强制删除。忽略不存在的文件，不给出提示</p>
</blockquote>
<p>示例：<code>rm -rf newdir</code>删除<code>newdir</code>目录及其内容</p>
<p>rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删<br>
除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。 rm命令还有-i选项，这个选项在使用文<br>
件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求逐一确定是否要删除。这时，必须输入Y并<br>
按回车键，才能删除文件。 示例：rm -rf /-可强制递归删除全盘文件！！！</p>
<blockquote>
<p>可以考虑在家目录下创建回收站目录，删除文件时先移动到回收站，再删除</p>
</blockquote>
<h3><span id="18-复制文件">1.8 复制文件</span></h3>
<blockquote>
<p>cp<br>
用法：cp [选项]… 源文件 目标文件<br>
选项：<br>
-r 递归复制目录及其内容</p>
</blockquote>
<p>示例：<code>cp hello_world.c hello_world2.c</code>复制<code>hello_world.c</code>文件为<code>hello_world2.c</code><br>
该命令的第一个参数为原文件路径，命令的第二个参数为目标文件路径。如果目标文件路径不存在，则会创建一个新的文件。</p>
<h3><span id="19-移动文件">1.9 移动文件</span></h3>
<blockquote>
<p>mv<br>
用法：mv [选项]… 源文件 目标文件<br>
选项：<br>
-i 若目标文件已经存在，询问是否覆盖</p>
</blockquote>
<p>示例：<code>mv hello_world2.c newdir</code>将<code>hello_world2.c</code>移动到<code>newdir</code>目录下<br>
<code>mv oldname newname</code>可以重命名文件</p>
<h3><span id="110-回显">1.10 回显</span></h3>
<blockquote>
<p>echo</p>
</blockquote>
<p>示例：<code>echo "hello world"</code>输出<code>hello world</code></p>
<h3><span id="111-查看文件内容">1.11 查看文件内容</span></h3>
<blockquote>
<p>cat<br>
用法：cat [选项]… [文件]…<br>
选项：<br>
-n 显示行号<br>
-b 显示行号，空行不显示<br>
-A 显示所有字符，包括控制字符<br>
-E 显示行尾的$<br>
-T 显示制表符<br>
-v 显示不可见字符<br>
-s 合并多个空行为一个空行<br>
-e 显示行尾的$</p>
</blockquote>
<p>示例：<code>cat hello_world.c</code>查看<code>hello_world.c</code>文件内容<br>
<code>cat -n file1 &gt; file2</code> 将file1的内容输出到file2中，并且在每一行前加上行号<br>
<code>cat -b file1 file2 &gt;&gt; file3</code> 将file1和file2的内容输出附加到file3中，并且在每一行前加上行号</p>
<p>###　1.12 帮助</p>
<blockquote>
<p>man -manual<br>
用法：man [选项]… [命令]…<br>
选项：<br>
-f 显示命令的简短说明</p>
</blockquote>
<p>示例：<code>man ls</code>查看<code>ls</code>命令的帮助<br>
通过man命令可以查看命令的详细用法和参数说明</p>
<h3><span id="113-查找">1.13 查找</span></h3>
<blockquote>
<p>find<br>
用法：find [选项]… [路径]… [表达式]…<br>
选项：<br>
-name 按文件名查找<br>
-type 按文件类型查找<br>
-size 按文件大小查找<br>
-exec 对查找到的文件执行命令</p>
</blockquote>
<ul>
<li><code>find</code>当前目录下递归查找符合参数所示文件名的文件，并将文件的路径输出至屏幕上</li>
</ul>
<p>示例：<code>find . -name "hello_world.c"</code>查找当前目录下的<code>hello_world.c</code>文件</p>
<blockquote>
<p>grep<br>
用法：grep [选项]… 模式 [文件]…<br>
选项：<br>
-n 显示行号<br>
-v 显示不包含模式的行<br>
-i 忽略大小写<br>
-r 递归查找<br>
-l 只显示文件名<br>
-c 显示匹配行数<br>
-w 匹配整个单词<br>
-A 显示匹配行及后面的n行</p>
</blockquote>
<ul>
<li><code>grep</code>使用正则表达式匹配文件内容，并把匹配的行输出至屏幕上。可以从文件中查找包含<code>pattern</code>部分字符串的行，并将该文件的路径和该行输出值屏幕</li>
</ul>
<p>示例：<code>grep "hello" hello_world.c</code>查找<code>hello_world.c</code>文件中包含<code>hello</code>的行</p>
<blockquote>
<p>tree<br>
用法：tree [选项]… [目录]…<br>
选项：<br>
-d 只显示目录<br>
-L 显示目录的深度<br>
-a 显示所有文件<br>
-f 显示完整路径</p>
</blockquote>
<ul>
<li><code>tree</code>可以以树状图的形式显示目录结构</li>
</ul>
<p>示例：<code>tree</code>显示当前目录的树状图</p>
<h3><span id="114-权限">1.14 权限</span></h3>
<blockquote>
<p>chmod<br>
用法：chmod [选项]… 模式 文件…<br>
选项：<br>
-R 递归修改<br>
模式：<br>
u 用户<br>
g 用户组<br>
o 其他用户<br>
a 所有用户<br>
‘+’ 添加权限<br>
‘-’ 减少权限<br>
= 设置权限<br>
r 读权限<br>
w 写权限<br>
x 执行权限<br>
s 设置用户ID<br>
t 粘滞位</p>
</blockquote>
<p>示例：<code>chmod u+x hello_world.c</code>给<code>hello_world.c</code>文件的用户添加执行权限<br>
<code>chmod 777 hello_world.c</code>给<code>hello_world.c</code>文件的所有用户添加读写执行权限<br>
<code>chmod 755 hello_world.c</code>给<code>hello_world.c</code>文件的用户添加读写执行权限，用户组和其他用户添加读执行权限(对应二进制111b=7, 101b=5)<br>
<code>chmod -w hello_world.c</code>删除<code>hello_world.c</code>文件的写权限</p>
<blockquote>
<p>chown<br>
用法：chown [选项]… 用户:用户组 文件…<br>
选项：<br>
-R 递归修改<br>
用户：文件的所有者<br>
用户组：文件的所属用户组<br>
文件：要修改的文件<br>
该命令可以修改文件的所有者和所属用户组</p>
</blockquote>
<p>示例：<code>chown root:root hello_world.c</code>将<code>hello_world.c</code>文件的所有者和所属用户组修改为<code>root</code></p>
<h3><span id="115-比较文件差异">1.15 比较文件差异</span></h3>
<blockquote>
<p>diff<br>
用法：diff [选项]… 文件1 文件2<br>
选项：<br>
-c 以上下文的方式显示差异<br>
-u 以统一的方式显示差异<br>
-r 递归比较目录<br>
-b 忽略空格<br>
-B 忽略空行<br>
-q 只显示是否有差异</p>
</blockquote>
<p>该命令可以比较两个文件的差异</p>
<h3><span id="116-文件处理">1.16 文件处理</span></h3>
<blockquote>
<p>sed<br>
用法：sed [选项]… [脚本]… [文件]…<br>
选项：<br>
-n 安静模式，只显示脚本处理后的结果<br>
-e 多个脚本处理<br>
-f 从文件中读取脚本<br>
脚本：</p>
<ul>
<li>s/old/new/g 替换old为new</li>
<li>d 删除匹配行</li>
<li>p 打印匹配行</li>
<li>a 在匹配行后添加</li>
<li>i 在匹配行前添加</li>
<li>c 替换匹配行</li>
<li>r 从文件中读取</li>
<li>w 写入文件</li>
<li>q 退出</li>
</ul>
<p>-i 直接修改文件，而不是输出到屏幕。否则，只输出不编辑</p>
</blockquote>
<p>示例：<code>sed -i 's/old/new/g' hello_world.c</code>将<code>hello_world.c</code>文件中的<code>old</code>替换为<code>new</code></p>
<blockquote>
<p>[行号]a[内容] 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理<br>
[行号]c[内容] 取代。用内容取代相应行的文本<br>
[行号]i[内容] 插入。在当前行的上面插入一行文本<br>
[行号]d 删除当前行的内容<br>
[行号]p 输出选择的内容。通常与选项-n一起使用<br>
s/re/string 将 re（正则表达式）匹配的内容替换为 string</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1a\hello'</span> hello_world.c   <span class="token comment">#在第一行后添加hello</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1,3d'</span> hello_world.c      <span class="token comment">#删除第一行到第三行</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'1,3p'</span> hello_world.c     <span class="token comment">#输出第一行到第三行</span>
<span class="token comment"># 输出 my.txt 的第三行</span>
<span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'3p'</span> my.txt
<span class="token comment"># 删除 my.txt 文件的第二行</span>
<span class="token function">sed</span> <span class="token string">'2d'</span> my.txt
<span class="token comment"># 删除 my.txt 文件的第二行到最后一行（$ 符号表示到最末尾）</span>
<span class="token function">sed</span> <span class="token string">'2,$d'</span> my.txt
<span class="token comment"># 在整行范围内把 str1 替换为 str2</span>
<span class="token comment"># 如果没有 g 标记，则只有每行第一个匹配的 str1 被替换成 str2</span>
<span class="token function">sed</span> <span class="token string">'s/str1/str2/g'</span> my.txt
<span class="token comment"># -e 选项允许在同一行里执行多条命令。例子的第一条是第四行后添加一个 str, 第二个命令是将</span>
str 替换为 aaa。命令的执行顺序对结果有影响。
<span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'4a\str'</span> <span class="token parameter variable">-e</span> <span class="token string">'s/str/aaa/'</span> my.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>awk<br>
用法：awk [选项]… [脚本]… [文件]…<br>
选项：<br>
-F 指定分隔符<br>
脚本：</p>
<ul>
<li>print 打印</li>
<li>printf 格式化打印</li>
<li>NR 行号</li>
<li>NF 列数</li>
<li>$1 第一列</li>
<li>$0 整行</li>
<li>$NF 最后一列</li>
<li>$NR 最后一行</li>
<li>BEGIN{…} 开始时执行</li>
<li>END{…} 结束时执行</li>
<li>FS 分隔符</li>
<li>OFS 输出分隔符</li>
<li>RS 输入行分隔符</li>
<li>ORS 输出行分隔符</li>
<li>FILENAME 文件名</li>
<li>FNR 当前文件的行号</li>
<li>ARGIND 当前文件的序号</li>
<li>ARGV 当前文件的名字</li>
<li>ENVIRON 环境变量</li>
<li>length() 字符串长度</li>
<li>substr() 截取字符串</li>
<li>index() 查找字符串</li>
<li>match() 匹配字符串</li>
<li>split() 分割字符串</li>
<li>tolower() 转小写</li>
<li>toupper() 转大写</li>
<li>system() 执行系统命令</li>
<li>getline 读取下一行</li>
<li>close 关闭文件</li>
<li>delete 删除数组</li>
<li>next 跳过当前行</li>
<li>exit 退出</li>
</ul>
<p>-f 从文件中读取脚本<br>
-v 定义变量</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'{print $1}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列 </span>
<span class="token function">awk</span> -F: <span class="token string">'{print $1}'</span> /etc/passwd  <span class="token comment">#以:为分隔符输出/etc/passwd的第一列</span>
<span class="token function">awk</span> <span class="token string">'{print $1,$2}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列和第二列</span>
<span class="token function">awk</span> <span class="token string">'{print $1,$2}'</span> <span class="token assign-left variable">OFS</span><span class="token operator">=</span><span class="token string">":"</span> my.txt  <span class="token comment">#输出 my.txt 的第一列和第二列，以:为分隔符</span>
<span class="token function">awk</span> <span class="token string">'$1&gt;2 {print$1,$3}'</span> my.txt  <span class="token comment">#输出 my.txt 的第一列大于2的行的第一列和第三列</span>
<span class="token variable">$n</span> 代表每一行中用空格分隔后的第n项
<span class="token function">awk</span> <span class="token parameter variable">-F</span> , <span class="token string">'{print $2}'</span> my.txt  <span class="token comment">#以,为分隔符输出 my.txt 的第二列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="117-压缩解压">1.17 压缩解压</span></h3>
<blockquote>
<p>tar<br>
用法：tar [选项]… [文件]…<br>
选项：<br>
-c 创建压缩文件<br>
-x 解压文件<br>
-z 使用gzip压缩<br>
-j 使用bzip2压缩<br>
-v 显示详细信息<br>
-f 指定文件名<br>
-C 指定目录<br>
-t 显示压缩文件内容<br>
-r 向压缩文件中添加文件<br>
-u 更新压缩文件<br>
-d 从压缩文件中删除文件<br>
-A 合并压缩文件<br>
-W 确认压缩文件<br>
-p 保留文件权限<br>
-P 保留绝对路径<br>
-m 不保留文件修改时间<br>
-l 保留符号链接<br>
-k 保留已存在文件<br>
-N 指定时间<br>
-X 指定排除文件<br>
-T 指定文件列表<br>
-U 更新压缩文件<br>
-M 多卷压缩文件<br>
-h 显示帮助</p>
</blockquote>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> file.tar file1 file2  <span class="token comment">#将file1和file2打包成file.tar</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> file.tar  <span class="token comment">#解压file.tar</span>
<span class="token function">tar</span> <span class="token parameter variable">-zcvf</span> file.tar.gz file1 file2  <span class="token comment">#将file1和file2打包成file.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="118-管道">1.18 管道</span></h3>
<blockquote>
<p>管道符号<code>|</code>可以将一个命令的输出作为另一个命令的输入</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command1 <span class="token operator">|</span> command2 <span class="token operator">|</span> command3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-al</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"hello"</span>  <span class="token comment">#查找当前目录下包含hello的文件</span>
<span class="token comment"># 为将my.sh的内容输出给grep命令，grep在其中查找字符串</span>
<span class="token function">cat</span> my.sh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Hello"</span>
<span class="token comment"># 将 my.sh 的内容作为 cat 命令参数，cat 命令 stdout 发给 grep 命令的 stdin，grep 在其</span>
中查找字符串，最后将结果输出到 output.txt
<span class="token function">cat</span> <span class="token operator">&lt;</span> my.sh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Hello"</span> <span class="token operator">&gt;</span> output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="119-重定向">1.19 重定向</span></h3>
<ul>
<li>标准输入(stdin)：0</li>
<li>标准输出(stdout)：1</li>
<li>标准错误(stderr)：2</li>
</ul>
<blockquote>
<p>重定向符号<code>&gt;</code>可以将命令的输出重定向到文件中<br>
重定向符号<code>&gt;&gt;</code>可以将命令的输出追加到文件中<br>
重定向符号<code>&lt;</code>可以将文件的内容作为命令的输入<br>
重定向符号<code>2&gt;</code>可以将错误输出重定向到文件中<br>
重定向符号<code>&amp;&gt;</code>可以将标准输出和错误输出重定向到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中<br>
重定向符号<code>&amp;&gt;&gt;</code>可以将标准输出和错误输出追加到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中<br>
重定向符号<code>&amp;&gt;&gt;</code>可以将标准输出和错误输出追加到文件中<br>
重定向符号<code>2&gt;&amp;1</code>可以将错误输出重定向到标准输出中</p>
</blockquote>
<h3><span id="120-环境变量">1.20 环境变量</span></h3>
<blockquote>
<p>环境变量是一些系统的配置信息，可以通过环境变量来控制系统的行为</p>
</blockquote>
<ul>
<li><code>PATH</code>环境变量：用于指定系统的可执行文件的路径</li>
<li><code>HOME</code>环境变量：用于指定用户的家目录</li>
<li><code>USER</code>环境变量：用于指定当前用户的用户名</li>
<li><code>SHELL</code>环境变量：用于指定当前用户的shell</li>
<li><code>PWD</code>环境变量：用于指定当前用户的工作目录</li>
<li><code>LANG</code>环境变量：用于指定当前用户的语言</li>
<li><code>TERM</code>环境变量：用于指定当前用户的终端类型</li>
<li><code>EDITOR</code>环境变量：用于指定当前用户的编辑器</li>
<li><code>PS1</code>环境变量：用于指定当前用户的命令提示符</li>
<li><code>PS2</code>环境变量：用于指定当前用户的命令提示符的续行符</li>
<li><code>PS3</code>环境变量：用于指定当前用户的选择提示符</li>
<li><code>PS4</code>环境变量：用于指定当前用户的调试提示符</li>
<li><code>HISTSIZE</code>环境变量：用于指定当前用户的历史记录的大小</li>
<li><code>HISTFILESIZE</code>环境变量：用于指定当前用户的历史记录文件的大小</li>
<li><code>HISTCONTROL</code>环境变量：用于指定当前用户的历史记录的控制</li>
<li><code>HISTIGNORE</code>环境变量：用于指定当前用户的历史记录的忽略</li>
</ul>
<blockquote>
<p><code>export</code>命令可以将一个变量导出为环境变量<br>
<code>unset</code>命令可以将一个环境变量删除<br>
<code>env</code>命令可以查看当前的环境变量<br>
<code>set</code>命令可以查看当前的所有变量<br>
<code>echo $变量名</code>可以查看变量的值<br>
<code>echo $PATH</code>可以查看<code>PATH</code>环境变量的值</p>
</blockquote>
<h3><span id="121-常用快捷键">1.21 常用快捷键</span></h3>
<ul>
<li><code>Ctrl+C</code>中断当前命令</li>
<li><code>Ctrl+D</code>退出当前shell,相当于<code>exit</code></li>
<li><code>Ctrl+L</code>清屏</li>
<li><code>Ctrl+Z</code>挂起当前命令,使用<code>fg</code>命令恢复</li>
</ul>
<h3><span id="122-通配符">1.22 通配符</span></h3>
<ul>
<li><code>*</code>匹配任意多个字符,<code>ls *.txt</code>匹配所有以<code>.txt</code>结尾的文件</li>
<li><code>?</code>匹配一个字符,<code>ls ?.txt</code>匹配所有以一个字符加<code>.txt</code>结尾的文件</li>
<li><code>[]</code>匹配指定范围内的字符,<code>ls [a-z].txt</code>匹配所有以一个小写字母加<code>.txt</code>结尾的文件</li>
<li><code>!</code>取反,排除匹配的文件,<code>ls !(*.txt)</code>匹配所有不以<code>.txt</code>结尾的文件</li>
<li><code>{}</code>,<code>ls {*.txt,*.c}</code>匹配所有以<code>.txt</code>或<code>.c</code>结尾的文件</li>
<li><code>()</code>可以改变优先级,<code>ls (a|b).txt</code>匹配所有以<code>a.txt</code>或<code>b.txt</code>结尾的文件</li>
<li><code>|</code>或,<code>ls a.txt|b.txt</code>匹配所有以<code>a.txt</code>或<code>b.txt</code>结尾的文件</li>
<li><code>^</code>匹配行首,<code>ls ^a.txt</code>匹配所有不以<code>a.txt</code>开头的文件</li>
<li><code>$</code>匹配行尾,<code>ls a.txt$</code>匹配所有以<code>a.txt</code>结尾的文件</li>
<li><code>\&lt;</code>匹配单词开头,<code>\&gt;</code>匹配单词结尾,<code>ls \&lt;a.txt</code>匹配所有以<code>a.txt</code>开头的文件</li>
<li><code>**</code>,递归匹配,<code>ls **/*.txt</code>匹配所有以<code>.txt</code>结尾的文件</li>
</ul>
<h3><span id="123-tmux">1.23 tmux</span></h3>
<blockquote>
<p>tmux是一个终端复用工具，可以在一个终端中同时运行多个终端<br>
详情看另一个文件</p>
</blockquote>
<h2><span id="2-使用工具">2. 使用工具</span></h2>
<h3><span id="21-编译器">2.1 编译器</span></h3>
<ul>
<li><code>gcc</code>是一个C语言编译器</li>
<li><code>g++</code>是一个C++语言编译器</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：gcc <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span class="token punctuation">..</span>.
选项：
<span class="token parameter variable">-c</span> 仅编译，不链接
<span class="token parameter variable">-o</span> 指定输出文件
<span class="token parameter variable">-E</span> 预处理
<span class="token parameter variable">-S</span> 汇编
<span class="token parameter variable">-l</span> 指定库文件
<span class="token parameter variable">-L</span> 指定库文件路径
<span class="token parameter variable">-I</span> Path/to/head/file 指定头文件路径
<span class="token parameter variable">-D</span> 定义宏
<span class="token parameter variable">-wall</span> 显示所有警告
<span class="token parameter variable">-g</span> 生成调试信息
<span class="token parameter variable">-std</span><span class="token operator">=</span>c99 指定C语言标准
参数：
file.c 源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world.o目标文件</span>
gcc <span class="token parameter variable">-E</span> hello_world.c  <span class="token comment">#预处理hello_world.c文件</span>
gcc <span class="token parameter variable">-S</span> hello_world.c  <span class="token comment">#汇编hello_world.c文件</span>
gcc <span class="token parameter variable">-o</span> hello_world hello_world.c <span class="token parameter variable">-lm</span>  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件，并链接数学库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时编译多个文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world.o和hello_world2.o目标文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-o用于指定要生成的结果文件，后面跟的就是结果文件名字。o是output的意思，不是目标的意思。结果文件可能是预处理文件、汇编文件、目标文件或者最终可执行文件。</p>
</blockquote>
<h3><span id="makefile">Makefile</span></h3>
<blockquote>
<p>Makefile是一个用于编译程序的工具，可以自动化编译程序<br>
基本格式</p>
</blockquote>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target</span><span class="token punctuation">:</span> dependencies
    command 1
    command 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>target</code>是要生成的目标文件</li>
<li><code>dependencies</code>是生成<code>target</code>所需要的依赖文件</li>
<li><code>command</code>是生成<code>target</code>所需要执行的命令</li>
</ul>
<p>示例</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">hello_world</span><span class="token punctuation">:</span> hello_world.c
    gcc -o hello_world hello_world.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3><span id="shell脚本">shell脚本</span></h3>
<blockquote>
<p>shell脚本是一个用于执行命令的脚本文件</p>
</blockquote>
<ul>
<li>在脚本中在第一行添加<code>#!/bin/bash</code>可以指定脚本使用的shell</li>
<li>运行脚本
<ul>
<li>通过<code>chmod +x script.sh</code>添加执行权限后，<code>./script.sh</code>运行脚本</li>
<li><code>sh script.sh</code>运行脚本</li>
<li><code>./script.sh</code>运行脚本</li>
<li><code>source script.sh</code>运行脚本</li>
</ul>
</li>
<li>参数
<ul>
<li><code>$0</code>脚本名</li>
<li><code>$1</code>第一个参数</li>
<li><code>$2</code>第二个参数</li>
<li><code>$#</code>参数个数</li>
<li><code>$*</code>所有参数，所有参数都是一个字符串</li>
<li><code>$@</code>所有参数，每个参数都是一个独立的字符串</li>
<li><code>$$</code>脚本的进程号</li>
<li><code>$?</code>上一个命令的返回值</li>
<li><code>$!</code>后台运行的最后一个进程的进程号</li>
</ul>
</li>
<li>函数
<ul>
<li><code>function_name(){...}</code>定义函数</li>
<li><code>function_name</code>调用函数</li>
<li><code>return</code>返回值</li>
</ul>
</li>
<li>控制结构
<ul>
<li><code>if...then...fi</code>条件语句</li>
<li><code>case...esac</code>多条件语句</li>
<li><code>for...do...done</code>循环语句</li>
<li><code>while...do...done</code>循环语句</li>
<li><code>until...do...done</code>循环语句</li>
<li><code>break</code>跳出循环</li>
<li><code>continue</code>跳过本次循环</li>
<li><code>exit</code>退出脚本</li>
<li><code>trap</code>捕获信号</li>
<li><code>eval</code>执行命令</li>
<li><code>exec</code>执行命令</li>
<li><code>let</code>执行算术运算</li>
<li><code>select</code>选择语句</li>
<li><code>shift</code>移动参数</li>
<li><code>source</code>执行脚本</li>
<li><code>test</code>测试语句</li>
<li><code>time</code>计时</li>
<li><code>type</code>查找命令</li>
<li><code>ulimit</code>设置资源限制</li>
</ul>
</li>
<li>关系运算符
<ul>
<li><code>-eq</code>等于</li>
<li><code>-ne</code>不等于</li>
<li><code>-gt</code>大于</li>
<li><code>-lt</code>小于</li>
<li><code>-ge</code>大于等于</li>
<li><code>-le</code>小于等于</li>
<li><code>=</code>字符串相等</li>
<li><code>!=</code>字符串不相等</li>
<li><code>-z</code>字符串为空</li>
<li><code>-n</code>字符串不为空</li>
<li><code>-e</code>文件存在</li>
<li><code>-f</code>文件存在且是普通文件</li>
<li><code>-d</code>文件存在且是目录</li>
<li><code>-s</code>文件存在且不为空</li>
<li><code>-r</code>文件存在且可读</li>
</ul>
</li>
</ul>
<h3><span id="ctags">ctags</span></h3>
<blockquote>
<p>ctags是一个用于生成代码索引的工具</p>
</blockquote>
<ul>
<li><code>ctags -R</code>生成当前目录的代码索引</li>
<li><code>ctags -R /path/to/dir</code>生成指定目录的代码索引</li>
<li><code>ctags -R /path/to/dir/*</code>生成指定目录的代码索引</li>
<li>vim 下使用<code>Ctrl+]</code>跳转到定义处,<code>Ctrl+t</code>返回</li>
<li>vim 下使用<code>:ts</code>查找定义处,<code>:tn</code>下一个,<code>:tp</code>上一个</li>
</ul>
<h2><span id="git">Git</span></h2>
<h3><span id="31-基本操作">3.1 基本操作</span></h3>
<ul>
<li><code>git init</code>初始化一个仓库</li>
<li><code>git clone</code>克隆一个仓库</li>
<li><code>git add</code>添加文件到暂存区</li>
<li><code>git commit</code>提交文件到仓库</li>
<li><code>git status</code>查看仓库状态</li>
<li><code>git diff</code>查看文件差异</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git reset</code>重置仓库</li>
<li><code>git rm</code>删除文件</li>
<li><code>git mv</code>移动文件</li>
<li><code>git branch</code>查看分支</li>
</ul>
<h3><span id="32-分支操作">3.2 分支操作</span></h3>
<ul>
<li><code>git branch</code>查看分支</li>
<li><code>git checkout</code>切换分支</li>
<li><code>git merge</code>合并分支</li>
<li><code>git rebase</code>变基分支</li>
<li><code>git cherry-pick</code>挑选提交</li>
<li><code>git tag</code>标记提交</li>
<li><code>git stash</code>暂存工作区</li>
<li><code>git fetch</code>获取远程分支</li>
<li><code>git pull</code>拉取远程分支</li>
<li><code>git push</code>推送远程分支</li>
<li><code>git remote</code>管理远程仓库</li>
<li><code>git submodule</code>管理子模块</li>
<li><code>git worktree</code>管理工作树</li>
<li><code>git reflog</code>查看引用日志</li>
<li><code>git bisect</code>二分查找</li>
<li><code>git blame</code>查看文件作者</li>
<li><code>git grep</code>查找文件内容</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git show</code>查看提交详情</li>
</ul>
<h3><span id="33-高级操作">3.3 高级操作</span></h3>
<ul>
<li><code>git filter-branch</code>过滤分支</li>
<li><code>git subcommand</code>子命令</li>
<li><code>git rerere</code>重用冲突解决</li>
<li><code>git gc</code>垃圾回收</li>
<li><code>git fsck</code>检查仓库</li>
<li><code>git prune</code>删除无用对象</li>
</ul>
<h3><span id="git-版本回退">git 版本回退</span></h3>
<ul>
<li><code>git reset --hard HEAD^</code>回退到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>回退到上上一个版本</li>
<li><code>git reset --hard HEAD~100</code>回退到上100个版本</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reflog</code>查看命令历史</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reset --hard HEAD@{n}</code>回退到指定版本</li>
<li><code>git reset --hard ORIG_HEAD</code>回退到上一个版本</li>
<li><code>git reset --hard</code>回退到上一个版本</li>
</ul>
<h3><span id="配置">配置</span></h3>
<ul>
<li><code>git config --global user.name "Your Name"</code>设置用户名</li>
<li>`git config --global user.email "</li>
<li><code>git config --global core.editor "vim"</code>设置编辑器</li>
<li><code>git config --global merge.tool "vimdiff"</code>设置合并工具</li>
<li><code>git config --global color.ui true</code>设置颜色</li>
<li><code>git config --global alias.st status</code>设置别名</li>
<li><code>git config --global alias.co checkout</code>设置别名</li>
<li><code>git config --global alias.ci commit</code>设置别名</li>
<li><code>git config --global alias.br branch</code>设置别名</li>
<li><code>git config --global alias.unstage "reset HEAD"</code>设置别名</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab0</tag>
      </tags>
  </entry>
  <entry>
    <title>hammingDistance</title>
    <url>/2023/05/25/hammingDistance/</url>
    <content><![CDATA[<p>分享一下大作业优化的技巧</p>
<span id="more"></span>
<h1><span id="__uint128_t_"><code>__uint128_t_</code></span></h1>
<p>最近越来越多的协议会定义 16 字节长的整形，gcc 在 4.6 以上版本就可以使用 __int128_t &amp; __uint128_t 了。</p>
<p>但需要注意的是，_uint128_t &amp; __int128_t 仅对 64 位程序才有定义，因此如果编译选项中加入了 -m32，会出现找不到定义的编译错误。</p>
<p>另外 _uint128_t &amp; __int128_t  并非 c/c++ 标准，所以 gcc 目前只支持基本运算符的操作，printf 这些都需要另外实现。</p>
<h1><span id="快速计算汉明距离">快速计算汉明距离</span></h1>
<blockquote>
<p>在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p>
<p>汉明距离是以<strong>理查德・卫斯里・汉明</strong>的名字命名的。在通信传输过程中，累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明距离在包括信息论、编码理论、密码学等领域都有应用。</p>
</blockquote>
<p>对于两个字符串计算汉明距离，那肯定也就只能是逐位比较</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//s1,s2为两个字符串，M为这两个字符串的长度</span>
<span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> l1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l1 <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> l2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么这样肯定是很慢的，如果可以转化两个整型的数，我们很容易想到利用到异或运算。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__uint128_t fingerprint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sumsignedweight <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        fingerprint <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprint <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样可以转换最高128位的两个01字符串。</p>
<p>那么就可以利用<code>^</code>运算来就算汉明距离了,由于异或运算的性质，得到的c的数位上为1说明ab的对应位不相同，反之则相同，那么我们就之需要计算c的二进制表示中数位为1的数目。这里可以按位采取<code>&amp;</code>运算。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        c <span class="token operator">=</span> c <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>布莱恩·克尼根算法</strong></p>
<p>我们先观察如下一个现象：对于任意一个非零的二进制数 <code>a</code>（将其看作无符号数），考虑 <code>a</code> 和 <code>a-1</code> 的关系。由于 <code>a</code> 非零，那么 <code>a</code> 中总有一些位为 <code>1</code>。假设 <code>a</code> 中最低位的 <code>1</code> 处于从右向左数的第 <code>N</code> 位。那么，<code>a</code> 的第 <code>N</code> 位以及第 <code>N</code> 位以后的每一位的值和 <code>a-1</code> 的第 <code>N</code> 位及第 <code>N</code> 位以后的每一位的值均不同。</p>
<p>举个例子就很容易理解了。我们以 8 位数来描述。假设 <code>a=10010000</code>，根据上述描述，从右往左数的第一个 <code>1</code> 出现在第 <code>5</code> 位，那么有 <code>N=5</code>。同时可以计算出 <code>a-1=10001111</code>，可以看到，从第 <code>N</code> 位开始，<code>a</code> 的后缀是 <code>10000</code>，而 <code>a-1</code> 的后缀是 <code>01111</code>。满足上述描述的现象。</p>
<p>进一步地，我们可以发现，如果对 <code>a</code> 和 <code>a-1</code> 进行与操作，就会直接消去位于最后一位，也就是第 <code>N</code> 位的 <code>1</code>。还以上面的 <code>a</code> 为例，<code>a &amp; (a-1)=10000000</code>。可以看到，我们不需要遍历，而是通过一次运算，就可以把 <code>a</code> 中的最后一个 <code>1</code> 消掉。如果我们一直重复这项操作，那么 <code>a</code> 里有多少个 <code>1</code>，我们就仅需要多少次 <code>a &amp; (a-1)</code> 的操作，就能把 <code>a</code> 化为 <code>0</code> 了。而这个操作的次数正是我们所要求的。</p>
<p>那么计算汉明距离就可以改进为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span>__uint128_t b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大作业优化</tag>
      </tags>
  </entry>
  <entry>
    <title>lab0实验报告</title>
    <url>/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab0">lab0</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-01">Thinking 0.1</span></h3>
<ul>
<li>
<p>在前述已初始化的 <code>~/learnGit </code>目录下，创建一个名为 <code>README.txt</code> 的文件。执 行命令 <code>git status &gt; Untracked.txt</code>（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313183854380.png" alt="image-20240313183854380"></p>
</li>
<li>
<p>在<code>README.txt</code>文件中添加任意文件内容，然后使用 <code>add</code> 命令，再执行命令<code> git status &gt; Stage.txt</code>。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184010190.png" alt="image-20240313184010190"></p>
</li>
<li>
<p>提交 <code>README.txt</code>，并在提交说明里写入自己的学号</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184040344.png" alt="image-20240313184040344"></p>
</li>
<li>
<p>执行命令 <code>cat Untracked.txt</code> 和 <code>cat Stage.txt</code>，对比两次运行的结果，体会 <code>README.txt</code> 两次所处位置的不同。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240313184130590.png" alt="image-20240313184130590"></p>
<p>不一样。第一次是在工作区添加了文件，没有提交的暂存区。而第二次提交到了暂存区，只是没有commit到HEAD。而由于都没有进行commit ，因此都没有跟踪，于是提示是为跟踪的文件。</p>
</li>
</ul>
<h3><span id="thinking-02">Thinking 0.2</span></h3>
<ul>
<li>
<p>仔细看看0.10，思考一下箭头中的 add the file 、 stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314115041772.png" alt="image-20240314115041772"></p>
<p>add the file : 对应<code>git add</code></p>
<p>stage the file : 对应<code>git commit</code></p>
<p>commit : 对应<code>git checkout</code></p>
</li>
</ul>
<h3><span id="thinking-03">Thinking 0.3</span></h3>
<ul>
<li>
<p>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314121507355.png" alt="image-20240314121507355"></p>
<blockquote>
<p>使用 <code>git restore print.c</code>即可</p>
</blockquote>
</li>
<li>
<p>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314142825497.png" alt="image-20240314142825497"></p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> restore <span class="token parameter variable">--staged</span> print.c
<span class="token function">git</span> restore print.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
</li>
<li>
<p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314143326431.png" alt="image-20240314143326431"></p>
<blockquote>
<p>使用<code>git restore --staged hello.txt</code>即可</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-04">Thinking 0.4</span></h3>
<ul>
<li>
<p>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件</p>
</li>
<li>
<p>在文件里加入 Testing 1， git add， git commit，提交说明记为 1。</p>
</li>
<li>
<p>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160243954.png" alt="image-20240314160243954"></p>
</li>
<li>
<p>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为3 的哈希值</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160309950.png" alt="image-20240314160309950"></p>
<blockquote>
<p>进行操作后可以看到确实有了三次提交的记录</p>
</blockquote>
</li>
<li>
<p>进行版本回退。执行命令 git reset --hard HEAD^ 后，再执行 git log，观察其变化</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160417333.png" alt="image-20240314160417333"></p>
<blockquote>
<p>此时git log的第一项是2，相当于撤销了第三次提交</p>
</blockquote>
</li>
<li>
<p>找到提交说明为 1 的哈希值，执行命令 git reset --hard <hash> 后，再执行 git log，观察其变化。</hash></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314160510381.png" alt="image-20240314160510381"></p>
<blockquote>
<p>强制撤销到1时候的版本，因此git log只能看到1的提交记录</p>
</blockquote>
</li>
<li>
<p>现在已经回到了旧版本，为了再次回到新版本，执行 git reset --hard <hash>，再执行 git log，观察其变化。</hash></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314161613264.png" alt="image-20240314161613264"></p>
<blockquote>
<p>可以看到又恢复了原样，也就是回到了新版</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-05">Thinking 0.5</span></h3>
<ul>
<li>
<p>执行如下命令，并查看结果</p>
<ul>
<li>echo first</li>
<li>echo second &gt; output.txt</li>
<li>echo third &gt; output.txt</li>
<li>echo forth &gt;&gt; output.txt</li>
</ul>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314161945989.png" alt="image-20240314161945989"></p>
<blockquote>
<p><code>&gt;</code>是覆盖写入</p>
<p><code>&gt;&gt;</code>是追加指令</p>
</blockquote>
</li>
</ul>
<h3><span id="thinking-06">Thinking 0.6</span></h3>
<ul>
<li>
<p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手） . 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo <code>echo Shell Start</code> 效果是否有区别; echo echo $c&gt;file1与 echo <code>echo $c&gt;file1</code> 效果是否有区别</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314162443513.png" alt="image-20240314162443513"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314162939850.png" alt="image-20240314162939850"></p>
<blockquote>
<p>前两条指令的效果是有区别的，而后两条指令的效果是没有区别</p>
<p>加上反引号相当于将反引号的内容重定向作为参数</p>
<p>因此</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Shell Start <span class="token comment"># 标准输出为Shell Start</span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> Shell Start<span class="token variable">`</span></span> <span class="token comment"># 后面指令的标准输出为Shell Start ，作为echo的参数，因此输出还是Shell Start</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token operator">&gt;</span>file1 <span class="token comment"># 相当于是echo指令输出了echo $c,其中$c 为 3，然后重定向到文件中</span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $c<span class="token operator">&gt;</span>file1<span class="token variable">`</span></span><span class="token comment"># 相当于是首先`echo $c&gt;file1` ,将$c的值重定向到了file1中，标准输出为空，将标准输出作为前面的echo的参数，因此输出为空，但是echo会默认添加一个换行符，因此还有一个换行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</blockquote>
</li>
</ul>
<h2><span id="难点分析">难点分析</span></h2>
<h3><span id="cli">CLI</span></h3>
<blockquote>
<p>第一个难点在于如果之前习惯了使用<code>GUI</code>界面，刚开始接触这种命令行界面是不够熟悉的。</p>
<p>依稀记得自己第一次接触<code>ubuntu</code>时探索了好久好久，当时使用的还是图形化界面。</p>
</blockquote>
<p>命令行界面(CLI)是基于文本的界面，可以在其中输入与计算机操作系统交互的命令。CLI在默认Shell的帮助下运行，该Shell位于操作系统和用户之间。</p>
<p>Shell负责处理各种任务，例如命令解析、环境管理和流程执行等。</p>
<p>此外还可以自定义Shell环境。为此，可以设置环境变量、定义别名(较长命令的快捷方式等)以及为自动化或重复任务创建Shell脚本。</p>
<ul>
<li>命令的工作原理</li>
</ul>
<p>在CLI中输入命令是，系统会执行以下步骤：</p>
<ol>
<li>Shell命令行解释器解析输入的命令以了解其结构，并且分离命令名称、选项和参数</li>
<li>Shell在其可用命令列表中查找命令名称。命令名称代表用户希望操作系统执行的操作</li>
<li>Shell搜索系统的PATH变量(系统文件所在的目录列表)，以查找与该命令关联的相应文件</li>
<li>CLI Shell会调用相应的文件，并且传递任何指定的选项和参数作为输入。</li>
<li>操作系统执行所需的操作</li>
<li>此操作可能会生成输出，例如信息性消息、错误消息、请求的数据或操作结果</li>
<li>CLI Shell会显示输出，因此可以看到命令的结果</li>
</ol>
<p>CLI Shell循环运行，等待输入另一条指令。</p>
<h3><span id="linux">Linux</span></h3>
<p>Linux与Windows命令行的一些指令的差异可能会让人感到措手不及。比如<code>bash</code>的指令和<code>powershell</code>以及<code>cmd</code>的指令是有比较大的差异的可能让人感到不熟悉。</p>
<p>同时也不熟练的使用Linux的一些基本操作。包括<code>sudo</code>等</p>
<h3><span id="vim">Vim</span></h3>
<p>由于使用<code>CLI</code>的缘故，我们没有很好的图形化文本编辑器，于是需要使用<code>Vim</code>或者<code>emacs</code>等文本编辑工具。</p>
<p>对于Vim的快捷键以及工作模式不熟悉会带来比较大的难点。</p>
<blockquote>
<p>对此我强烈推荐跟着<code>vimtutor</code>走一遍，基本上可以熟悉大多数的操作，以及基本的几个vim模式</p>
</blockquote>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174337175.png" alt="image-20240314174337175"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174412381.png" alt="image-20240314174412381"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174441142.png" alt="image-20240314174441142"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174505883.png" alt="image-20240314174505883"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174529894.png" alt="image-20240314174529894"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174700133.png" alt="image-20240314174700133"></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314174717116.png" alt="image-20240314174717116"></p>
<p>其实简单的用法也只有</p>
<ul>
<li>输入<code>i</code>进入编辑模式</li>
<li>点击<code>Esa</code>退出编辑模式</li>
<li>输入<code>:w</code>保存，<code>:wq</code>保存并退出</li>
</ul>
<p>基本上可以完成最基本的使用，甚至上下左右可以直接使用箭头键，都不需要使用到<code>hjkl</code>。</p>
<h3><span id="gcc">GCC</span></h3>
<p>对于<code>gcc</code>的基本使用指令不够了解。</p>
<blockquote>
<p><code>tldr</code>是个非常好用的命令用法查询工具，狠狠种草</p>
</blockquote>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314175039544.png" alt="image-20240314175039544"></p>
<p>可以看到<code>gcc</code>的基本用法</p>
<ul>
<li><code>gcc</code>是一个C语言编译器</li>
<li><code>g++</code>是一个C++语言编译器</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：gcc <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span class="token punctuation">..</span>.
选项：
<span class="token parameter variable">-c</span> 仅编译，不链接
<span class="token parameter variable">-o</span> 指定输出文件
<span class="token parameter variable">-E</span> 预处理
<span class="token parameter variable">-S</span> 汇编
<span class="token parameter variable">-l</span> 指定库文件
<span class="token parameter variable">-L</span> 指定库文件路径
<span class="token parameter variable">-I</span> Path/to/head/file 指定头文件路径
<span class="token parameter variable">-D</span> 定义宏
<span class="token parameter variable">-wall</span> 显示所有警告
<span class="token parameter variable">-g</span> 生成调试信息
<span class="token parameter variable">-std</span><span class="token operator">=</span>c99 指定C语言标准
参数：
file.c 源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c  <span class="token comment">#编译hello_world.c文件为hello_world.o目标文件</span>
gcc <span class="token parameter variable">-E</span> hello_world.c  <span class="token comment">#预处理hello_world.c文件</span>
gcc <span class="token parameter variable">-S</span> hello_world.c  <span class="token comment">#汇编hello_world.c文件</span>
gcc <span class="token parameter variable">-o</span> hello_world hello_world.c <span class="token parameter variable">-lm</span>  <span class="token comment">#编译hello_world.c文件为hello_world可执行文件，并链接数学库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时编译多个文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello_world hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world可执行文件</span>
gcc <span class="token parameter variable">-c</span> hello_world.c hello_world2.c  <span class="token comment">#编译hello_world.c和hello_world2.c文件为hello_world.o和hello_world2.o目标文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-o用于指定要生成的结果文件，后面跟的就是结果文件名字。o是output的意思，不是目标的意思。结果文件可能是预处理文件、汇编文件、目标文件或者最终可执行文件。</p>
</blockquote>
<h3><span id="git">Git</span></h3>
<blockquote>
<p>git真是一个非常好用的版本管理工具，发明者太强了没办法！</p>
</blockquote>
<p>相信同学们经过<code>oopre</code>后基本上对于<code>git</code>的基本用法已经了如指掌了，这里包括</p>
<ul>
<li>git add .	添加修改文件到暂存区</li>
<li>git commit -m “message”提交文件到版本库</li>
<li>git push 提交到远程仓库</li>
</ul>
<p>同时还包括一些基本的分支的操作</p>
<ul>
<li>git checkout -b new_branch</li>
</ul>
<p>但是<code>git</code>的更多高阶的用法其实还是不够熟悉，大多数还是需要查询相关资料进行使用。</p>
<p>这里推荐一个可视化git学习网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>
<blockquote>
<p>同时我这里整理了一下一些git 常用的指令</p>
</blockquote>
<p><strong>基本操作</strong></p>
<ul>
<li><code>git init</code>初始化一个仓库</li>
<li><code>git clone</code>克隆一个仓库</li>
<li><code>git add</code>添加文件到暂存区</li>
<li><code>git commit</code>提交文件到仓库</li>
<li><code>git status</code>查看仓库状态</li>
<li><code>git diff</code>查看文件差异</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git reset</code>重置仓库</li>
<li><code>git rm</code>删除文件</li>
<li><code>git mv</code>移动文件</li>
<li><code>git branch</code>查看分支</li>
</ul>
<p><strong>分支操作</strong></p>
<ul>
<li><code>git branch</code>查看分支</li>
<li><code>git checkout</code>切换分支</li>
<li><code>git merge</code>合并分支</li>
<li><code>git rebase</code>变基分支</li>
<li><code>git cherry-pick</code>挑选提交</li>
<li><code>git tag</code>标记提交</li>
<li><code>git stash</code>暂存工作区</li>
<li><code>git fetch</code>获取远程分支</li>
<li><code>git pull</code>拉取远程分支</li>
<li><code>git push</code>推送远程分支</li>
<li><code>git remote</code>管理远程仓库</li>
<li><code>git submodule</code>管理子模块</li>
<li><code>git worktree</code>管理工作树</li>
<li><code>git reflog</code>查看引用日志</li>
<li><code>git bisect</code>二分查找</li>
<li><code>git blame</code>查看文件作者</li>
<li><code>git grep</code>查找文件内容</li>
<li><code>git log</code>查看提交日志</li>
<li><code>git show</code>查看提交详情</li>
</ul>
<p><strong>高级操作</strong></p>
<ul>
<li><code>git filter-branch</code>过滤分支</li>
<li><code>git subcommand</code>子命令</li>
<li><code>git rerere</code>重用冲突解决</li>
<li><code>git gc</code>垃圾回收</li>
<li><code>git fsck</code>检查仓库</li>
<li><code>git prune</code>删除无用对象</li>
</ul>
<p><strong>git 版本回退</strong></p>
<ul>
<li><code>git reset --hard HEAD^</code>回退到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>回退到上上一个版本</li>
<li><code>git reset --hard HEAD~100</code>回退到上100个版本</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reflog</code>查看命令历史</li>
<li><code>git reset --hard commit_id</code>回退到指定版本</li>
<li><code>git reset --hard HEAD@{n}</code>回退到指定版本</li>
<li><code>git reset --hard ORIG_HEAD</code>回退到上一个版本</li>
<li><code>git reset --hard</code>回退到上一个版本</li>
</ul>
<p><strong>配置</strong></p>
<ul>
<li><code>git config --global user.name "Your Name"</code>设置用户名</li>
<li>`git config --global user.email "</li>
<li><code>git config --global core.editor "vim"</code>设置编辑器</li>
<li><code>git config --global merge.tool "vimdiff"</code>设置合并工具</li>
<li><code>git config --global color.ui true</code>设置颜色</li>
<li><code>git config --global alias.st status</code>设置别名</li>
<li><code>git config --global alias.co checkout</code>设置别名</li>
<li><code>git config --global alias.ci commit</code>设置别名</li>
<li><code>git config --global alias.br branch</code>设置别名</li>
<li><code>git config --global alias.unstage "reset HEAD"</code>设置别名</li>
</ul>
<h3><span id="shell脚本">Shell脚本</span></h3>
<blockquote>
<p>这个对于我自己来说也是一个比较大的难点！！主要对于一些特殊字符的用法不了解，其中包括小括号，中括号，大括号，单引号，反引号，双引号</p>
<p>我觉得把这个讲清楚真的非常重要，其次就是了解一些基本的变量、控制结构(条件结构，循环结构)基本上就能够懂得基本的用法了</p>
<p>其中稍微高阶一点，也是shell作为一个脚本型语言的特色就是其参数传递了</p>
<p>同时还有一些比较困难的指令的使用，包括<code>grep awk sed</code></p>
<p>虽然可以通过<code>man</code>来了解大部分</p>
</blockquote>
<h3><span id="shell脚本">shell脚本</span></h3>
<blockquote>
<p>shell脚本是一个用于执行命令的脚本文件</p>
</blockquote>
<ul>
<li>在脚本中在第一行添加<code>#!/bin/bash</code>可以指定脚本使用的shell</li>
<li>运行脚本
<ul>
<li>通过<code>chmod +x script.sh</code>添加执行权限后，<code>./script.sh</code>运行脚本</li>
<li><code>sh script.sh</code>运行脚本</li>
<li><code>./script.sh</code>运行脚本</li>
<li><code>source script.sh</code>运行脚本</li>
</ul>
</li>
<li>参数
<ul>
<li><code>$0</code>脚本名</li>
<li><code>$1</code>第一个参数</li>
<li><code>$2</code>第二个参数</li>
<li><code>$#</code>参数个数</li>
<li><code>$*</code>所有参数，所有参数都是一个字符串</li>
<li><code>$@</code>所有参数，每个参数都是一个独立的字符串</li>
<li><code>$$</code>脚本的进程号</li>
<li><code>$?</code>上一个命令的返回值</li>
<li><code>$!</code>后台运行的最后一个进程的进程号</li>
</ul>
</li>
<li>函数
<ul>
<li><code>function_name(){...}</code>定义函数</li>
<li><code>function_name</code>调用函数</li>
<li><code>return</code>返回值</li>
</ul>
</li>
<li>控制结构
<ul>
<li><code>if...then...fi</code>条件语句</li>
<li><code>case...esac</code>多条件语句</li>
<li><code>for...do...done</code>循环语句</li>
<li><code>while...do...done</code>循环语句</li>
<li><code>until...do...done</code>循环语句</li>
<li><code>break</code>跳出循环</li>
<li><code>continue</code>跳过本次循环</li>
<li><code>exit</code>退出脚本</li>
<li><code>trap</code>捕获信号</li>
<li><code>eval</code>执行命令</li>
<li><code>exec</code>执行命令</li>
<li><code>let</code>执行算术运算</li>
<li><code>select</code>选择语句</li>
<li><code>shift</code>移动参数</li>
<li><code>source</code>执行脚本</li>
<li><code>test</code>测试语句</li>
<li><code>time</code>计时</li>
<li><code>type</code>查找命令</li>
<li><code>ulimit</code>设置资源限制</li>
</ul>
</li>
<li>关系运算符
<ul>
<li><code>-eq</code>等于</li>
<li><code>-ne</code>不等于</li>
<li><code>-gt</code>大于</li>
<li><code>-lt</code>小于</li>
<li><code>-ge</code>大于等于</li>
<li><code>-le</code>小于等于</li>
<li><code>=</code>字符串相等</li>
<li><code>!=</code>字符串不相等</li>
<li><code>-z</code>字符串为空</li>
<li><code>-n</code>字符串不为空</li>
<li><code>-e</code>文件存在</li>
<li><code>-f</code>文件存在且是普通文件</li>
<li><code>-d</code>文件存在且是目录</li>
<li><code>-s</code>文件存在且不为空</li>
<li><code>-r</code>文件存在且可读</li>
</ul>
</li>
</ul>
<p><strong>grep</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180342701.png" alt="image-20240314180342701"></p>
<p><strong>awk</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180412634.png" alt="image-20240314180412634"></p>
<p><strong>sed</strong></p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240314180442171.png" alt="image-20240314180442171"></p>
<h2><span id="实验体会">实验体会</span></h2>
<p>我觉得通过本次实验自己对于一些工具包括<code>vim tmux</code>更加熟悉了，同时对于<code>shell</code>脚本的撰写也更加熟悉了。学到了很多东西！！！</p>
<p>当然还有一点体会就是对于命令的细节还是要更加了解一点，比如<code>echo</code>会自动加入换行符，真的被狠狠背刺了啊啊啊啊！！</p>
<p>前面没有提到，这里分享一下自己学习<code>tmux</code>的经验</p>
<blockquote>
<p>tmux is terminal multiplexer</p>
</blockquote>
<blockquote>
<p>虽然你可以打开多个终端，但是tmux帅啊！！</p>
</blockquote>
<p>创建会话 <code>creating tmux sessions</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样会打开一个新的页面也该窗口</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144341753.png" alt="image-20240308144341753"></p>
<p>退出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>增加一个命名：</p>
<pre class="line-numbers language-none"><code class="language-none">tmux new -s test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144443438.png" alt="image-20240308144443438"></p>
<p>创建新的tmux窗口<code>creating new tmux windows</code></p>
<pre class="line-numbers language-none"><code class="language-none">Ctrl-b c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>Ctrl-b</code>在tmux里面相当于是一个命令前缀</p>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308144816204.png" alt="image-20240308144816204"></p>
<p>在两个tmux窗口之间切换 s<code>witching between tmux windows</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样会顺序遍历已经创建的窗口</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>你可以注意到这个窗口的名字叫做bash，是因为目前是正在运行进程，如果你某一个窗口运行<code>htop</code>，那么那个窗口的名字就是<code>htop</code></p>
<p>如果你想要设置一个不会改变的窗口命名</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b ,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150121933.png" alt="image-20240308150121933"></p>
<p>离开一个会话<code>detaching from a tmux session</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>连接一个会话<code>attaching to a tmus session</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要重新新建一个任务可以</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b new <span class="token parameter variable">-s</span> coding
// 也就是前面的新建一个session的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150456377.png" alt="image-20240308150456377"></p>
<p>列举所有tmux会话<code>listing tmux sessions</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果想要连接某一个<code>session</code>，可以</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmux a <span class="token parameter variable">-t</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150641122.png" alt="image-20240308150641122"></p>
<p>可以再几个<code>session</code>之间切换</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150751219.png" alt="image-20240308150751219"></p>
<p>窗格操作</p>
<p>划分窗格</p>
<p><code>tmux split-window</code>命令用来划分窗格。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 划分上下两个窗格</span>
$ tmux split-window

<span class="token comment"># 划分左右两个窗格</span>
$ tmux split-window <span class="token parameter variable">-h</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>移动光标</p>
<p><code>tmux select-pane</code>命令用来移动光标位置。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 光标切换到上方窗格</span>
$ tmux select-pane <span class="token parameter variable">-U</span>

<span class="token comment"># 光标切换到下方窗格</span>
$ tmux select-pane <span class="token parameter variable">-D</span>

<span class="token comment"># 光标切换到左边窗格</span>
$ tmux select-pane <span class="token parameter variable">-L</span>

<span class="token comment"># 光标切换到右边窗格</span>
$ tmux select-pane <span class="token parameter variable">-R</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>交换窗格位置</p>
<p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>
<blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前窗格上移</span>
$ tmux swap-pane <span class="token parameter variable">-U</span>

<span class="token comment"># 当前窗格下移</span>
$ tmux swap-pane <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>窗格快捷键</p>
<p>下面是一些窗格操作的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b %</code>：划分左右两个窗格。</li>
<li><code>Ctrl+b "</code>：划分上下两个窗格。</li>
<li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li>
<li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li>
<li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li>
<li><code>Ctrl+b {</code>：当前窗格与上一个窗格交换位置。</li>
<li><code>Ctrl+b }</code>：当前窗格与下一个窗格交换位置。</li>
<li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>
<li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>
<li><code>Ctrl+b x</code>：关闭当前窗格。</li>
<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>
<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>
<li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li>
<li><code>Ctrl+b q</code>：显示窗格编号。</li>
</ul>
</blockquote>
<p>获取帮助<code>getting help with tmux</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl-b ?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> tmux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240308150851773.png" alt="image-20240308150851773"></p>
<p><strong>reference</strong></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p>
<p><a href="https://www.linuxtrainingacademy.com/tmux-tutorial/">https://www.linuxtrainingacademy.com/tmux-tutorial/</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab0</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab2实验报告</title>
    <url>/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab2实验报告">Lab2实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-21">Thinking 2.1</span></h3>
<blockquote>
<p>请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？ MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</p>
</blockquote>
<p>都是<strong>虚拟地址</strong>。c程序是虚拟地址比较显然，一方面是因为需要链接许多文件，在地址空间重新排列。而mips中的地址也是虚拟地址主要是因为，我们在计算机组成原理中自己搭的cpu其实是没有mmu这个内存管理单元的，也就没有虚拟内存与物理内存的转换，实际上这里我们的<strong>4Kc CPU是有MMU的</strong>，因此也是虚拟地址。</p>
<h3><span id="thinking-22">Thinking 2.2</span></h3>
<blockquote>
<p>请思考下述两个问题：</p>
<ul>
<li>从可重用性的角度，阐述用宏来实现链表的好处。</li>
<li>查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li>
</ul>
</blockquote>
<p>c语言没有模板这一语法功能，于是使用宏可以使得链表可以实现不同的类型的链表，只需要将相应的类型结构作为参数传入宏函数即可。</p>
<p>比如从定义一个链表的角度说，使用宏是这样的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span>                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>                                  </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> le_next<span class="token punctuation">;</span> </span><span class="token comment">/* next element */</span>                      <span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span><span class="token operator">*</span> le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直接可以选择相应的name和type，当定义另一个链表时修改其中的name和type即可。同时，这样我们还能够实现后面的可复用性高的宏函数，比如链表的遍历，插入等。</p>
<ul>
<li>
<p>甚至让我在想会不会c++的模板用的也是类似的方法了。</p>
<ul>
<li>
<blockquote>
<p>简单查了一下：总的来说，C++ 模板的底层实现是通过编译器进行的，包括模板的实例化和代码的生成。这个过程是在编译期完成的，可以提高程序的性能。</p>
</blockquote>
</li>
<li>
<p>虽然这个说法像是啥也没说（</p>
</li>
</ul>
</li>
<li>
<p>单向链表：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SLLIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> 		  </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>sle_next<span class="token punctuation">;</span>		  </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于插入，只能够方便的实现在某一元素之后插入，删除操作和在某一项之前插入都需要从头开始遍历列表。</p>
</li>
<li>
<p>循环链表：</p>
<p>这里的循环链表的定义和单向链表基本一致，只是多了一个将链表最后的元素指向了头指针。因此对于删除操作，在某一项之前插入，在某一项之后插入这几种操作都和单向链表相同，不过对于在尾部插入可以直接进行，是o(1)的复杂度</p>
</li>
<li>
<p>双向链表：</p>
<p>双向链表的删除操作、在某一项之前插入、在某一项之后插入都可以通过o(1)的时间开销搞定。但是比起循环链表在尾部插入还是需要进行遍历。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>链表类型</th>
<th>在某个位置操作（删除，插入）</th>
<th>删除某个元素</th>
<th>在某个元素前插入</th>
<th>在某个元素后插入</th>
</tr>
</thead>
<tbody>
<tr>
<td>单向链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>循环链表</td>
<td>O(n)，当在尾部插入时为O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="thinking-23">Thinking 2.3</span></h3>
<blockquote>
<p>请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">A<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">B<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">C<span class="token operator">:</span>
<span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>结合</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_HEAD</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span>                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>                                  </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span> </span><span class="token comment">/* first element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>和</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LIST_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span> le_next<span class="token punctuation">;</span> </span><span class="token comment">/* next element */</span>                      <span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span><span class="token operator">*</span><span class="token operator">*</span> le_prev<span class="token punctuation">;</span> </span><span class="token comment">/* address of previous next element */</span> <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然可得。</p>
<h3><span id="thinking-24">Thinking 2.4</span></h3>
<blockquote>
<p>请思考下面两个问题：</p>
<ul>
<li>
<p>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</p>
</li>
<li>
<p>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’sManual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc</p>
<p>中可容纳不同的地址空间的最大数量。</p>
</li>
</ul>
</blockquote>
<p>TLB事实上构建了一个映射$&lt;VPN, ASID&gt; \stackrel{TLB}{\longrightarrow}&lt;PFN,N,D,V,G&gt;$</p>
<p>其中的ASID是用于区分不同的地址空间，，同一虚拟地址在不同地址空间中通常映射到不同的物理地址。</p>
<p>操作系统给每一个进程分配一个页表，每个页表都有自己的虚拟地址空间，而同一地址空间通常映射到不同的物理地址，如果没有ASID来区分当前虚拟地址是在哪个进程中使用，则可能将该虚拟地址映射到错误的物理地址。</p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411195402243.png" alt="image-20240411195402243"></p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411195351085.png" alt="image-20240411195351085"></p>
<p>ASID有八位，因此可以容纳不同地址空间的数量为256个。</p>
<h3><span id="thinking-25">Thinking 2.5</span></h3>
<blockquote>
<p>请回答下述三个问题：</p>
<ul>
<li>tlb_invalidate 和 tlb_out 的调用关系？</li>
<li>请用一句话概括 tlb_invalidate 的作用。</li>
<li>逐行解释 tlb_out 中的汇编代码。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tlb_invalidate</span><span class="token punctuation">(</span>u_int asid<span class="token punctuation">,</span> u_long va<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">tlb_out</span><span class="token punctuation">(</span><span class="token punctuation">(</span>va <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token function">GENMASK</span><span class="token punctuation">(</span>PGSHIFT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>asid <span class="token operator">&amp;</span> <span class="token punctuation">(</span>NASID <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>课件<code>tlb_invalidate</code>在调用<code>tlb_out</code></p>
<ul>
<li><code>tlb_invalidate</code>作用：
<ul>
<li>实现删除特定虚拟地址在 TLB中的旧表项</li>
</ul>
</li>
</ul>
<p>​</p>
<pre class="line-numbers language-ass" data-language="ass"><code class="language-ass">LEAF(tlb_out)								# 叶子函数
.set noreorder								# 不雅重新排列指令顺序
	mfc0    t0, CP0_ENTRYHI					# 从CP0寄存器CP0_ENTRYHI中的值读取到t0种
	mtc0    a0, CP0_ENTRYHI					# 将a0的值保存到CP0寄存器CP0_ENTRYHI中
	nop
	/* Step 1: Use 'tlbp' to probe TLB entry */
	/* Exercise 2.8: Your code here. (1/2) */
	tlbp									# 查询虚拟地址的物理地址映射
	nop
	/* Step 2: Fetch the probe result from CP0.Index */
	mfc0    t1, CP0_INDEX					# 将CP0寄存器CP0_INDEX寄存器中的值读取到t1中
.set reorder								# 指示汇编器重新排列指令顺序
	bltz    t1, NO_SUCH_ENTRY				# 跳转，如果t1小于0,则跳转到NO_SUCH_ENTRY处
.set noreorder
	mtc0    zero, CP0_ENTRYHI				# 将CP0寄存器CP0_ENTRYHI清空
	mtc0    zero, CP0_ENTRYLO0				# 将CP0寄存器CP0_ENTRYLO0清空
	mtc0    zero, CP0_ENTRYLO1				# 将CP0寄存器CP0_ENTRYLO1清空
	nop
	/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */
	/* Exercise 2.8: Your code here. (2/2) */
	tlbwi									# 将CP0.ENTRYHI/LO 写入tlb的CP0。INDEX处
.set reorder

NO_SUCH_ENTRY:
	mtc0    t0, CP0_ENTRYHI					# 将t0重新赋值到CP0寄存器CP0_ENTRYHI中
	j       ra
END(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="thinking-26">Thinking 2.6</span></h3>
<blockquote>
<p>从下述三个问题中任选其一回答：</p>
<ul>
<li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别</li>
</ul>
</blockquote>
<p>Q1:</p>
<p>两者主要有以下三点区别：</p>
<ul>
<li>
<p>内存管理机制上，MIPS为页式管理系统，x86位段页式</p>
</li>
<li>
<p>TLB不命中的处理时，MIPS会触发TLB Refill异常，内核的<code>tlb_refiil_handler</code>会以<code>pgd_current</code>为当前进程的<code>PG0</code>基址，索引获得转换失败的虚拟地址对应的<code>PTE</code>，并将其填入TLB，然后CPU用刚刚转换失败的虚拟地址重新访问TLB</p>
<p>x86在TLB不命中时，有硬件MMU以<code>CR3</code>为当前进程的<code>PG0</code>基址，索引获得PFN后，直接输出PA。同时MMU填充TLB以加快下次转换的速度。</p>
</li>
<li>
<p>转换失败的虚拟地址，MIPS使用<code>BadVAddr</code>寄存器存放，x86使用<code>CR2</code>存放</p>
</li>
</ul>
<p>Q2：</p>
<ul>
<li>TLB 条目格式上，MIPS 的 TLB 条目格式可能会有所不同，具体取决于 MIPS 处理器的架构。而 RISC-V 则有一种统一的页表格式，称为 Sv39，用于支持 39 位的虚拟地址空间。</li>
<li>异常处理机制上，MIPS 和 RISC-V 在异常处理机制上有一些差异。MIPS 使用异常号来区分不同类型的异常，而 RISC-V 使用不同的异常代码来区分异常类型。</li>
<li>特权模式上，RISC-V 的特权模式相对于 MIPS 更加灵活，支持更多的特权级别，例如 U 模式（用户模式）、S 模式（监管者模式）、M 模式（机器模式）等。这使得 RISC-V 能够更好地支持多任务操作系统和虚拟化环境。</li>
</ul>
<p>Q3：</p>
<ul>
<li><strong>页表结构</strong>：LoongArch 使用了三级页表结构，而 MIPS 在某些情况下可能使用两级页表结构。这使得 LoongArch 能够更灵活地管理大内存空间。</li>
<li><strong>TLB 缓存</strong>：LoongArch 的 TLB 结构可能与 MIPS 略有不同，具体取决于 LoongArch 处理器的架构。不过，两者都利用 TLB 来加速地址转换。</li>
<li><strong>特权模式</strong>：LoongArch 可能支持更多的特权模式，例如用户模式、管理模式、超级模式等。这使得 LoongArch 能够更好地支持不同级别的特权操作。</li>
<li><strong>异常处理</strong>：LoongArch 和 MIPS 在异常处理机制上可能有一些差异，例如异常号的定义和异常处理程序的调用方式。</li>
</ul>
<h2><span id="难点分析">难点分析</span></h2>
<p>我觉得本次作业的难点主要在于<code>List</code>数据结构的理解和<code>Page</code>存储结构的理解。</p>
<h3><span id="数据结构与存储结构">数据结构与存储结构</span></h3>
<p>前面已经提到Page_list的结构为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page_list</span><span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> pp_link<span class="token punctuation">;</span>
		u_short pp_ref<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token operator">*</span> lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个给我带来了比较大的困扰，这到底是个什么结构。</p>
<ul>
<li>LIST又是啥呢？这也好难，让我感觉自己的数据结构又是白学的<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
</ul>
<p>首先要坚信这个List就是我们学的那个链表，是一个双向链表。</p>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240411203312741.png" alt="image-20240411203312741"></p>
<p>这里的链表是有一个专门的头指针的，在ds中也有地方会这么用。(有一些好像还会有一些头发指针，头指针的前一个元素)这几个都是让链表的处理更加方便，也可以认为是大家认为链表的比较优雅的实现方式。</p>
<p>头指针：</p>
<p><code>LIST_HEAD(name, type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上是定义了一个结构体，给这个结构提一个名字比如head，实际上就是<code>LIST_HEAD(name, int) head;</code></p>
<p>宏替换后实际上就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">int</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么相应的一些与链表头指针的一些操作：</p>
<p><code>LIST_HEAD_INITIALIZER(head)</code></p>
<p>具体用法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_HRAD</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
head <span class="token operator">=</span> LIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于每个结点的指针部分实际上就是</p>
<p><code>LIST_ENTRY(type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里le_next可以理解，但是这个le_prev呢，这个给的注释也很奇怪，<code>address of previous next element</code>。这么来看，实际上就是将每个next指针作为一个element，那么prev就是前一个元素的这个指针。也就是一个<strong>指向指向自己的指针的指针</strong>。</p>
<p>这样并不是双向链表那种，双向链表是多了一个指向前一个结点的大结点的地址的指针，也就是说可以通过这个指针直接访问前一个结点。而这个le_prev仅仅只是前一个元素的next这个元素的地址。</p>
<blockquote>
<p>那么这里为什么要这么样呢，我们应该从功能的角度来理解，我们遍历页表是不需要从后往前的，因此理论上使用单向链表即可，但是我们又有很多对于某个元素的删除和前后插入元素的操作，使用这种类似的双向链表的结构，可以更加方便的进行删除和插入的操作。</p>
</blockquote>
<p>那么到这里其实就懂了，一个结点分为data和field。filed实际上就是优化版的next，包括next和prev两个元素。data的数据格式为struct type, next是struct type*，prev是struct type**;</p>
<p>那么我们简单总结一下这个链表的结构。首先是head，head是个头指针，里面包含有第一个元素的指针。每个结点包含data和field两个部分。</p>
<p>就可以很好理解<code>LIST_NEXT(elm, field)</code> 这个宏函数了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> field<span class="token punctuation">.</span>le_next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看一下<code>LIST_FOREACH(var, head, field)</code>这个宏定义，这里给出了一种遍历链表的方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来实现<code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，也即是在listelm前面添加elm。</p>
<p>一般的双向链表有下面这个就够了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> listelm<span class="token punctuation">;</span>
<span class="token comment">// listelm-&gt;prev = elm; 类似这种的操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是由于添加了prev，需要更新elm和listelm的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> elm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里*的运算级是高于-&gt;的。</p>
<p>于是完成<code>LIST_INSERT_AFTER(listelm, elm, field)</code>就很简单了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> elm<span class="token punctuation">;</span>
elm<span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="tlb原理与重填策略">TLB原理与重填策略</span></h3>
<p>首先要分清这里是包括物理内存管理和虚拟内存管理两个东西的。</p>
<p>物理内存就是一个内核链表，地址空间也是连续的。</p>
<p>虚拟内存则是需要通过转化到物理内存来访问的。</p>
<p><strong>虚拟地址映射到物理地址</strong></p>
<ul>
<li>虚拟地址0x80000000-0x9fffffff，kseg0，将最高位置0得到物理地址，通过cache访问。这一部分<strong>用于存放内核代码与数据</strong>。</li>
<li>虚拟地址0xa0000000-0xbfffffff，kseg1，将最高3位置0得到物理地址，不通过cache访问。这一部分可以<strong>用于访问外设</strong>。</li>
<li>虚拟地址0x00000000-0x7fffffff，kuseg，通过TLB转换为物理地址，然后通过cache访存。这一部分用于<strong>存放用户程序代码与数据</strong></li>
</ul>
<p><img src="/2024/04/24/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240406230222403.png" alt="image-20240406230222403"></p>
<p>其中只有kuseg部分需要用到TLB。</p>
<p>那么TLB本身是一个两级页表结构(MIPS中是的)。第一级是页目录Page Directory，第二级是页表Page Table。</p>
<p>这么看不容易理解。</p>
<p>一级页表项是31-22位，二级页表项是21-12位。11-0位则是页内偏移量。我们在TLB转化过程中只是为了确定是哪个物理页，因此我们不关注页内偏移量，照搬即可。</p>
<ul>
<li>首先通过查一级页表，得到二级页表中的首地址</li>
<li>然后通过二级页表得到虚拟地址对应的物理地址</li>
</ul>
<p>具体的实现还用到了很多的权限位。但这是代码上的实现了，和原理解耦开来。</p>
<h2><span id="实验体会">实验体会</span></h2>
<p>lab2真的是很难的一节，首先的List这个数据结构让我感到十分困惑，一度不能理解le_prev这个结构，我刚开始甚至认为这个无法直接访问前一个结点而认为这是一个单向页表，但是其后的页表插入删除操作却又不太合理了，后来一步步看一步步记录才看懂qaq。</p>
<p>确实是收获满满！<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab2</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab1笔记</title>
    <url>/2024/04/24/os-lab1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>os-lab1实验报告</title>
    <url>/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab1实验报告">Lab1实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-11">Thinking 1.1</span></h3>
<blockquote>
<p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具 链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数 的含义</p>
</blockquote>
<p>首先是gcc的几个重要的选项</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-E</span>                       Preprocess only<span class="token punctuation">;</span> <span class="token keyword">do</span> not compile, assemble or link.      
<span class="token parameter variable">-S</span>                       Compile only<span class="token punctuation">;</span> <span class="token keyword">do</span> not assemble or link.                   
<span class="token parameter variable">-c</span>                       Compile and assemble, but <span class="token keyword">do</span> not link.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>objdump的几个重要的选项</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-D, --disassemble-all    Display assembler contents of all sections
	 <span class="token parameter variable">--disassemble</span><span class="token operator">=</span><span class="token operator">&lt;</span>sym<span class="token operator">&gt;</span>  Display assembler contents from <span class="token operator">&lt;</span>sym<span class="token operator">&gt;</span>
-S,  <span class="token parameter variable">--source</span>             Intermix <span class="token builtin class-name">source</span> code with disassembly
	 --source-comment<span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span>txt<span class="token operator">&gt;</span><span class="token punctuation">]</span> Prefix lines of <span class="token builtin class-name">source</span> code with <span class="token operator">&lt;</span>txt<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327155605072.png" alt="image-20240327155605072"></p>
<p>使用不同的gcc，如使用MIPS交叉编译工具链的gcc，得到的文件类型是不一样的</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161230861.png" alt="image-20240327161230861"></p>
<p>那么对比具体内容呢，我们分别使用只进行预处理后的文本进行比较</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161546394-1711527348582-1.png" alt="image-20240327161546394"></p>
<p>发现不相同的地方还是很多的。</p>
<p>在进行编译后发现得到的文本类型也不相同</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327161721152.png" alt="image-20240327161721152"></p>
<p>那么显然使用diff后区别会非常大，毕竟一个x86，一个mips</p>
<p>这里有意思的一点是</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327162651923.png" alt="image-20240327162651923"></p>
<p>如果我使用x86的objdump去反汇编用交叉编译器得到的文件会报错。</p>
<blockquote>
<p>这里我也有点不懂，objdump不是支持多个架构吗，难道说在什么架构确定了objdump对硬件的接口，只是说objdump有不同硬件架构的的接口吗.</p>
<blockquote>
<p>因为不支持mips，樂</p>
</blockquote>
</blockquote>
<h3><span id="thinking-12">Thinking 1.2</span></h3>
<blockquote>
<p>思考下述问题：</p>
<ul>
<li>
<p>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文 件。</p>
</li>
<li>
<p>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚 才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</p>
</li>
</ul>
</blockquote>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327163822161.png" alt="image-20240327163822161"></p>
<p>关于为什么不能够解析自己，首先我们查看一下<code>readel</code>f和<code>hello</code>的文件头</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git@22373058 ~/2/t/readelf <span class="token punctuation">(</span>lab2<span class="token punctuation">)</span><span class="token operator">&gt;</span> readelf <span class="token parameter variable">-h</span> readelf
ELF 头：
  Magic：   7f <span class="token number">45</span> 4c <span class="token number">46</span> 02 01 01 00 00 00 00 00 00 00 00 00
  类别:                              ELF64
  数据:                              <span class="token number">2</span> 补码，小端序 <span class="token punctuation">(</span>little endian<span class="token punctuation">)</span>
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - System V
  ABI 版本:                          <span class="token number">0</span>
  类型:                              DYN <span class="token punctuation">(</span>Position-Independent Executable <span class="token function">file</span><span class="token punctuation">)</span>
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x1180
  程序头起点：          <span class="token number">64</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">14488</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  标志：             0x0
  Size of this header:               <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">56</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">13</span>
  Size of section headers:           <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">31</span>
  Section header string table index: <span class="token number">30</span>
git@22373058 ~/2/t/readelf <span class="token punctuation">(</span>lab2<span class="token punctuation">)</span><span class="token operator">&gt;</span> readelf <span class="token parameter variable">-h</span> hello
ELF 头：
  Magic：   7f <span class="token number">45</span> 4c <span class="token number">46</span> 01 01 01 03 00 00 00 00 00 00 00 00
  类别:                              ELF32
  数据:                              <span class="token number">2</span> 补码，小端序 <span class="token punctuation">(</span>little endian<span class="token punctuation">)</span>
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - GNU
  ABI 版本:                          <span class="token number">0</span>
  类型:                              EXEC <span class="token punctuation">(</span>可执行文件<span class="token punctuation">)</span>
  系统架构:                          Intel <span class="token number">80386</span>
  版本:                              0x1
  入口点地址：               0x8049600
  程序头起点：          <span class="token number">52</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">746280</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  标志：             0x0
  Size of this header:               <span class="token number">52</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">32</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">8</span>
  Size of section headers:           <span class="token number">40</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">35</span>
  Section header string table index: <span class="token number">34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到<code>readelf</code>的ELF类别是ELF64，而<code>hello</code>的ELF的类别是ELF32。可以知道我们的<code>readelf</code>只能解析ELF32类别的ELF文件，我们可以自己手动得到一个ELF32的<code>myReadelf</code>使得可以解析自身</p>
<p>在Makefile中做如下修改</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">myReadelf</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c main.c -m32
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c readelf.c -m32
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> main.o readelf.o -o <span class="token variable">$@</span> -m32 -static -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现可以解析自身了~</p>
<p><img src="/2024/04/24/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240327173712186.png" alt="image-20240327173712186"></p>
<h3><span id="thinking-13">Thinking 1.3</span></h3>
<blockquote>
<p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）</p>
</blockquote>
<p>操作系统设计人员一般会将硬件初始化的相关工作作为“bootloader”程序放在非易失存储器中，而将操作系统内核放在磁盘中。从操作系统的角度来看，bootloader是为了正确找到内核并加载执行。同时这个启动过程分为两个阶段。</p>
<p>在stage1中，进行初始化硬件设备，同时加载stage2到RAM空间，并且设置堆栈最后跳转到stage2的入口函数。</p>
<p>在stage2中，初始化这一阶段需要用到的硬件设备以及其他功能，然后将内核镜像从存储器读到RAM中，并为内核设置启动参数，最后将CPU指令寄存器的内容设置为内核入口函数的地址，并将控制权转交给系统内核，这时就已经保证了内核地址被正确跳转到。</p>
<p>在我们的qemu中，在stage2阶段：</p>
<p>由 Linker Script (控制加载地址)完成。Linker Script 可以控制各节的加载地址。我们在 kernel.lds 中设置了程序各个生成地址：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SECTIONS <span class="token punctuation">{</span>
	<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80010000<span class="token punctuation">;</span>
	.text <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.text<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	.data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.data<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	.bss <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.bss<span class="token punctuation">)</span> <span class="token punctuation">}</span>
	bss_end <span class="token operator">=</span> <span class="token builtin class-name">.</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80400000<span class="token punctuation">;</span>
	end <span class="token operator">=</span> <span class="token builtin class-name">.</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这个控制，生成的程序各个 section 的位置就被调整到了我们所指定的地址上。 segment 是由 section组合而成的，section 的地址被调整了，那么最终 segment 的地址也会相应地被调整。 至此，我们通过 lds 文件控制各段(包括内核)被加载到我们预期的位置。与此同时kernel.lds规定了 ENTRY(_start) ，即把内核入口定为 _start 这个函数。</p>
<p>我们通过对 /init/start.S 中 _start 函数的设置，就可以正确的跳转至 mips_init 函数:</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">EXPORT(_start)
.set at
.set reorder
	mtc0    zero, CP0_STATUS
	li	sp, 0x80400000
	jal mips_init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="难点分析">难点分析</span></h2>
<h3><span id="qemu模拟器">QEMU模拟器</span></h3>
<p>qemu（Quick Emulator）是一个硬件模拟器，刚开始接触的话我感觉还是会不太懂得这个的运行流程。</p>
<p>通过观察Makefile文件可以看到一些QUME的功劳</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">QEMU_FLAGS              <span class="token operator">+=</span> -cpu 4Kc -m 64 -nographic -M malta \<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到QUME为我们指定了使用的使用的CPU模型为<code>MIPS 4Kc</code>，同时<code>-m 64</code>指定了虚拟机内存为64MB，<code>-nographic</code>指定QEMU以无图形界面模式运行，<code>-M malta</code>指定QEMU使用"MIPS Malta"模拟器模型，这是一种MIPS架构的开发板。</p>
<p>同时与QEMU一起出现的交叉编译也很有意思</p>
<p>比如<code>mips-kubyx-gnu-gcc</code>与<code>gcc</code>的区别，不同架构的编译器的使用还是很有意思的。</p>
<p><a href="https://github.com/qemu/qemu">QUME源代码</a></p>
<h3><span id="操作系统内核启动流程">操作系统内核启动流程</span></h3>
<p>这里主要是指操作系统引导内核启动的过程。</p>
<p>首先计算机的存储部分主要包括ROM和RAM，RAM是易失存储器，刚开始RAM应该是空的，而ROM的内存又是有限的，因此操作系统需要在ROM中找到将内核部分的</p>
<p>这个过程的主要目的是将内核定位并加载到主存中，那么操作系统适配在不同的架构中启动的过程主要包括以下几个流程。</p>
<ol>
<li>打开电源，加载BIOS</li>
<li>BIOS进行开机自检，其中启动程序会对计算机的硬件进行初始化，同时会对计算机的主存、磁盘、I/O设备进行检查。</li>
<li>加载引导程序。BIOS或这UEFI会根据Boot Sequence的内容，同时将控制权交给启动顺序第一位的存储设备(这个如果本机装了多个操作系统比较明显，在我们进入BIOS后可以选择进入哪个操作系统，实际上就是CPU知道有哪几个操作系统，然后选择操作系统并将相应位置的扇区内容进行加载，根据 老师上课说的一切管理都需要数据结构可以推断出，CPU中有某个数据结构专门存储了操作系统类型、扇区地址和扇区大小等数据)，然后CPU将存储设备中的引导扇区的内容加载到内存中。</li>
<li>加载MBR，CPU可以知道在哪个主分区寻找操作系统。</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含活动分区和非活动分区，找到活动分区后，加载活动分区并将控制权交给活动分区。</li>
<li>加载PBR，读取活动分区的第一个分区（分区引导记录PBR），寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）</li>
<li>加载启动管理器</li>
<li>加载操作系统。将操作系统的初始化程序加载到内存中执行。</li>
</ol>
<blockquote>
<p>之前装debian的时候经常会遇到找不到系统的问题，推断是第3步出现了问题，BIOS找不到磁盘中debian的启动分区在哪里。</p>
</blockquote>
<h3><span id="linker-script">Linker Script</span></h3>
<blockquote>
<p>这里是因为感觉对于Linker Script的语法不够理解</p>
</blockquote>
<p>链接器脚本实际上就是是一个文本文件，使用链接器脚本编写一系列的命令，每个命令要么是一个关键字，后面可能跟有参数，要么是对符号的赋值。</p>
<ul>
<li>
<p>一个简单的Linker Script脚本</p>
<p>实际上大多数的链接器脚本都是相对比较简单的，最简单脚本通常为</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SECTIONS
<span class="token punctuation">{</span>
<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x10000<span class="token punctuation">;</span>
.text <span class="token builtin class-name">:</span> <span class="token punctuation">{</span>*<span class="token punctuation">(</span>.text<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token builtin class-name">.</span> <span class="token operator">=</span> 0x80000000<span class="token punctuation">;</span>
.data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span>*<span class="token punctuation">(</span>.data<span class="token punctuation">)</span><span class="token punctuation">}</span>
.bss :<span class="token punctuation">{</span>*<span class="token punctuation">(</span>.bss<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而其他复杂的语法包括<br>
一些简单的赋值符号</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">symbol <span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">+=</span> expression <span class="token punctuation">;</span>
symbol -<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol *<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol /<span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&lt;&lt;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">&amp;</span><span class="token operator">=</span> expression <span class="token punctuation">;</span>
symbol <span class="token operator">|</span><span class="token operator">=</span> expression <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>给出另外一个例子</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">floating_point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
SECTIONS
<span class="token punctuation">{</span>
  .text:
    <span class="token punctuation">{</span>
      *<span class="token punctuation">(</span>.text<span class="token punctuation">)</span>
      .etext <span class="token operator">=</span> <span class="token builtin class-name">.</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _bdata <span class="token operator">=</span> <span class="token punctuation">(</span>. + <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> ~ <span class="token number">4</span><span class="token punctuation">;</span>
    .data <span class="token builtin class-name">:</span> <span class="token punctuation">{</span> *<span class="token punctuation">(</span>.data<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的<code>_bdata</code>是一个符号，它的值是当前位置加3，然后向下取整4的结果。</p>
<h3><span id="printk">printk</span></h3>
<p>在本次实验中我们实现了一个简单的<code>printk</code>函数，其中很多关于C语言的一些用法还是很有难度的。</p>
<p>首先是梳理一下代码架构</p>
<ul>
<li>最外层是printk()函数，其用法与我们通常使用的printf()函数有很大的相似性，可能没有那么智能的正则匹配等功能</li>
<li>printk()函数中的主要功能由vprintfmt(outputk, NULL, fmt, ap)函数实现，其中outputk是一个函数指针，fmt是一个字符串，ap是一个va_list类型的变量，这个函数的主要功能是将fmt中的内容输出到串口</li>
<li>vprintfmt()中主要部分在解析fmt这个字符串，解析到%后判断其后面的内容，然后直接调用如num = va_arg(ap, int)来得到参数，然后根据读取到的%后的内容将相应的结果进行格式化输出，这里调用了三个主要的函数，分别是print_char(),print_str(),print_num()，这里print_char和print_str实质上就是直接调用out(data,&amp;c,1)或者out(data, s, len)，但是由于考虑到左对齐右对齐等需要补充一些空格的情况，因此这里的print_char和print_str函数还是有一些复杂的。而print_num()可以看到是直接将数字转化为字符串，然后调用out(data,buf,len)函数输出。</li>
</ul>
<p>其中va_list和va_start,va_end这几个的含义也是很难理解的一部分，这里简单的说一下，va_list是一个指向参数的指针，va_start是将这个指针指向第一个参数，va_end是将这个指针指向最后一个参数。</p>
<ul>
<li>va_list 变长参数表的变量类型</li>
<li>va_start(va_list, ap ,lastarg)用于初始化边长参数表的宏</li>
<li>va_arg(va_list, type)用于获取变长参数表中的参数。这里的类型有很多种，比如int，double，char等</li>
<li>va_end(va_list,ap) 结束使用边长参数表的宏</li>
</ul>
<blockquote>
<p>但是由于这个不太了解，还是太难啦！</p>
</blockquote>
<h2><span id="实验体会">实验体会</span></h2>
<p>主要是关于<code>printf</code>中的几个细节有了更多的了解。但是我觉得对于其中的va_*那几个函数还是不太能够理解，就是一个变长参数表到底是个什么东西还是不太清楚，这也导致我extra没做出来，哭！</p>
<p>其中对于启动引导的学习让自己对于操作系统有了更深的认识，完成了从计算机组成原理中学习到的底层计算机硬件架构到操作系统的过渡，同时也对于活动分区等这些有了更深的认识，起码对于自己电脑上的多系统的了解更深了一分。</p>
<p>同时还有readelf也让自己对于文件的结构更加了解了，包括认识学习到了之前一直苦恼的一些有关.so文件缺失的报错，对于文件头这个数据结构也懂了很多！</p>
<p>总体而言还是觉得自己需要加强对于操作系统的学习啊！！C语言真是博大精深啊！</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab1</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab3实验报告</title>
    <url>/2024/04/24/os-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1><span id="lab3实验报告">Lab3实验报告</span></h1>
<h2><span id="思考题">思考题</span></h2>
<h3><span id="thinking-31">Thinking 3.1</span></h3>
<blockquote>
<p>请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)]= PADDR(e-&gt;env_pgdir) | PTE_V </code>的含义。</p>
</blockquote>
<p>0x7fc00000-0x80000000 这 4MB 空间的起始位置（也就是第一个二级页表的基地址）对应着页目录的第一个页目录项。同时由于 1M 个页表项和 4GB 地址空间是线性映射的，不难算出 0x7fc00000 这一个地址对应的应该是第 0x7fc00000 &gt;&gt; 12 个页表项。</p>
<p>每个页表项是<code>4B</code>，一共有<code>1M</code>个页表项，占据<code>4MB</code>的空间，正好是<code>UVPT</code>到<code>ULIM</code>这个<code>User VPT</code>这4MB的空间。页表自映射使得页目录的某一项正好映射到这个页表。由于线性性质，那么正好就是<code>UVPT &gt;&gt; 22</code>这个页目录中的一项就是页目录所在页表的物理地址。</p>
<p>后面就是页表的标志位了。</p>
<h3><span id="thinking-32">Thinking 3.2</span></h3>
<blockquote>
<p>elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p>
</blockquote>
<p>在<code>map_page()</code>中的参数<code>data</code>就是传入<code>elf_load_seg()</code>中传入的参数<code>data</code>，也就是在<code>load_icode()</code>中传入的参数<code>struct Env *e</code>，一个进程控制块。</p>
<p>在<code>map_page()</code>中<code>data</code>的作用为最后的<code>env</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span>env_pgdir<span class="token punctuation">,</span> env<span class="token operator">-&gt;</span>env_asid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是指定当前进程的页目录的内核虚拟地址，和该进程的<code>asid</code></p>
<p>不可以去掉这个参数，这是因为每个进程有自己的<code>tlb</code>，这个<code>tlb</code>是由<code>asid</code>确定的。</p>
<h3><span id="thinking-33">Thinking 3.3</span></h3>
<blockquote>
<p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p>
</blockquote>
<ol>
<li>当前页面不可写的情况：调整传入map_page()中断权限位</li>
<li>段头和页面不对齐的情况：注意开始的位置</li>
<li>创建页面不成功的情况：return</li>
<li>二进制文件大小小于段在内存的大小的情况：继续创建填充0的页面</li>
</ol>
<h3><span id="thinking-34">Thinking 3.4</span></h3>
<blockquote>
<p>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：</p>
<ul>
<li>你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</li>
</ul>
</blockquote>
<p>虚拟地址。</p>
<p>（lab2啥理解呀）应该是说在CPU看来都是虚拟地址，MIPS是有一个MMU的作为地址变换的。</p>
<h3><span id="thinking-35">Thinking 3.5</span></h3>
<blockquote>
<p>试找出 0、 1、 2、 3 号异常处理函数的具体实现位置。 8 号异常（系统调用）涉及的 do_syscall() 函数将在 Lab4 中实现</p>
</blockquote>
<p>在<code>kern/genex.S</code>中。</p>
<p>0号异常处理<code>handle_int</code>是处理时钟中断，其中主要是调用了<code>schedule</code>这个函数，但是这里还特判一下<code>$t1</code>是否为0这个我不太理解，理论上前面刚和<code>STATUS_IM7</code>这个做完与运算应该就不会是0才对。</p>
<p>1号异常，存储异常会执行<code>do_tlb_mod</code>，这个在<code>kern/tlbex.c</code>中实现</p>
<p>2、3号异常，<code>tlb</code>异常会执行<code>do_tlb_refill</code>，也就是tlb重填，这个在<code>kern/tlb_asm.S</code>中实现</p>
<h3><span id="thinking-36">Thinking 3.6</span></h3>
<blockquote>
<p>阅读 entry.S、 genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p>
</blockquote>
<p>在<code>entry.S</code>中的<code>handle_int</code>里面开启，时钟中断过程进入<code>schedule</code>函数，然后其中调用<code>env_run</code>，再调用<code>env_pop_tf</code>，，<code>env_pop_tf</code>的具体实现在<code>env_asm.S</code>中，其中调用<code>RESET_KCLOCK</code>，也就是在<code>include/kclock.h</code>中的实现。</p>
<h3><span id="thinking-37">Thinking 3.7</span></h3>
<blockquote>
<p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p>
</blockquote>
<p>根据3.6的分析，时钟中断后会调用<code>schedule</code>在这里面切换进程，具体而言包括保存上下文和进入新的进程的上下文环境，同时时钟初始化。</p>
<h2><span id="难点分析">难点分析</span></h2>
<p>本次lab其实主要包括两个部分，一个是进程方面，包括进程的创建和调度；一个是时钟中断方面。</p>
<p>实际上进程的创建和调度应该分开说，但是我认为这两个其实都是在软件层面上的实现(似乎这么说也不准确)，反正就这么说了罢。</p>
<p>本次lab的难点我认为主要在于对这几个的流程的理解。</p>
<h3><span id="进程创建与调度">进程创建与调度</span></h3>
<p>进程的创建是在内核态中执行的。</p>
<p>创建进程包括</p>
<ol>
<li>初始化Env 这个进程控制块，包括其中的一些变量的取值</li>
<li>在<code>struct Env</code>中还有一个关键的<code>env_pgdir</code>，这个就是确定虚拟地址</li>
<li>进程是运行中的程序，那这个程序从哪里来呢？这个在<code>load_icode</code>中加以实现，由于一个程序可以有多个进程，所以肯定不能用程序的那块内存空间直接操作，同时还有一些动态的空间需要进程创建，那么这块地址空间在哪呢，对于进程来说，他看到的都是自己的虚拟地址，就是这个了~</li>
</ol>
<p>进程调度实际上就是去掉这个进程然后把那个进程拉过来</p>
<ul>
<li>去掉这个进程：这一步需要保存CPU上下文信息，同时需要在两个队列中进行处理，包括空闲env区，和调度队列区</li>
<li>把新的进程拉过来：从调度队列拿一个过来，然后恢复他的上下文信息</li>
</ul>
<h3><span id="时钟中断">时钟中断</span></h3>
<p>我觉得这里主要是函数之间的调用挺复杂的，其实工作流程还是很好理解的</p>
<ul>
<li>handle_int</li>
<li>schedule</li>
<li>env_run</li>
<li>env_pop_tf</li>
</ul>
<p>害，真是中中又断断啊~</p>
<p>其中对于<code>kern/genex.S</code>中的<code>timer_irq</code>不甚了解，但是当我看到<code>guide_book</code>中的描述时(顺便吐槽一下，咋这还不相同的)，我好像懂了，或许是更加不同情况会进入不同的异常处理，只需要将<code>bnez</code>稍微调整为<code>beq</code>为某个特定的数就可以了，由于目前只实现了是时钟中断，因此一律调用这个就好啦~</p>
<p><img src="/2024/04/24/os-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%5Cimage-20240424011924754.png" alt="image-20240424011924754"></p>
<h2><span id="实验体会">实验体会</span></h2>
<p>在Lab2的时候说这个lab好难啊，在Lab3的时候也还是这么说。Lab2对于List的使用确实是我遇到的很大的一个障碍，这次使用起来更加得手了。</p>
<p>同时自己实现了一次进程后，对于比如“每个结构都有一个数据结构”、“linux一切皆文件”，这些有了更深的认识。</p>
<p>当需要实现某个具有特定功能的结构时，首要就是分析其数据结构，课程组似乎没有特别强调<code>env</code>的数据结构，其实处处都是优雅。基于上面这一点，进程其实就是一段地址空间，与“一切皆文件”的观点不谋而合。当然需要清楚到底是哪一段内存，是什么样子的内存。</p>
<p>这次还用到了更多<code>debug</code>的功能，下次可以多多研究<code>objdump</code>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab3</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab3笔记</title>
    <url>/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="lab3">lab3</span></h1>
<p>实验目的：</p>
<ul>
<li>创建一个进程，并成功运行</li>
<li>实现时钟中断，通过时钟中断内核获得执行权</li>
<li>实现进程调度，创建两个进程，通过时钟中断切换进程执行</li>
</ul>
<p>使用进程控制卡Env来跟踪用户进程，并建立一个简单的用户进程，加载一个程序镜像到指定的内存空间，并让它运行起来。</p>
<p>进程</p>
<ul>
<li>由于没有实现线程，进程既是基本的分配单元，也是基本的执行单元。</li>
<li>每个进程都是一个实体，有自己的地址空间，通常包括代码段、数据段和堆栈。</li>
<li>程序是一个没有声明的实体，只有被操作系统执行时才能称为一个活动的实体，而执行中的程序，就是进程</li>
</ul>
<p>PCB进程控制块</p>
<blockquote>
<p>本质就是一个数据结构</p>
</blockquote>
<p><code>env_init</code></p>
<blockquote>
<p>traverse 是遍历的意思</p>
</blockquote>
<p>段地址映射</p>
<p>为<code>base_pgdir</code>分配了一页物理内存，将其转换为内核虚拟地址，并使用<code>map_segment</code>来进行映射。</p>
<ul>
<li><code>pages</code>映射到<code>UPAGES</code></li>
<li><code>envs</code>映射到<code>UENVS</code></li>
</ul>
<p>其中补全的部分我是这么写的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Page</span><span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token function">pa2page</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">page_insert</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> asid<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其实可以把pp直接替换为中间那一部分。</p>
<p>注意是<code>va+i</code>和<code>pa+i</code></p>
<p>进程的标识</p>
<blockquote>
<p>就是<code>env_id</code></p>
</blockquote>
<p>这里用自己的话解释一下为什么还需要一个<code>asid</code></p>
<p>实际上是为了让每一个进程有一个自己的<code>tlb</code>，这样当这个进程结束时(或者进程切换的时候)只需要把这个进程的<code>tlb</code>刷新掉即可。</p>
<p>既然需要有一个自己的<code>tlb</code>那就得有一个标识符，那为什么不直接用<code>env_id</code>呢，我认为主要是为了让<code>tlb</code>只有有限个，太多了就炸内存了，这波属于是宁愿少点，不能多了。</p>
<p>创建进程</p>
<blockquote>
<p>终于开始创建进程了</p>
</blockquote>
<p>实际上创建进程在不考虑进程的交互性(也就是说这是个活的实体)，实际上就是个数据结构，那么相应的数据结构就是<code>PCB</code>进程控制块。</p>
<p>因此也可以理解为设置一个进程控制块。</p>
<ul>
<li>设置进程控制块实际上是告诉了我们这个进程是什么</li>
<li>那么进程还要有自己的地址空间，包括代码段、数据段和堆栈</li>
</ul>
<p>OK，这里开始解释后面的进程调度和中断的开启。</p>
<p>在MIPS处理器中，中断是由硬件控制的，也就是<code>CP0</code>寄存器中保存着我们需要的信息。</p>
<p>那么具体是如何设置的呢？</p>
<p>这里我们考虑的相对简单，还只开启了时钟中断。</p>
<blockquote>
<p>这里就是需要将<code>IM7</code>设置为1，表示时钟中断可以被响应，同时还有<code>IE</code>位，也就是<code>Interupt Enable</code>中断使能位要打开才能正确的中断</p>
</blockquote>
<p>还有第二个问题，中断需要调度进程，同时需要进入内核态。</p>
<blockquote>
<p>害，理论是真的很重要！！！</p>
</blockquote>
<p>用户态的标志：<code>EXL=0, UM=1</code></p>
<p>其他都是内核态</p>
<p>那么如果我们刚开始在内核态接受到了时钟中断，中断结束后我们还应当是在内核态，但是由于</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">eret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令在所有进程调度的最后都会被执行，同时<code>eret</code>会进<code>EXL</code>设置为0(也就是希望返回到用户态)，因此我们还需要手动维护一下<code>EXL</code>使得保持在内核态。</p>
<p>elf简单复习一下</p>
<p>ELF文件结构为：</p>
<ul>
<li>ELF头，包括程序的基本信息，比如体系结构和操作系统，同时也把包括了节头表和段头表相对文件的偏移量offset</li>
<li>段头表，program header table ，主要包含程序中各个段segment的信息，段的信息需要在运行时刻使用</li>
<li>节头表，section header table，主要包括程序中各个节section的信息，节的信息需要在程序编译和链接的时候使用</li>
</ul>
<p>加载二进制文件</p>
<p>ELF文件的类型有三种：可重定位文件，可执行文件，可被共享的对象文件。</p>
<p>这里指可执行文件</p>
<p>要加载一个ELF文件到内存，只需要将其中所有需要加载的program segment程序段到对应的虚拟地址上即可。(这里我认为主要是因为这里是可执行文件，所以只需要将各个需要在运行时刻使用的信息存放过去即可)</p>
<p>目前还是在内核态，<code>alloc</code>的一个页面是一个物理页面。</p>
<p>要得到其物理地址，由于是内核态，因此需要调用<code>page2kva</code>来得到物理地址。</p>
<p>这一点从<code>page_alloc()</code>中的<code>memset((void*)page2kva(pp),0,PAGE_SIZE);</code>可以初见端倪。</p>
<p>而且本身也非常合理。</p>
<p>给进程分配地址空间，实际上是将可执行文件的信息进行复制。</p>
<p>这里用到了一个回调函数，还算比较好理解。</p>
<p><code>load_icode</code>函数最后需要将<code>env_tf.cp0_epc</code>设置为<code>e_entry</code>，这个是说当执行进程时还是需要从最开始这个可执行文件的开始位置开始执行。</p>
<p>创建进程</p>
<p>进程控制块也设置好了，地址空间也安排好了，终于可以创建进程了。</p>
<p>这里的创建进程是在内核初始化时直接创建进程。</p>
<ol>
<li>分配一个新的Env结构体</li>
<li>设置进程控制块</li>
<li>将程序载入到进程的地址空间</li>
</ol>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240422043001149.png" alt="image-20240422043001149"></p>
<p>这里可以修改为</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进程运行与切换</p>
<p>要运行一个进程：</p>
<ul>
<li>需要保存当前进程的上下文(如果当前没有进程就pass)</li>
<li>恢复要启动的进程的上下文，然后运行该进程</li>
</ul>
<p>进程的上下文朴素的理解就是当时运行这个进程时硬件的情况，也就是各个寄存器的状态，也就是<code>Trapframe</code>的内容</p>
<p>包括</p>
<ul>
<li>通用寄存器</li>
<li><code>HI</code>、<code>LO</code></li>
<li>CP0的<code>Status</code>、<code>EPC</code>、<code>Cause</code>和<code>BadVAddr</code>寄存器</li>
</ul>
<p>在这里寄存器状态保存的地方是<code>KSTACKTOP</code>以下的大小为<code>TrapFrame</code>的区域</p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240422044027836.png" alt="image-20240422044027836"></p>
<p>运行一个进程：</p>
<ol>
<li>保存当前进程的上下文信息(没有就开摆)</li>
<li>切换<code>curenv</code>为即将运行的进程(这里还没有切换)</li>
<li>设置全局变量<code>cur_pgdir</code>为当前进程的页目录地址，在<code>TLB</code>重填是将用到这个全局变量</li>
<li>调用<code>env_top_tf</code>函数，恢复现场(就是即将运行的进程的现场/上下文信息)、异常返回</li>
</ol>
<p>中断与异常</p>
<p>CP0寄存器</p>
<ul>
<li>Status 状态寄存器，包括中断引脚使能，其他CPU模式等位域</li>
<li>Cause 记录导致异常的原因</li>
<li>EPC 异常结束后程序恢复执行的位置</li>
</ul>
<p>处理异常是由硬件完成的，MIPS CPU处理一个异常的步骤包括</p>
<ol>
<li>设置EPC指向从异常返回的地址</li>
<li>设置EXL位，强制CPU进入内核态，并禁止中断</li>
<li>设置Cause寄存器，记录异常发生的原因</li>
<li>CPU从异常入口位置取指，此后交给软件处理，也即是我们的操作系统来处理</li>
</ol>
<h2><span id="梳理">梳理</span></h2>
<p>这里再把整个流程进行梳理</p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240424160053472.png" alt></p>
<p><img src="/2024/04/24/os-lab3%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab3%E7%AC%94%E8%AE%B0%5Cimage-20240424160152458.png" alt="image-20240424160152458"></p>
<h3><span id="进程创建">进程创建</span></h3>
<h2><span id="几个问题">几个问题</span></h2>
<ol>
<li>
<p><code>tests/lab3_*</code>这几个里面的<code>pre_env_run.c</code>是干嘛用的，<code>tests/lab3_4</code>还有个<code>quick_sort.c</code>是干嘛的</p>
<blockquote>
<p>第一直觉感觉是创建一个进程，但是仔细一看还是不太清楚</p>
</blockquote>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab3</tag>
      </tags>
  </entry>
  <entry>
    <title>os-lab2笔记</title>
    <url>/2024/04/24/os-lab2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>#　lab2</p>
<p>首先我们需要关注<code>include</code>中的一些头文件以及其中定义的一些宏函数和静态内联函数。这些东西是真的难啊，让我觉得自己程设里面学的C语言和这里的不是一个东西。</p>
<ul>
<li>
<p>首先要知道这些宏定义对应的英文全称和中文释义。</p>
<blockquote>
<ol>
<li><code>NASID</code>：Node Abstract System Identifier，节点抽象系统标识符。</li>
<li><code>PAGE_SIZE</code>：Page Size，页面大小。</li>
<li><code>PTMAP</code>：Page Table Mapping，页表映射。</li>
<li><code>PDMAP</code>：Page Directory Mapping，页目录映射。</li>
<li><code>PGSHIFT</code>：Page Shift，页偏移。</li>
<li><code>PDSHIFT</code>：Page Directory Shift，页目录偏移。</li>
<li><code>PDX</code>：Page Directory Index，页目录索引。</li>
<li><code>PTX</code>：Page Table Index，页表索引。</li>
<li><code>PTE_ADDR</code>：Page Table Entry Address，页表条目地址。</li>
<li><code>PTE_FLAGS</code>：Page Table Entry Flags，页表条目标志。</li>
</ol>
</blockquote>
</li>
<li>
<p>从整体上来理解，首先要知道几个基本的东西是啥。</p>
</li>
</ul>
<p>其中包括Page_list和Page。<code>LIST_HEAD(Page_list, Page);</code>可以知道这几个对应在LIST中的几个基本要素。</p>
<p><code>typedef LIST_ENTRY(Page) Page_LIST_entry_t;</code>虽然感觉这个类型宏替换意义不大。</p>
<ul>
<li>LIST又是啥呢？这也好难，让我感觉自己的数据结构又是白学的<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
</ul>
<p>首先要坚信这个List就是我们学的那个链表，是一个双向链表。</p>
<p>这里的链表是有一个专门的头指针的，在ds中也有地方会这么用。(有一些好像还会有一些头发指针，头指针的前一个元素)这几个都是让链表的处理更加方便，也可以认为是大家认为链表的比较优雅的实现方式。</p>
<p>头指针：</p>
<p><code>LIST_HEAD(name, type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上是定义了一个结构体，给这个结构提一个名字比如head，实际上就是<code>LIST_HEAD(name, int) head;</code></p>
<p>宏替换后实际上就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">int</span> <span class="token operator">*</span>lh_first<span class="token punctuation">;</span>
<span class="token punctuation">}</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么相应的一些与链表头指针的一些操作：</p>
<p><code>LIST_HEAD_INITIALIZER(head)</code></p>
<p>具体用法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_HRAD</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
head <span class="token operator">=</span> LIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于每个结点的指针部分实际上就是</p>
<p><code>LIST_ENTRY(type)</code></p>
<p>也就是</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span>le_next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token operator">*</span><span class="token operator">*</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里le_next可以理解，但是这个le_prev呢，这个给的注释也很奇怪，<code>address of previous next element</code>。这么来看，实际上就是将每个next指针作为一个element，那么prev就是前一个元素的这个指针。这样并不是双向链表那种，双向链表是多了一个指向前一个结点的大结点的地址的指针，也就是说可以通过这个指针直接访问前一个结点。而这个le_prev仅仅只是前一个元素的next这个元素的地址。</p>
<p>那么到这里其实就懂了，一个结点分为data和field。filed实际上就是优化版的next，包括next和prev两个元素。data的数据格式为struct type, next是struct type*，prev是struct type**;</p>
<p>那么我们简单总结一下这个链表的结构。首先是head，head是个头指针，里面包含有第一个元素的指针。每个结点包含data和field两个部分。</p>
<p>就可以很好理解<code>LIST_NEXT(elm, field)</code> 这个宏函数了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> field<span class="token punctuation">.</span>le_next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看一下<code>LIST_FOREACH(var, head, field)</code>这个宏定义，这里给出了一种遍历链表的方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来实现<code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，也即是在listelm前面添加elm。</p>
<p>一般的双向链表有下面这个就够了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> listelm<span class="token punctuation">;</span>
<span class="token comment">// listelm-&gt;prev = elm; 类似这种的操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是由于添加了prev，需要更新elm和listelm的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev<span class="token punctuation">;</span>
<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> elm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里*的运算级是高于-&gt;的。</p>
<p>于是完成<code>LIST_INSERT_AFTER(listelm, elm, field)</code>就很简单了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span> <span class="token operator">=</span> elm<span class="token punctuation">;</span>
elm<span class="token operator">-&gt;</span>field<span class="token punctuation">.</span>le_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listelm<span class="token punctuation">)</span><span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="4kc访存流程">4Kc访存流程</span></h2>
<h3><span id="cpu发出地址">CPU发出地址</span></h3>
<h3><span id="虚拟地址映射到物理地址">虚拟地址映射到物理地址</span></h3>
<ul>
<li>虚拟地址0x80000000-0x9fffffff，kseg0，将最高位置0得到物理地址，通过cache访问。这一部分<strong>用于存放内核代码与数据</strong>。</li>
<li>虚拟地址0xa0000000-0xbfffffff，kseg1，将最高3位置0得到物理地址，不通过cache访问。这一部分可以<strong>用于访问外设</strong>。</li>
<li>虚拟地址0x00000000-0x7fffffff，kuseg，通过TLB转换为物理地址，然后通过cache访存。这一部分用于<strong>存放用户程序代码与数据</strong></li>
</ul>
<p><img src="/2024/04/24/os-lab2%E7%AC%94%E8%AE%B0/D:%5Cblog%5Chexo%5Csource_posts%5Cos-lab2%E7%AC%94%E8%AE%B0%5Cimage-20240406230222403.png" alt="image-20240406230222403"></p>
<h3><span id="内核程序启动">内核程序启动</span></h3>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>os-lab2</tag>
      </tags>
  </entry>
  <entry>
    <title>p3-CPU-设计文档</title>
    <url>/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1><span id="单周期mips架构cpu的logisim实现">单周期mips架构CPU的logisim实现</span></h1>
<p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p>
<span id="more"></span>
<h2><span id="数据路径">数据路径</span></h2>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>Stop</td>
<td>I</td>
<td>1</td>
<td>停止信号</td>
</tr>
<tr>
<td>PC’</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
<tr>
<td>Instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
<tr>
<td>4</td>
<td>取指令</td>
<td>根据当前 PC 的值从 IM（指令存储器）中读出对应的指令到 Instr 端口</td>
</tr>
</tbody>
</table>
<h4><span id="pc程序计数器">PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>Stop</td>
<td>I</td>
<td>1</td>
<td>停止信号</td>
</tr>
<tr>
<td>PC’</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>PC</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="im指令存储器">IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>Instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>Branch</td>
<td>I</td>
<td>1</td>
<td>是否为Branch型指令，控制信号</td>
</tr>
<tr>
<td>Equals</td>
<td>I</td>
<td>1</td>
<td>是否满足Branch跳转判断</td>
</tr>
<tr>
<td>Offset</td>
<td>I</td>
<td>32</td>
<td>进行符号拓展后的立即数信号<br>Branch &amp; Equals==1:b型跳转</td>
</tr>
<tr>
<td>JUMP</td>
<td>I</td>
<td>1</td>
<td>是否为j指令或者jal指令，控制信号<br>1：J型跳转</td>
</tr>
<tr>
<td>Imm_26</td>
<td>I</td>
<td>26</td>
<td>26位立即数信号，拓展后即为跳转地址</td>
</tr>
<tr>
<td>JR</td>
<td>I</td>
<td>1</td>
<td>是否为jr或者jalr指令，控制信号<br>1：JR型跳转</td>
</tr>
<tr>
<td>Ra</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165252314.png" alt="image-20240221165252314"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165258299.png" alt="image-20240221165258299"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165302941.png" alt="image-20240221165302941"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="ext拓展单元">EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Imm_16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>UnsignedExt</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>Imm_32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>0000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>0001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>0010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>0011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>0100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>0101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>0110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>0111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>1000</td>
<td>ALURes = SrcA &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>1001</td>
<td>ALURes = SrcA &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>1010</td>
<td>ALURes = SrcA &gt;&gt; Shift</td>
</tr>
<tr>
<td>相等</td>
<td>equal</td>
<td>1011</td>
<td>ALURes = (SrcA == SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>有符号小于</td>
<td>signed_less</td>
<td>1100</td>
<td>ALURes = (SrcA &lt; SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>无符号小于</td>
<td>unsigned_less</td>
<td>1101</td>
<td>ALURes = (u_SrcA &lt; u_SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>有符号大于</td>
<td>signed_bigger</td>
<td>1110</td>
<td>ALURes = (SrcA &gt; SrcB) ? 1 : 0</td>
</tr>
<tr>
<td>无符号大于</td>
<td>unsigned_bigger</td>
<td>1111</td>
<td>ALURes = (u_SrcA &gt; u_SrcB) ? 1 : 0</td>
</tr>
</tbody>
</table>
<h3><span id="dm数据存储器">DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="控制">控制</span></h2>
<h3><span id="cu">CU</span></h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p>
<p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p>
<p>其次从CU的角度开始处理指令。</p>
<p>第一步，<strong>输入信号</strong>。</p>
<p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p>
<p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p>
<p>然后利用<code>Or Logical</code>，来激活相应的接口。</p>
<p>第二步，对于<strong>lw指令</strong>。</p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165310365.png" alt="image-20240221165310365"></p>
<p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p>
<p>第三步，对于<strong>sw信号</strong>。</p>
<p><img src="/2024/02/21/p3-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165317549.png" alt="image-20240221165317549"></p>
<p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p>
<p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p>
<h2><span id="自动化测试">自动化测试</span></h2>
<h2><span id="思考题">思考题</span></h2>
<ul>
<li>
<p>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p>
<blockquote>
<p>状态存储交给寄存器来搞定，包括IFU里面的指令寄存器和GRF里面的32个寄存器。其他的期间几乎都是在完成状态转移功能。</p>
</blockquote>
</li>
<li>
<p>现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p>
<blockquote>
<p>合理的，正确的，中肯定，毋庸置疑的</p>
</blockquote>
</li>
<li>
<p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p>
<blockquote>
<p>如果非要说的，或许可以实现一个分线器Splitter？将各部分信号传出来的一个元件，当然这几个就可以实现一个基本的mips单周期cpu</p>
</blockquote>
</li>
<li>
<p>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</p>
<blockquote>
<p>等价于sll 0位，或者认为是不进行任何操作处理。</p>
</blockquote>
</li>
<li>
<p>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p>
<blockquote>
<p>强度不行。指令并有覆盖到所有可能的情况，包括使用到的寄存器，是否考虑溢出情况等。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p3</tag>
      </tags>
  </entry>
  <entry>
    <title>p5-流水线</title>
    <url>/2024/02/21/p5-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$五级流水线$\mathscr{Design}$</span></h1>
<p>实现五级流水线CPU</p>
<span id="more"></span>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p5</tag>
      </tags>
  </entry>
  <entry>
    <title>p4-CPU-设计文档</title>
    <url>/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1><span id="单周期mips架构cpu的verilog实现">单周期mips架构CPU的verilog实现</span></h1>
<p>通过抽象的方式我们从两个方面来构建单周期CPU，也就是数据路径（DataPath）和控制器（Controller）</p>
<h2><span id="数据路径">数据路径</span></h2>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="pc程序计数器">PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="im指令存储器">IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="npc下一指令计算单元">NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>Imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>regAddr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>PC+4</td>
<td>O</td>
<td>32</td>
<td>输出PC+4的值</td>
</tr>
<tr>
<td>npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC_4</td>
<td>2</td>
<td>2‘b00</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>2</td>
<td>2’b01</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>2</td>
<td>2’b10</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>2</td>
<td>2’b11</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165229781.png" alt="image-20240221165229781"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165224329.png" alt="image-20240221165224329"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165218734.png" alt="image-20240221165218734"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="grf通用寄存器组">GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>Reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>WE</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="ext拓展单元">EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>extUnsignedSel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="alu逻辑运算单元">ALU（逻辑运算单元）</span></h3>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>0000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>0001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>0010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>0011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>0100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>0101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>0110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>0111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>1000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>1001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>1010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="dm数据存储器">DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>dmWriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>WD</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="splitter">Splitter</span></h3>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>instr</td>
<td>I</td>
<td>32</td>
<td>输入指令信号</td>
</tr>
<tr>
<td>opcode</td>
<td>O</td>
<td>6</td>
<td>instr[31:26]</td>
</tr>
<tr>
<td>rs</td>
<td>O</td>
<td>5</td>
<td>instr[25:21]</td>
</tr>
<tr>
<td>base</td>
<td>O</td>
<td>5</td>
<td>instr[25:21]</td>
</tr>
<tr>
<td>rt</td>
<td>O</td>
<td>5</td>
<td>instr[20:16]</td>
</tr>
<tr>
<td>rd</td>
<td>O</td>
<td>5</td>
<td>instr[15:11]</td>
</tr>
<tr>
<td>sa</td>
<td>O</td>
<td>5</td>
<td>instr[10:6]</td>
</tr>
<tr>
<td>func</td>
<td>O</td>
<td>6</td>
<td>instr[5:0]</td>
</tr>
<tr>
<td>imm26</td>
<td>O</td>
<td>26</td>
<td>instr[25:0]</td>
</tr>
<tr>
<td>imm16</td>
<td>O</td>
<td>16</td>
<td>instr[15:0]</td>
</tr>
</tbody>
</table>
<h3><span id="cmp">CMP</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>值</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2><span id="控制">控制</span></h2>
<h3><span id="cu">CU</span></h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>由于我是先搓完的数据路径部分，在写到CU的时候对于大多数的接口已经<strong>不记得了</strong>。这里可以学习<strong>黑书中的模式</strong>，通过一条指令来构建起其中的一些指令的控制，然后加指令来增加前面可能缺少的接口，同时补全接口的定义等。</p>
<p>首先我是将一些和初始化、终止等相关的接口拿出来，这些基本上是自定义的，用于提高CPU的可拓展性。比如在IFU中的Stop，EXT中的UnsignedExt信号等。</p>
<p>其次从CU的角度开始处理指令。</p>
<p>第一步，<strong>输入信号</strong>。</p>
<p>这里包括两个，<code>Instr[31:26]</code>也就是Opcode，<code>Instr[5:0]</code>也就是在R类型指令中的Func。</p>
<p>对这两个进行输入解析。利用<code>And Logical</code>，判断得到对应什么指令。</p>
<p>然后利用<code>Or Logical</code>，来激活相应的接口。</p>
<p>第二步，对于<strong>lw指令</strong>。</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165208821.png" alt="image-20240221165208821"></p>
<p>这里首先调整了几个选择信号，同时检查发现加上了WriteReg控制信号。</p>
<p>第三步，对于<strong>sw信号</strong>。</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165204960.png" alt="image-20240221165204960"></p>
<p>发现sw和lw基本一模一样。做完这两个之后对于整体指令已经熟悉了，然后开始实现剩余的指令控制信号。</p>
<p>最后，反过来从接口的角度思考有哪些指令需要用到该接口或者对该接口有什么操作，然后对CU进行补全以及检查。</p>
<h2><span id="自动化测试">自动化测试</span></h2>
<h2><span id="思考题">思考题</span></h2>
<ul>
<li>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024 字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</li>
</ul>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165157185.png" alt="image-20240221165157185"></p>
<blockquote>
<p>addr信号来自于ALU。因为是按字存储的，每四个byte一个字节。</p>
</blockquote>
<ul>
<li>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</li>
</ul>
<blockquote>
<p>记录指令的控制信号如何取值</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
     <span class="token function">if</span><span class="token punctuation">(</span>opcode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
         <span class="token function">case</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> 
             <span class="token number">6'b100000</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>
                 npcOp <span class="token operator">==</span> <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span>
                 writeRegSel <span class="token operator">==</span> <span class="token constant">`CU_GRF_A3_RD</span><span class="token punctuation">;</span>
                 grfWriteEn <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>
             <span class="token keyword">end</span>
         <span class="token keyword">endcase</span>
     <span class="token keyword">end</span>
     <span class="token keyword">else</span> <span class="token keyword">begin</span>
         <span class="token keyword">case</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">)</span><span class="token punctuation">:</span>
             <span class="token constant">`CU_add_OP</span> <span class="token punctuation">:</span> <span class="token keyword">begin</span>

         <span class="token keyword">end</span>
     <span class="token keyword">endcase</span>
             <span class="token keyword">end</span>
 <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>记录控制信号每种取值所对应的指令</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> npcOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`NPC_B</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>j <span class="token operator">|</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>jr<span class="token punctuation">)</span>      <span class="token operator">?</span> <span class="token constant">`NPC_JR</span><span class="token punctuation">:</span>
                           <span class="token constant">`NPC_PC_4</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> writeRegSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> sll<span class="token punctuation">)</span>       <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">:</span>
                     <span class="token punctuation">(</span>ori <span class="token operator">|</span> lw  <span class="token operator">|</span> sw <span class="token operator">|</span> lui <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RT</span> <span class="token punctuation">:</span>
                     <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                   <span class="token operator">?</span> <span class="token constant">`CU_GRF_A3_RA</span> <span class="token punctuation">:</span>
                                               <span class="token constant">`CU_GRF_A3_RD</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> grfWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll <span class="token operator">|</span> jal <span class="token operator">|</span> lw<span class="token punctuation">)</span> <span class="token operator">?</span>  <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> writeRegDataSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> ori <span class="token operator">|</span> lui <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_ALURESULT</span> <span class="token punctuation">:</span>
                         <span class="token punctuation">(</span>lw<span class="token punctuation">)</span>                          <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_MEMRD</span> <span class="token punctuation">:</span>
                         <span class="token punctuation">(</span>jal<span class="token punctuation">)</span>                         <span class="token operator">?</span> <span class="token constant">`CU_GRF_WD_PC_4</span> <span class="token punctuation">:</span>
                                                         <span class="token constant">`CU_GRF_WD_ALURESULT</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> extUnsignedSel <span class="token operator">=</span> <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> aluSrcSel <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> sub <span class="token operator">|</span> beq <span class="token operator">|</span> sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">:</span>
                   <span class="token punctuation">(</span>ori <span class="token operator">|</span> lui <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span>   <span class="token operator">?</span> <span class="token constant">`CU_ALU_SRCB_IMM32</span>  <span class="token punctuation">:</span>
                                             <span class="token constant">`CU_ALU_SRCB_GRFRD2</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> shamtSel <span class="token operator">=</span> <span class="token punctuation">(</span>lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_16</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>sll<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span> <span class="token punctuation">:</span>
                          <span class="token constant">`CU_ALU_SHAMT_SEL_sa</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> aluOp <span class="token operator">=</span> <span class="token punctuation">(</span>add <span class="token operator">|</span> lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`ALU_add</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>sub<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_sub</span> <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>ori<span class="token punctuation">)</span>           <span class="token operator">?</span> <span class="token constant">`ALU_or</span>  <span class="token punctuation">:</span>
               <span class="token punctuation">(</span>lui <span class="token operator">|</span> sll<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token constant">`ALU_sll</span> <span class="token punctuation">:</span>
                                 <span class="token constant">`ALU_add</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> dmWriteEn <span class="token operator">=</span> <span class="token punctuation">(</span>sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
<span class="token keyword">assign</span> dmOp <span class="token operator">=</span> <span class="token punctuation">(</span>lw <span class="token operator">|</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`DM_WORD</span> <span class="token punctuation">:</span>
                          <span class="token constant">`DM_WORD</span> <span class="token punctuation">;</span>
<span class="token keyword">assign</span> branchOp <span class="token operator">=</span> <span class="token punctuation">(</span>beq<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bne<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_NOT_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bge<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER_OR_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>ble<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS_OR_EQUAL</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>blt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_LESS</span> <span class="token punctuation">:</span>
                  <span class="token punctuation">(</span>bgt<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`CMP_SIGNED_GREATER</span> <span class="token punctuation">:</span>
                          <span class="token constant">`CMP_EQUAL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>记录指令的控制信号如何取值，更加方便记录追踪每一条指令的问题。这个对于增加指令也比较方便。</li>
<li>记录控制信号每种取值所对应的指令，方便看某一个控制指令的组成</li>
</ul>
</blockquote>
<ul>
<li>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</li>
</ul>
<blockquote>
<p>同步复位中，clk信号优先于reset信号。</p>
<p>异步复位中，reset信号优先于clk信号。</p>
</blockquote>
<ul>
<li>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</li>
</ul>
<blockquote>
<p>addi和addiu的区别，add和addu的区别在于addi和add在溢出是会报溢出异常，忽略溢出二者自然就相同了嘛。</p>
<ul>
<li>
<p>add</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165124611.png" alt="image-20240221165124611"></p>
</li>
<li>
<p>addu</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165132920.png" alt="image-20240221165132920"></p>
</li>
<li>
<p>addi</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165139866.png" alt="image-20240221165139866"></p>
</li>
<li>
<p>addiu</p>
<p><img src="/2024/02/21/p4-CPU-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20240221165148096.png" alt="image-20240221165148096"></p>
</li>
</ul>
</blockquote>
<h2><span id="命名的合理性">命名的合理性</span></h2>
<p>元件统一大驼峰（首字母大写）</p>
<p>接口连线统一小驼峰（首字母小写），单个字母仍然使用大写以保证美观。（想了想GRF还是采用以前的A1这种命名吧，不然感觉好奇怪。</p>
<p><strong>操作控制</strong>：选择信号以Op结尾</p>
<p><strong>写使能控制</strong>：使能信号以En结尾</p>
<p><strong>多路控制</strong>：多路选择器开关信号以Sel结尾。</p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p4</tag>
      </tags>
  </entry>
  <entry>
    <title>p7-知识点整理</title>
    <url>/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1><span id="mips-微系统">mips 微系统</span></h1>
<h2><span id="cp0协处理器">CP0协处理器</span></h2>
<h3><span id="cpu-控制寄存器"><strong>CPU 控制寄存器</strong></span></h3>
<table>
<thead>
<tr>
<th>寄存器助记符</th>
<th>寄存器编号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SR</td>
<td>12</td>
<td>State Register</td>
</tr>
<tr>
<td>Cause</td>
<td>13</td>
<td>记录异常中断的原因</td>
</tr>
<tr>
<td>EPC</td>
<td>14</td>
<td>Exception program counter发生异常和中断后从哪里重新开始执行</td>
</tr>
</tbody>
</table>
<h4><span id="sr"><strong>SR</strong></span></h4>
<p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206164953902.png" alt="image-20231206164953902"></p>
<p>这里我们实际使用到的或者说有意义的只有</p>
<p><strong>IM——SR[15:10]</strong></p>
<blockquote>
<p>其实这里应该指的是SR[15:8]的这8位，其中IP1-0也就是SR[9:8]是由CPU内部产生的</p>
</blockquote>
<ul>
<li>中断屏蔽：一个8位的域定义哪些允许中断源活动时产生异常。其中6个中断源由CPU核外部的信号产生。其余两个是Cause寄存器中软件可写的中断位</li>
</ul>
<p><strong>EXL——SR[1]</strong></p>
<ul>
<li>异常级：任何异常发生时置位，这会强行进入核心态并禁止中断：目的是吧EXL位维持足够长的时间以便软件决定新的CPU特权级和中断屏蔽该设成什么</li>
</ul>
<p><strong>IE——SR[0]</strong></p>
<ul>
<li>全局的中断使能位：注意不管这位是什么值，EXL和ERL总是禁止所有的中断</li>
</ul>
<h4><span id="cause"><strong>Cause</strong></span></h4>
<p><img src="/2024/02/21/p7-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20231206170514085.png" alt="image-20231206170514085"></p>
<p><strong>BD——Cause[31]</strong></p>
<ul>
<li>
<p>分支延迟：EPC保存的是异常处理完之后的返回地址，正常情况下，这也指向异常受害指令。</p>
</li>
<li>
<p>但是如果发生异常的指令是在一条转移指令的延时槽里，EPC得指向那条转移指令：重新执行转移指令没有- 什么害处，但是如果返回到延迟槽指令本身，转移就不会发生，从而这个异常将破坏被中断的程序。</p>
</li>
<li>
<p>只要异常发生在延迟槽的指令，Cause(BD)就会置为，EPC就会指向分支指令。如果想要分析异常受害指令，只要看看Cause(BD)(如果Cause(BD)==1，那么该指令位于EPC+4)就知道了。</p>
</li>
</ul>
<p><strong>IP——Cause[15:10]</strong></p>
<blockquote>
<p>这里其实也是IM一个道理</p>
</blockquote>
<p>待决的中断：这里表示待发生的中断。IP照抄CPU硬件的输入信号，<code>IP1-0</code>（软件中断位）可读可写包含你最近写入的值。</p>
<ul>
<li>当相应的<code>SR(IM)</code>位（还要受到其它禁止中断的条件约束）允许时，这八位中的任意以为活动都会导致一个中断</li>
</ul>
<p><strong>BD——Cause[6:2]</strong></p>
<p>这是一个5位的编码，告诉你发生了哪种异常。</p>
<table>
<thead>
<tr>
<th>ExcCode</th>
<th>助记符</th>
<th>指令与指令类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Int</td>
<td>所有指令</td>
<td>中断</td>
</tr>
<tr>
<td>4</td>
<td>AdEL</td>
<td>所有指令<br>load型指令（或特指其中某型）</td>
<td>（取数，取指或者存数时）地址错误：<br>PC地址未字对齐<br>PC地址超过0x3000-0x6ffc<br><br> （取数，取指或者存数时）地址错误：<br><strong>lw</strong>：取数地址未与4字节对齐<br><strong>lh</strong>：取数地址未与2字节对齐<br><strong>lh，lb</strong>：取Timer</td>
</tr>
<tr>
<td>5</td>
<td>AdES</td>
<td>store型指令</td>
<td>（取数，取指或者存数时）地址错误：<br><strong>sw</strong>：存数地址未4字节对齐<br><strong>sh</strong>：存数地址未2字节对齐<br><strong>sh，sb</strong>：存Timer寄存器的值<br>store型指令：<br>计算地址加法溢出<br>向计时器的Count寄存器存值<br>存数地址超过DM，Timer0，Timer1，中断发生器的范围</td>
</tr>
<tr>
<td>8</td>
<td>Syscall</td>
<td>syscall</td>
<td>系统调用，执行了一条syscall指令</td>
</tr>
<tr>
<td>10</td>
<td>RI</td>
<td></td>
<td>出现未知的指令码</td>
</tr>
<tr>
<td>12</td>
<td>Ov</td>
<td>add,addi,sub</td>
<td>算数溢出</td>
</tr>
</tbody>
</table>
<h4><span id="epc">EPC</span></h4>
<p>异常返回地址寄存器。这是一个博爱村异常返回点的寄存器。导致（或者遭受）异常的指令地址存入EPC，除非Cause寄存器中的BD位置位了，这种情况下EPC指向前一条（分支）指令</p>
<p>​	<strong>CPU控制指令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mtc0</td>
<td>s,&lt;n&gt;</td>
<td>把数据传送到CP0<br>把CPU通用寄存器s中的内容传送到CP0的寄存器n<br>数据为32位</td>
</tr>
<tr>
<td>mfc0</td>
<td>d,&lt;n&gt;</td>
<td>从协处理器中取出数据<br>通用寄存器d中装入CPU控制寄存器n的值<br>这是查看控制寄存器的值的唯一方式</td>
</tr>
</tbody>
</table>
<p>关于mfc0</p>
<p>想要更新控制寄存器中的单个域——比如说——状态寄存器SR</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mfc0 t0, SR
and  t0, &lt;要清零的为的反码&gt;
or   t0, &lt;要置1的位&gt;
mtc0 SR, t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这里有一个比较抽象的话后续再来理解一下</p>
<p>即返回到用户态和改变特权级的操作必须是同步的，不可分的（原文只讲了不可分的，我的理解就是同步的进行操作）</p>
<p>用软件触发的异常——异常调用——作为用户代码请求（运行在高特权级上的）操作系统内核服务的唯一机制。</p>
</blockquote>
<p><strong>什么时候需要用到哪些寄存器</strong></p>
<blockquote>
<p>这里是针对CP0中的控制寄存器而言的</p>
</blockquote>
<p><strong>上电后：</strong></p>
<p>设置SR来使CPU进入一个可工作的状态</p>
<p><strong>处理任意异常：</strong></p>
<ul>
<li>
<p>早期：调用一个固定入口地址的公共的“通用异常处理程序”</p>
</li>
<li>
<p>自那以后：对不同目的使用分开的异常处理程序</p>
</li>
</ul>
<p>在异常入口处：不保存任何程序寄存器，只有返回地址被存在EPC中。</p>
<p><strong>从异常返回：</strong></p>
<ol>
<li>控制最终必须返回到异常入口处保存到EPC中的地址。</li>
<li>不管是什么异常，返回时都需要报SR寄存器调整回原来的值，恢复用户态特权、允许中断以及消除异常的一般影响</li>
<li>异常返回指令eret合并完成了返回用户空间和复位SR(EXL)的功能</li>
</ol>
<p><strong>中断：</strong></p>
<p>SR用来调整中断掩码（掩码就是一串二进制码，掩码的作用是用来存储和操作“状态”）</p>
<p><strong>纯粹为了引发异常的指令：</strong></p>
<p>比如<code>break</code>和<code>syscall</code></p>
<h2><span id="异常-中断及初始化">异常、中断及初始化</span></h2>
<ul>
<li>外部事件：在CPU核之外的时间——即来自于真实的“连线”上的输入信号，这就是中断。</li>
<li>存储器地址转换异常</li>
<li>程序或硬件检测到的错误：这些包括不存在的指令、在用户权限下非法的指令、在相应SR位被禁止是执行的协处理器指令、整数溢出、地址对齐出错、用户态中访问kuseg以外的地址</li>
<li>系统调用和自陷</li>
</ul>
<h3><span id="精确异常">精确异常</span></h3>
<p>也就是我们的宏观pc的来由，如果某个pc是异常受害指令，那么我们希望在这个指令之前的指令已经全部处理完成，在这个指令之后的还没有开始处理。</p>
<p>全部内容如下：</p>
<ul>
<li>明确的罪证：在任何异常之后，CPU的控制寄存器EPC都指向一个正确的地方，异常处理之后从该处开始重新执行。在大多数情形中，EPC指向异常受害指令，但是如果异常受害指令处于分支延迟槽内，则EPC指向前面的分支指令：返回到分支指令去重新执行受害指令，但是返回到受害指令将导致分支被忽略。
<ul>
<li>当受害指令处于分支延迟槽内时，原因寄存器的Cause(BD)位置位</li>
</ul>
</li>
<li>异常出现在指令序列中：由于是流水线，而且在不同的流水级都有可能会出现问题，但是我们为了实现精确异常，不应该是出现异常就处理，也就是出现第二条指令的异常事件先发生时需要先处理第一条指令
<ul>
<li>为了避免这一个问题，早期发现的异常并不立即采取措施：该事件只是被记录并沿着流水线传递。在大多数CPU设计中，指定一个特定的流水线阶段作为检测异常的地方。如果当我们的异常记录正沿着流水线向下传递，更老的指令的后期检测到的事件到达了这个终点线，此时异常记录就直接丢弃。</li>
</ul>
</li>
<li>后续指令无效：因为流水线的原因，处于EPC中的受害指令之后的指令就已经开始了。</li>
</ul>
<h3><span id="非精确异常">非精确异常</span></h3>
<blockquote>
<p>这里实际上指的是历史上的MPIS CPU的乘法器，也就是我们P6的内容，采取直接发送一个busy信号的处理方法，这里我们不在进行讨论</p>
</blockquote>
<p><strong>异常发生的时机</strong></p>
<p>因为异常是精确的，那么异常发生的时间应当也是没有歧义的：</p>
<ul>
<li>异常之前执行的最后一条指令就是异常受害指令的前一条。</li>
<li>如果该异常不是中断：受害指令即是引发异常的指令</li>
</ul>
<blockquote>
<p>下面是MIPS CPU决定处理一个异常是所要做的</p>
</blockquote>
<ol>
<li>设置EPC指向重新开始的地址</li>
<li>设置SR(EXL)位，强制CPU进入内核态（高特权态）并且禁止中断</li>
<li>设置Cause寄存器这样软件可以看到发生异常的原因。在地址异常时，BadVAddr也要设置<strong>但是我们课程好像没有这个要求</strong></li>
<li>然后CPU开始从异常入口点取值，此后一切交给软件处理。<strong>其实也就是继续进行handler处理程序的执行部分</strong></li>
</ol>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p7</tag>
      </tags>
  </entry>
  <entry>
    <title>p5p6-流水线</title>
    <url>/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1>
<p>实现五级流水线CPU</p>
<span id="more"></span>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<h3><span id="实现指令说明">实现指令说明</span></h3>
<p>将本CPU实现的指令分为以下几类：</p>
<table>
<thead>
<tr>
<th>classify</th>
<th>指令set</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>lw//lh,lhu,lb,lbu</td>
</tr>
<tr>
<td>store</td>
<td>sw//sh,sb</td>
</tr>
<tr>
<td>calc_r</td>
<td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td>
</tr>
<tr>
<td>calc_i</td>
<td>ori//addiu,addi,xori,slti,sltiu</td>
</tr>
<tr>
<td>shift_s</td>
<td>sll//sra,srl</td>
</tr>
<tr>
<td>shift_v</td>
<td>//sllv,srav,srlv</td>
</tr>
<tr>
<td>b_type</td>
<td>beq//bne</td>
</tr>
<tr>
<td>j</td>
<td>jal,j</td>
</tr>
<tr>
<td>特殊</td>
<td>jr,lui</td>
</tr>
</tbody>
</table>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
<h3><span id="命名规范">命名规范</span></h3>
<ul>
<li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li>
<li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li>
<li>寄存器文件采用两边的流水线层级加上_REG的方式。</li>
</ul>
<h2><span id="数据通路datapath">数据通路DataPath</span></h2>
<p>同P4，变量命名有稍微修改。</p>
<p>但没有单独使用一个DataPath的模块，显得比较多余。</p>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>i_en</td>
<td>I</td>
<td>1</td>
<td>使能信号</td>
</tr>
<tr>
<td>i_npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>or_pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>o_instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>i_npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>i_imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>i_jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>i_ra_of_jr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>o_npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC4</td>
<td>3</td>
<td>3‘b000</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>3</td>
<td>3’b001</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>3</td>
<td>3’b010</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>3</td>
<td>3’b011</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p5p6-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>i_writeEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>i_A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>i_A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>i_WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>o_RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>o_RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>用于$display</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>i_unsigned_ext_Sel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>o_imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMP_EQUAL</td>
<td>4</td>
<td>4‘b0000</td>
<td>判断是否相等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3>
<p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">信号名</th>
<th style="text-align:left">方向</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALUOp</td>
<td style="text-align:left">I</td>
<td style="text-align:left">4</td>
<td style="text-align:left">ALU 功能选择信号</td>
</tr>
<tr>
<td style="text-align:left">src_A</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第一个值</td>
</tr>
<tr>
<td style="text-align:left">src_B</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第二个值 S</td>
</tr>
<tr>
<td style="text-align:left">shamt</td>
<td style="text-align:left">I</td>
<td style="text-align:left">5</td>
<td style="text-align:left">移位数输入</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">O</td>
<td style="text-align:left">32</td>
<td style="text-align:left">输出 ALU 计算结果</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>00000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>00001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>00010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>00011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>00100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>00101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>00110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>00111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>01000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>01001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>01010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>i_Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>i_dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>i_WriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_writeData</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>o_RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>reset信号有效时，所有寄存器的中存储的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A地址对应的存储单元的数据，将其加载到RD</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td>
</tr>
</tbody>
</table>
<h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2>
<p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p>
<h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v 中的 clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v 中的 reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器使能信号</td>
<td style="text-align:left">HCU 中 stall 信号取反</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器清空信号</td>
<td style="text-align:left">默认为 1‘b0</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 instr 输入</td>
<td style="text-align:left">IFU_instr</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 pc 输入</td>
<td style="text-align:left">IFU_pc</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 instr 输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 pc 输出</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from EXT</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p>
</li>
</ul>
<h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3>
<ul>
<li>
<p>端口定义</p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left">关于sw的来自GRF_RD2的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<blockquote>
<p>我这里暂停部分在专门的一个模块HU中解决了</p>
</blockquote>
<p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p>
</li>
</ul>
<h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>接口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left">来自dm的数据读出信号</td>
<td style="text-align:left">from M_DM</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2><span id="控制单元_cu">控制单元_CU</span></h2>
<p>输入改为instr，之前为opcode和func</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0]</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="分支转移实现">分支转移实现</span></h3>
<h4><span id="b-类指令">B 类指令</span></h4>
<p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h4><span id="j-和-jal">j 和 jal</span></h4>
<p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p>
<h4><span id="jr">jr</span></h4>
<p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h2><span id="冒险处理">冒险处理</span></h2>
<p>冒险处理我们均通过 “A_T” 法实现 ——</p>
<h3><span id="转发forward">转发（forward）</span></h3>
<p><strong>无脑转发策略。</strong></p>
<p><strong>将所有在该层级后面的均进行转发。</strong></p>
<p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p>
<p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p>
<p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p>
<ul>
<li>
<p><strong>供应者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">流水级</th>
<th style="text-align:left">产生数据</th>
<th style="text-align:left">MUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">E_E32，E_pc8</td>
<td style="text-align:left">MUX_E_out &amp; SelEMOut</td>
<td style="text-align:left">E_out</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">M_AO，M_pc8</td>
<td style="text-align:left">MUX_M_out &amp; SelEMOut</td>
<td style="text-align:left">M_out</td>
</tr>
<tr>
<td style="text-align:left">W</td>
<td style="text-align:left">W_AO，W_RD，W_pc8</td>
<td style="text-align:left">MUX_W_out &amp; SelWOut</td>
<td style="text-align:left">W_out</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>需求者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">接收端口</th>
<th style="text-align:left">选择数据</th>
<th style="text-align:left">HMUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMP_D1/NPC_ra</td>
<td style="text-align:left">D_V1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td>
<td style="text-align:left">D_V1_f</td>
</tr>
<tr>
<td style="text-align:left">CMP_D2</td>
<td style="text-align:left">D_v1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td>
<td style="text-align:left">D_V2_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_A</td>
<td style="text-align:left">E_V1， W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_B</td>
<td style="text-align:left">E_V2，W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">DM_WD</td>
<td style="text-align:left">M_V2， W_out</td>
<td style="text-align:left">HMUX_DM &amp; FwdDM</td>
<td style="text-align:left">M_V2_f</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p>
<p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p>
<ul>
<li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li>
<li><strong>写使能信号有效</strong></li>
</ul>
<p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p>
<h3><span id="暂停stall">暂停（stall）</span></h3>
<p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p>
<p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p>
<ul>
<li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li>
<li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li>
</ul>
<p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p>
<ul>
<li>
<p><strong>Tuse 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tuse_rs</th>
<th style="text-align:left">Tuse_rt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">X</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jump</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">0</td>
<td style="text-align:left">X</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Tnew 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tnew_D</th>
<th style="text-align:left">Tnew_E</th>
<th style="text-align:left">Tnew_M</th>
<th style="text-align:left">Tnew_W</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jal</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">lui</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p>
<ul>
<li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li>
<li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li>
<li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li>
</ul>
<h1><span id="思考题">思考题</span></h1>
<blockquote>
<p>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p>
</blockquote>
<ul>
<li>我们使用两个寄存器值的时间最早来到了 D 级，所以很可能会引发暂停.</li>
<li>如下面这种情况，若 beq 的结果在 E 级产生，则不需要暂停，可以转发，但是现在 beq 在 D 级的时候 lw 还在 M 级，没有产生结果，需要暂停。</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw    $t0, 0($0)
nop
beq   $t0, $t0, label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</p>
</blockquote>
<ul>
<li>因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把 PC+8 写入寄存器，不然 jr 时延迟槽内的指令会再执行一次</li>
</ul>
<blockquote>
<p>3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？</p>
</blockquote>
<ul>
<li>因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</li>
</ul>
<blockquote>
<p>4、我们为什么要使用 GPR 内部转发？该如何实现？</p>
</blockquote>
<p>如果你W级写入数据的寄存器与D级读寄存器的地址相同时，将会你导致出现错误的数值，因此需要通过内部转发来规避数据冒险。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 内部转发</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_RD1_D<span class="token punctuation">,</span> D_FWD_RD2_D<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> D_FWD_RD1_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A1 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>
                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A1 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>
                                            r_rf<span class="token punctuation">[</span>i_A1<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token keyword">assign</span> D_FWD_RD2_D <span class="token operator">=</span> <span class="token punctuation">(</span> i_A2 <span class="token operator">==</span> <span class="token number">5'h0</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0</span><span class="token punctuation">:</span>
                         <span class="token punctuation">(</span><span class="token punctuation">(</span>i_A2 <span class="token operator">==</span> i_A3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> i_WD <span class="token punctuation">:</span>
                                            r_rf<span class="token punctuation">[</span>i_A2<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p>
</blockquote>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                                                D_grf_RD1<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> D_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">32'h0000_0000</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> E_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> E_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>D_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                                                D_grf_RD2<span class="token punctuation">;</span>

<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rs_RD1 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rs <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                E_grf_RD1<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> E_FWD_rt_RD2 <span class="token operator">=</span> <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> M_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> M_grf_writeData <span class="token punctuation">:</span>
                           <span class="token punctuation">(</span>E_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                E_grf_RD2<span class="token punctuation">;</span>

<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> M_FWD_writeData <span class="token operator">=</span> <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> <span class="token number">5'h0</span>    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span>
                              <span class="token punctuation">(</span>M_rt <span class="token operator">==</span> W_grf_WA<span class="token punctuation">)</span> <span class="token operator">?</span> W_grf_writeData <span class="token punctuation">:</span>
                                                   M_dm_writeData  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p>
</blockquote>
<ul>
<li>高内聚低耦合原理：大多数只需要改变控制信号以及相应的功能模块增加功能，但不排除某些需要修改数据通路</li>
<li>对于计算类：首先改变 MCU，注意每个指令的控制信号的对应，再改 ALU 的结构，增加输出选择</li>
<li>对于访存类：改变 MCU + 修改 DM 增加相应的功能</li>
<li>对于跳转类：修改 MCU+NPC 相应功能修改</li>
<li>小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。</li>
</ul>
<blockquote>
<p>7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p>
</blockquote>
<p>我采用的是分布式译码。我感觉分布式译码器确实从实际运用上讲会造成器件的浪费，但是单从code上来讲，确实会方便很多，其中把每个instr传进去也感觉十分方便。</p>
<p>但是可能不足在于修改了CU相应的部分，mips.v和HU.v都需要进行比较大的改动。</p>
<h3><span id="流水线冒险">流水线冒险</span></h3>
<ol>
<li>
<p><strong>在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</strong></p>
<p><strong>A</strong>：当需要进行暂停时，IFU 的使能信号失效，PC 值不变。当不需要进行分支转移和跳转时，NPC 中将 F_pc 信号加 4 处理返回 IFU，下一时钟沿来临时更新为 F_pc+4。当执行分支指令时，NPC 将 D_pc +4 和符号扩展后的 imm16 相加，返回 IFU，下一时钟沿上升时更新。当执行 j/jal 指令时，NPC 将 imm26 进行扩展（前四位补 D_pc 的前四位，后两位补 0），返回 IFU，下一时钟沿上升时更新。当执行 jr 指令时，NPC 将从 GRF 的 RD1 端口（考虑转发）输出的值输出，返回 IFU 下一时钟沿上升时更新。</p>
</li>
<li>
<p><strong>对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8 ？</strong></p>
<p><strong>A</strong>：因为需要考虑编译优化，jal 的下一条指令是延迟槽中的指令，在 jal 执行前会被执行。如果回写 PC+4 的话，当出现 “jr $ra” 时，将会回到延迟槽，重复执行延迟槽中的指令。因此需要回写 PC+8。</p>
</li>
</ol>
<h3><span id="数据冒险的分析">数据冒险的分析</span></h3>
<ol>
<li>
<p><strong>为什么所有的供给者都是存储了上一级传来的各种数据的流水级寄存器，而不是由 ALU 或者 DM 等部件来提供数据？</strong></p>
<p><strong>A</strong>：因为流水寄存器中的储存的数据时前一级已经计算出来的数据，在当前周期内时稳定输出的。而功能部件的输出是有延迟的，如果让这些部件提供数据，有可能再其在回写数据生成前就写入了错误的数据，导致数据波动。</p>
</li>
</ol>
<h3><span id="at-法处理流水线数据冒险">AT 法处理流水线数据冒险</span></h3>
<ol>
<li>
<p><strong>“转发（旁路）机制的构造” 中的 Thinking 1-4；</strong></p>
<p><strong>Thinking 1</strong>：如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</p>
<p><strong>A</strong>：例如：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">addi    $s0, $0, 4
andi	$s1, $s0, 5
sw      $s1, 4($s0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>Thinking 2</strong>：我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</p>
<p><strong>A</strong>：因为需要使得 W 级保存的将要写入得数据及时反馈到 GRF 的输出端口，从而规避数据冒险。如果不采用内部转发，我们可以在 GRF 的输出端口加入多路选择器，将 W 级的数据进行转发。</p>
<p><strong>Thinking 3</strong>：为什么 0 号寄存器需要特殊处理？</p>
<p><strong>A</strong>：因为对 0 号寄存器的写入是无效的，如果不特殊处理，则会使得向 0 号寄存器写入的数据（无效输入）被错误转发，从而造成 BUG。</p>
<p><strong>Thinking 4</strong>：什么是 “最新产生的数据”？</p>
<p><strong>A</strong>: 距离当前需求者最近的流水寄存器中储存的数据。</p>
</li>
<li>
<p><strong>在 AT 方法讨论转发条件的时候，只提到了 “供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 we 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了用且仅用 A 和 T 完成转发，在翻译出 A 的时候，要结合 we 做什么操作呢？</strong></p>
<p><strong>A</strong>： 因为当 we 信号为 0 时我们就把 RF 写入地址置为 0，因此如果 “供给者的 A 不为 0”，就已经排除了 “写入信号为 0” 的情况。</p>
</li>
</ol>
<h3><span id="在线测试相关说明">在线测试相关说明</span></h3>
<p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
<p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略，<strong>比如构造连续数据冒险序列，请你描述一下你使用的策略如何</strong>结合了随机性</strong>达到强测的效果。</p>
<p>此思考题请同学们结合自己测试 CPU 使用的具体手段，按照自己的实际情况进行回答。</p>
<p><strong>A</strong>：我是采用半随机生成半手动构造的方法。对于功能型指令，完全通过 python 脚本自动生成。并且为了提高数据冲突的概率，我们仅仅使用 0~7 号寄存器进行测试。对于跳转指令，我们先使用一定模板进行构建，然后为了增加数据冒险和控制冒险，我们又手动进行一定修改，使得测试样例尽可能更多的覆盖所有可能的情况</p>
<h3><span id="参考">参考</span></h3>
<p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p6</tag>
      </tags>
  </entry>
  <entry>
    <title>大一下数据结构大作业</title>
    <url>/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>暂时嘛，啥也没有</p>
<p>蒟蒻博主啥也不会捏</p>
<p>会了也不告诉你</p>
</blockquote>
<span id="more"></span>
<h2><span id="bug">bug</span></h2>
<blockquote>
<p>这里是大家可能会遇到的一些问题，我分享一些我的想法</p>
</blockquote>
<h2><span id="读题">读题</span></h2>
<p>要注意理解题目意思。大致就是首先统计article的词频。接着得到单词中非停用词的词频最多的前N个。（要注意不是每个网页的前N个，而是将所有article的网页的词频统计好之后的前N个（这个也就是特征向量）。然后通过<strong>题目描述的计算方式</strong>得到指纹。然后对每个sample的网页，同样统计特征向量中每个单词（注意这里变成了特征向量中的单词，而不需要所有的）的词频，通过<strong>题目描述的计算方式</strong>再次得到指纹。最后将每一个sample网页的指纹与所有article的指纹进行汉明距离的计算，然后统计输出。</p>
<h3><span id="第一种本地不对">第一种，本地不对</span></h3>
<p>本地不管是输出错误还是运行时错误，都可以采取打印调试法和逐步调试法。(debug是必修课喔~~)</p>
<h3><span id="第二种本地对小数据不对">第二种，本地对小数据不对</span></h3>
<p>嗯，这种情况其实到后面可以向助教祈求小数据的内容。</p>
<p>首先可能是windows与linux的差异。</p>
<p>也就是linux中每一行结束时\r\n，而windows是\n。</p>
<p>可以将文件打开Mode改为rb，看本地输出是否正确。</p>
<h3><span id="第三种小数据对大数据不对">第三种，小数据对大数据不对</span></h3>
<blockquote>
<p>这一种是最恼火的</p>
</blockquote>
<p>如果是输出错误，</p>
<ul>
<li>千万要注意article和sample的网页名。如果是直接以为就是样例中的1-%d这种的，那么就会出问题。建议改为从数组中解析或者fscanf。</li>
</ul>
<p>如果是运行时错误，</p>
<p>多半是数组开小了，或者malloc多了。</p>
<ul>
<li>这种情况下关键是找到哪里运行时错误了。可以在代码的不同位置return 0强制结束然。后看在哪个之前显示的是输出错误，过了那个就变成了运行时错误，那么就仔细看看应该如何解决。</li>
</ul>
<h2><span id="题目">题目</span></h2>
<p><img src="/2023/05/25/%E5%A4%A7%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%A7%E4%BD%9C%E4%B8%9A.png" alt></p>
<h2><span id="code">code</span></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// N 5000</span>
<span class="token comment">// M 64</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimize</span><span class="token punctuation">(</span></span><span class="token string">"Ofast"</span><span class="token expression"><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">low</span><span class="token expression"><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">&gt;=</span><span class="token number">65</span><span class="token operator">&amp;&amp;</span>c<span class="token operator">&lt;=</span><span class="token number">90</span> <span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">32</span><span class="token operator">+</span>c<span class="token operator">:</span>c<span class="token punctuation">)</span></span></span>
<span class="token comment">//#define low(c) (c|0x20)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NMAX</span> <span class="token expression"><span class="token number">10005</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MMAX</span> <span class="token expression"><span class="token number">130</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXHASH</span> <span class="token expression"><span class="token number">1280010</span></span></span>
<span class="token keyword">char</span> bufferHash<span class="token punctuation">[</span>MAXHASH<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSTOPCHARS</span> <span class="token expression"><span class="token number">10000</span></span></span>
<span class="token keyword">char</span> bufferStopChars<span class="token punctuation">[</span>MAXSTOPCHARS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXARTICLECHARS</span> <span class="token expression"><span class="token number">350000000</span></span></span>
<span class="token keyword">char</span> bufferArticleChars<span class="token punctuation">[</span>MAXARTICLECHARS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGENUMMAX</span> <span class="token expression"><span class="token number">16000</span></span></span>
<span class="token keyword">int</span> hash_better<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span><span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">myatoi</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">57</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tmp <span class="token operator">=</span> tmp <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">!=</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">-</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
        p2<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mystrcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mymemset_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">mystrcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
        p1<span class="token operator">++</span><span class="token punctuation">;</span>
        p2<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">++</span><span class="token punctuation">;</span>
        len<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">readHash</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferHash<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXHASH<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferHash<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            hash_better<span class="token punctuation">[</span>hash_i_line<span class="token punctuation">]</span><span class="token punctuation">[</span>hash_i<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">==</span> <span class="token number">48</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
            hash_i_line<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                hash_i<span class="token operator">++</span><span class="token punctuation">;</span>
                hash_i_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_stopWords<span class="token punctuation">[</span><span class="token number">1010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_stopWords <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">search_stopwords</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//就是1</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferStopChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXSTOPCHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> bufferStopChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_stopWords<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            num_stopWords<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_article<span class="token punctuation">[</span><span class="token number">1500010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aword</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span> word<span class="token punctuation">;</span>
word word_num_article<span class="token punctuation">[</span><span class="token number">106010</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_word <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pos_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> name_page<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_page <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len_article <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    len_article <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos_article<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search_stopwords</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">mystrcpy</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                word_num_article<span class="token punctuation">[</span>pos_word<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> p<span class="token punctuation">;</span>
                pos_word<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                num_page<span class="token operator">++</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    pos<span class="token operator">++</span><span class="token punctuation">;</span>
                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                    pos<span class="token operator">++</span><span class="token punctuation">;</span>
                    n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                name_page<span class="token punctuation">[</span>num_page<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            num_article<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>
    word <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>word <span class="token operator">*</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num_article<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span> <span class="token operator">-</span> num_article<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">mystrcmp</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>str<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> trie_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_N_words<span class="token punctuation">[</span><span class="token number">101000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">^</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            n <span class="token operator">=</span> word_num_article<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>pos<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> trie_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        num_N_words<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> weightArticle<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sumSignedWeightArticle<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
__uint128_t fingerprintArticle<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len_article<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> isNWords <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isNWords <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                weightArticle<span class="token punctuation">[</span>isNWords <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//0.96429S</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span> weightArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintArticle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignedWeightArticle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>__uint128_t a<span class="token punctuation">,</span> __uint128_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    __uint128_t c <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dist <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">=</span> c <span class="token operator">&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> weightSample<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sumSignWeightSample<span class="token punctuation">[</span>MMAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
__uint128_t fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> name_sample<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num_sample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> flag_ans<span class="token punctuation">[</span>PAGENUMMAX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>space <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">readSample</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in<span class="token punctuation">,</span> FILE <span class="token operator">*</span>out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MAXARTICLECHARS<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">^</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> flag_f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">48</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">!=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                n <span class="token operator">=</span> bufferArticleChars<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            name_sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            flag_f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&lt;=</span> <span class="token number">122</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
                n <span class="token operator">=</span> <span class="token function">low</span><span class="token punctuation">(</span>bufferArticleChars<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pos<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            temp<span class="token punctuation">[</span>temp_i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
            temp_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> ppage <span class="token operator">=</span> <span class="token function">search_N_words</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ppage <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            weightSample<span class="token punctuation">[</span>ppage <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            flag_f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            fingerprintSample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> N<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+=</span>weightSample<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> hash_better<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">^</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    fingerprintSample <span class="token operator">=</span> <span class="token punctuation">(</span>fingerprintSample <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>weightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">mymemset_int</span><span class="token punctuation">(</span>sumSignWeightSample<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token punctuation">(</span>num_page <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                distance <span class="token operator">=</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span>fingerprintSample<span class="token punctuation">,</span> fingerprintArticle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> name_page<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">mystrcat</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>distance<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> name_sample<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">^</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag_ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n%d:"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">fwrite</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>num_sample<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            num_sample<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    N <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    M <span class="token operator">=</span> <span class="token function">myatoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>pp_result <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"result.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_stop <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"stopwords.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_article <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"article.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_sample <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"sample.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp_hashvalue <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"hashvalue.txt"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">readHash</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_hashvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createStopwordsTrie</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.01427S</span>
    <span class="token function">createArticleTrie</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp_article<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.39820S</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">,</span> pos_word <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>word_num_article<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.49212S</span>
    <span class="token function">createNWordsTrie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//0.50967</span>
    <span class="token function">reReadArticle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//3.53592S</span>
    <span class="token function">readSample</span><span class="token punctuation">(</span>fp_sample<span class="token punctuation">,</span> pp_result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//    fclose(fp_sample);</span>
<span class="token comment">//    fclose(pp_result);</span>
    <span class="token comment">//3.63961S</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="version5说明">version5说明</span></h2>
<p>这里我优化了计算指纹的部分。我将计算的循环次序进行了交换，同时我判断weight是否为0，如果是就不需要进行循环了。</p>
<p>这个版本在优化后最终也是跑到了<code>1.15s</code></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>大作业优化</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2023/05/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1><span id="使用两个栈实现一个队列两个队列实现一个栈">使用两个栈实现一个队列，两个队列实现一个栈</span></h1>
<blockquote>
<p>总感觉这像是一个面试题		——hugo</p>
</blockquote>
<span id="more"></span>
<p>栈是一种后入先出(Last In First Out, LIFO)的数据结构，队列是一种先进先出(First In First Out, FIFO)的数据结构。</p>
<h2><span id="两个栈实现一个队列">两个栈实现一个队列</span></h2>
<p>思路一：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p>
<p>入队：</p>
<p><code>push_s1(item)</code></p>
<p>出队：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>top_s2 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push_s1</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即<code>s1</code>式负责元素的存储，<code>s2</code>作为过渡栈，每次元素出队矩利用到<code>s2</code>;</p>
<p>但是整个过程中出队入队显然太麻烦了，那么对此进行优化有：</p>
<p>我们其实可以发现对<code>s2</code>中的<code>top</code>元素<code>pop</code>后其实不一定需要再全部倒回<code>s1</code>，</p>
<p>那么就有：</p>
<p>思路二：<code>s1</code>进行入队操作,<code>s2</code>进行出队操作</p>
<p>入队：</p>
<p><code>push_s1(item)</code></p>
<p>出队：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top_s2 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>top_s1 <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	tmp <span class="token operator">=</span> <span class="token function">pop_s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">push_s2</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token function">pop_s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>思路二主要就是减少了两个栈之间元素的转移。</p>
<h2><span id="两个队列实现一个栈">两个队列实现一个栈</span></h2>
<p>思路一：<code>q1</code>负责出栈，<code>q2</code>只是一个中转</p>
<p>入栈：</p>
<p><code>q1[rear1++]=item</code></p>
<p>出栈：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>front1 <span class="token operator">&lt;</span> rear1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    q2<span class="token punctuation">[</span>rear2<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
item <span class="token operator">=</span> q1<span class="token punctuation">[</span><span class="token operator">++</span>front1<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>front2 <span class="token operator">&lt;</span> rear2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    tmp <span class="token operator">=</span> q2<span class="token punctuation">[</span><span class="token operator">++</span>front2<span class="token punctuation">]</span><span class="token punctuation">;</span>
    q1<span class="token punctuation">[</span>rear1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>思路二：<code>q1</code>和<code>q2</code>都负责进出栈</p>
<p>入栈：</p>
<p>如果<code>q1</code>和<code>q2</code>都为空，随便入一个队即可，这里选择入<code>q1</code>；</p>
<p>如果一个队列为空，另一个队列非空，则入非空队；</p>
<p>如果都非空，则入<code>q1</code>即可。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>rear1 <span class="token operator">==</span> front <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rear2 <span class="token operator">==</span> front2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    q2<span class="token punctuation">[</span><span class="token operator">++</span>rear2<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    q1<span class="token punctuation">[</span><span class="token operator">++</span>rear1<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>出栈：</p>
<p>如果一个队列为空，另一个队列非空，则仿造思路1将非空队列的队尾元素出队；</p>
<p>如果两个队列都非空，则将<code>q1</code>的队尾元素出队，其他元素入队<code>q2</code>。即把不为空的队列中除最后一个元素外的所有元素移动到另一个队列中，然后出队最后一个元素。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>p7-流水线</title>
    <url>/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1><span id="mathscr-hugo-mathbbcpu-五级流水线mathscrdesign">$\mathscr {Hugo}$ $\mathbb{CPU}$ 五级流水线$\mathscr{Design}$</span></h1>
<blockquote>
<p>这里是hugo的blog</p>
</blockquote>
<blockquote>
<p>P6-P7</p>
</blockquote>
<h2><span id="mips微系统">MIPS微系统</span></h2>
<p>有亿点点麻烦，首先阐释具体的概念，然后是工程化的应用。</p>
<ul>
<li>P7的任务是实现一个简单的计算机系统，即“mips微系统”</li>
<li>为了实现CPU的异常报告和与外设进行复杂的交互</li>
</ul>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/%E5%BE%AE%E7%B3%BB%E7%BB%9F.png" alt="img"></p>
<h3><span id="外设">外设</span></h3>
<p>暂时不重要</p>
<ul>
<li>Timer</li>
<li>Memory</li>
<li>InterruptGenerator</li>
</ul>
<p>Timer那里的是定时产生时钟中断。</p>
<p>InterruptGenerator是产生随机的外部中断信号，用来模拟外界情形</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/structure-1701416411059-3.svg" alt="structure"></p>
<blockquote>
<ul>
<li>
<p><strong>Q：我们计组课程一本参考书目标题中有 “硬件 / 软件接口” 接口字样，那么到底什么是 “硬件 / 软件接口”？(Tips：什么是接口？和我们到现在为止所学的有什么联系？)</strong></p>
<p><strong>A：</strong> 硬件 / 软件接口是指软件和硬件之间数据交互的接口。在我看来，这个应该指的是操作系统，操作系统将外部软件程序的机器码传入 core，由 core 执行；而 core 执行后产生的数据又通过操作系统传给软件。</p>
</li>
<li>
<p><strong>Q：BE 部件对所有的外设都是必要的吗？</strong></p>
<p><strong>A：</strong> 我认为没有必要，BE 部件是为了实现 DM 按字节访存设置的，而其他的部件例如 Timer 仅仅支持按字访存，因此不需要 BE 部件。</p>
</li>
<li>
<p><strong>Q：请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</strong></p>
<p><strong>A：</strong> 鼠标和键盘等外设并不是直接与 CPU 相连的，中间需要通过软件来连接，这个软件也就是我们熟知的驱动。驱动和硬件之间通过操作系统进行处理。</p>
</li>
<li>
<p><strong>Q:</strong> 请开发一个主程序以及定时器的 exception handler。整个系统完成如下功能：</p>
<p>（1）定时器在主程序中被初始化为模式 0；</p>
<p>（2）定时器倒计数至 0 产生中断；</p>
<p>（3）handler 设置使能 Enable 为 1 从而再次启动定时器的计数器。(2) 及 (3) 被无限重复。</p>
<p>（4）主程序在初始化时将定时器初始化为模式 0，设定初值寄存器的初值为某个值，如 100 或 1000。（注意，主程序可能需要涉及对 <a href="http://CP0.SR">CP0.SR</a> 的编程，推荐阅读过后文后再进行。）</p>
<p><strong>A:</strong></p>
<p>verilog</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">主程序<span class="token punctuation">:</span>
<span class="token punctuation">.</span>text
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>xfc01
mtc0 <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$12</span>
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x0
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">288</span>
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f04
ori <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9
sw <span class="token kernel-function property">$t0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
addi <span class="token kernel-function property">$t1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">1</span>
loop<span class="token punctuation">:</span>
add <span class="token kernel-function property">$s0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s2</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
add <span class="token kernel-function property">$s3</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span>
j loop
异常处理程序<span class="token punctuation">:</span>
<span class="token punctuation">.</span>ktext <span class="token number">0</span>x00004180
ori <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x1
ori <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token kernel-function property">$0</span><span class="token punctuation">,</span> <span class="token number">0</span>x9
sw <span class="token kernel-function property">$k0</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
sw <span class="token kernel-function property">$k1</span><span class="token punctuation">,</span> <span class="token number">0</span>x7f00
eret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</blockquote>
<blockquote>
<p>P5-P6</p>
</blockquote>
<p>本次迭代新增了不少calc_r,calc_i型指令，这类指令基本上不敲错code基本上没啥问题，对于新增的md,mt,mf类型的指令，新增一个D_MDU进行处理。</p>
<p>关键这里将IM和DM进行了外置</p>
<blockquote></blockquote>
<p>实现五级流水线CPU</p>
<ul>
<li>命名统一采用hugo命名法（借鉴了匈牙利命名法和下划线命名）</li>
<li>主体为mips.v模块，不再像P4一样加入DataPath模块，统一在mips.v中完成连线等大部分操作。</li>
<li>控制部分分为<code>Ctrl_Unit</code>和<code>Hazard_Ctrl</code>两个部分，处理冲突为在能够使用旁路转换的情况下尽可能的使用旁路转换</li>
<li>流水线阶段分为IF，ID，EX，MEM，WB五个部分
<ul>
<li>F：<code>NPC</code>,<code>PC</code>,<code>IM</code></li>
<li>D: <code>GRF</code>,<code>EXT</code>,<code>CMP</code></li>
<li>E: <code>ALU</code></li>
<li>M: <code>DM</code></li>
<li>W: <code>GRF</code></li>
</ul>
</li>
<li>其中用到大部分的宏定义在<code>def.v</code>中定义</li>
</ul>
<h2><span id="cpu流水线的实现">CPU流水线的实现</span></h2>
<h3><span id="实现指令说明">实现指令说明</span></h3>
<p>将本CPU实现的指令分为以下几类：</p>
<table>
<thead>
<tr>
<th>classify</th>
<th>指令set</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>lw//lh,lhu,lb,lbu</td>
</tr>
<tr>
<td>store</td>
<td>sw//sh,sb</td>
</tr>
<tr>
<td>calc_r</td>
<td>add,sub//addu, subu,and,or,nor,xor,slt,sltu</td>
</tr>
<tr>
<td>calc_i</td>
<td>ori//addiu,addi,xori,slti,sltiu</td>
</tr>
<tr>
<td>shift_s</td>
<td>sll//sra,srl</td>
</tr>
<tr>
<td>shift_v</td>
<td>//sllv,srav,srlv</td>
</tr>
<tr>
<td>b_type</td>
<td>beq//bne</td>
</tr>
<tr>
<td>j</td>
<td>jal,j</td>
</tr>
<tr>
<td>特殊</td>
<td>jr,lui</td>
</tr>
</tbody>
</table>
<p>基本的数据通路</p>
<p>IF阶段的pc需要保留到后面继续使用</p>
<p>重点处理的在于ALU</p>
<h3><span id="命名规范">命名规范</span></h3>
<ul>
<li>对于每一个模块依旧采用仅有文件英文名的办法，对于其实例化为_小写</li>
<li>对于每一条线采用层级+命名的方式（原本采用的是匈牙利命名法，也就是前面加上对应的类型，后发现全部都是wire，遂弃之）</li>
<li>寄存器文件采用两边的流水线层级加上_REG的方式。</li>
</ul>
<h2><span id="数据通路datapath">数据通路DataPath</span></h2>
<p>同P4，变量命名有稍微修改。</p>
<p>但没有单独使用一个DataPath的模块，显得比较多余。</p>
<p>对于一个数据路径，包括取指令(IF)，译码(ID)，执行(EX)，访存(MEM)，回写(WB)这几个方面，相应的有IFU，NPC，GRF，ALU，IM，DM这几个基本单元，单元之间通过Splitter和MUX等进行元件之间的数据交换和处理，这里需要在构建是需要留下几个控制信号的接口，以便于最后CU（控制器单元）单元的构建。</p>
<h3><span id="ifu取指令单元">IFU取指令单元</span></h3>
<p>该模块由PC（Programming Counter)模块和IM（Instruction Memory）模块组成。其中PC模块负责对每次新的指令状态进行转移，IM模块则从ROM中得到相应的指令。</p>
<blockquote>
<p>这里考虑到之后<u><strong>可能</strong></u>需要将IM和DM放到一起，这里不再对PC和IM进行进一步的封装。</p>
</blockquote>
<h4><span id="f_pc程序计数器">F_PC（程序计数器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号</td>
</tr>
<tr>
<td>i_en</td>
<td>I</td>
<td>1</td>
<td>使能信号</td>
</tr>
<tr>
<td>i_npc</td>
<td>I</td>
<td>32</td>
<td>通过计算得到的下一条指令的地址</td>
</tr>
<tr>
<td>or_pc</td>
<td>O</td>
<td>32</td>
<td>状态转移后的地址，输出当前正在执行的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>当Reset信号有效时，将PC寄存器中的值置为0x00003000</td>
</tr>
<tr>
<td>2</td>
<td>停止</td>
<td>当Stop信号有效时，PC寄存器忽略时钟输入，PC当前值保持不变</td>
</tr>
<tr>
<td>3</td>
<td>写 PC 寄存器</td>
<td>当 Stop 信号失效且时钟上升沿来临时，将下一条指令的地址（next PC）写入 PC 寄存器</td>
</tr>
</tbody>
</table>
<h4><span id="f_im指令存储器">F_IM（指令存储器）</span></h4>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前正在执行的地址</td>
</tr>
<tr>
<td>o_instr</td>
<td>O</td>
<td>32</td>
<td>输出当前正在执行的指令</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>取指令</td>
<td>根据当前PC的值从IM中读出对应的指令</td>
</tr>
</tbody>
</table>
<h3><span id="d_npc下一指令计算单元">D_NPC（下一指令计算单元）</span></h3>
<p>计算下一个指令，有三种方式，包括直接计算下一条指令，b型跳转指令，j型跳转指令。其中j型跳转指令包括跳转到寄存器的值和直接跳转两种。</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>当前指令地址</td>
</tr>
<tr>
<td>i_npcOp</td>
<td>I</td>
<td>2</td>
<td>NPC控制信号</td>
</tr>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>branch类型的16位立即数</td>
</tr>
<tr>
<td>i_imm26</td>
<td>I</td>
<td>26</td>
<td>jump类型的26位立即数</td>
</tr>
<tr>
<td>i_jumpEn</td>
<td>I</td>
<td>1</td>
<td>用于得到branch类型的跳转条件是否成立</td>
</tr>
<tr>
<td>i_ra_of_jr</td>
<td>I</td>
<td>32</td>
<td>寄存器中存储的地址</td>
</tr>
<tr>
<td>o_npc</td>
<td>O</td>
<td>32</td>
<td>下一条指令地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选择信号类型</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NPC_PC4</td>
<td>3</td>
<td>3‘b000</td>
<td>pc+4</td>
</tr>
<tr>
<td>NPC_J</td>
<td>3</td>
<td>3’b001</td>
<td>直接跳转，26位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_B</td>
<td>3</td>
<td>3’b010</td>
<td>条件跳转，满足条件跳转到16位立即数拓展后的地址</td>
</tr>
<tr>
<td>NPC_JR</td>
<td>3</td>
<td>3’b011</td>
<td>跳转到寄存器存储的地址</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>三种跳转指令</strong></li>
</ul>
<p><strong>b型跳转指令</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163128067.png" alt="image-20231026163128067"></p>
<p>均为判断后跳转到label（即Offset）</p>
<p><strong>JR型跳转指令(jr,jalr)</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026163459284.png" alt="image-20231026163459284"></p>
<p>跳转到寄存器中的存储的地址</p>
<p><strong>J型跳转指令(j,jal)</strong></p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231026164030190.png" alt="image-20231026164030190"></p>
<p>跳转到target这个立即数对应的地址</p>
<p>其实也可以分为：</p>
<p><strong>间接寻址</strong>（通过PC+4和Offset寻址）</p>
<p><strong>直接寻址</strong>（直接跳转到立即数对应地址，或者寄存器中存储的地址）</p>
<h3><span id="d_grf通用寄存器组">D_GRF（通用寄存器组）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>异步复位信号<br>1：复位信号有效<br>0：复位信号无效</td>
</tr>
<tr>
<td>i_writeEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_A1</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD1</td>
</tr>
<tr>
<td>i_A2</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其中的数据读出到 RD2</td>
</tr>
<tr>
<td>i_A3</td>
<td>I</td>
<td>5</td>
<td>地址输入信号，指定 32 个寄存器中的一个，将其作为写入目标</td>
</tr>
<tr>
<td>i_WD</td>
<td>I</td>
<td>32</td>
<td>数据输入信号</td>
</tr>
<tr>
<td>o_RD1</td>
<td>O</td>
<td>32</td>
<td>输出A1指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td>o_RD2</td>
<td>O</td>
<td>32</td>
<td>输出A2指定的寄存器中的 32 位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>i_pc</td>
<td>I</td>
<td>32</td>
<td>用于$display</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>Reset 信号有效时，所有寄存器中储存的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出 A1，A2 地址对应的寄存器中储存的数据，将其加载到 RD1 和 RD2</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当 WE 信号有效且时钟上升沿来临时，将 WD 中的数据写入到 A3 地址对应的寄存器</td>
</tr>
</tbody>
</table>
<h3><span id="d_ext拓展单元">D_EXT（拓展单元）</span></h3>
<p>将16位立即数符号拓展为32位。这里为了提高可拓展性，添加了<code>UnsignedExt</code>接口</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_imm16</td>
<td>I</td>
<td>16</td>
<td>16位立即数输入信号</td>
</tr>
<tr>
<td>i_unsigned_ext_Sel</td>
<td>I</td>
<td>1</td>
<td>无符号拓展信号<br>1：无符号拓展（0拓展）<br>0：符号拓展</td>
</tr>
<tr>
<td>o_imm32</td>
<td>O</td>
<td>32</td>
<td>32位立即数输出信号</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>符号拓展</td>
<td>将16位立即数进行符号拓展</td>
</tr>
</tbody>
</table>
<h3><span id="d_cmpb类指令比较单元">D_CMP(B类指令比较单元)</span></h3>
<p>用于生成Branch类跳转信号是否跳转的使能信号。该单元根据输入的branchOp信号对当前B指令的类型进行判断，进而对当前输入的数值进行比较，最后输出结果。</p>
<ul>
<li>端口定义</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_cmpA</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_cmpB</td>
<td>I</td>
<td>32</td>
<td>输入信号</td>
</tr>
<tr>
<td>i_branchOp</td>
<td>I</td>
<td></td>
<td>比较类型</td>
</tr>
<tr>
<td>jumpOp</td>
<td>O</td>
<td>1</td>
<td>是否满足跳转条件</td>
</tr>
</tbody>
</table>
<ul>
<li>功能定义</li>
</ul>
<table>
<thead>
<tr>
<th>branchOP</th>
<th>位宽</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMP_EQUAL</td>
<td>4</td>
<td>4‘b0000</td>
<td>判断是否相等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="e_alu逻辑运算单元">E_ALU（逻辑运算单元）</span></h3>
<p>该模块可实现加，减，按位与，按位或等 11 种运算，并根据 ALUOP 信号的值在这些功能中进行选择。除此之外，该模块还可以实现溢出判断</p>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">信号名</th>
<th style="text-align:left">方向</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ALUOp</td>
<td style="text-align:left">I</td>
<td style="text-align:left">4</td>
<td style="text-align:left">ALU 功能选择信号</td>
</tr>
<tr>
<td style="text-align:left">src_A</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第一个值</td>
</tr>
<tr>
<td style="text-align:left">src_B</td>
<td style="text-align:left">I</td>
<td style="text-align:left">32</td>
<td style="text-align:left">参与 ALU 计算的第二个值 S</td>
</tr>
<tr>
<td style="text-align:left">shamt</td>
<td style="text-align:left">I</td>
<td style="text-align:left">5</td>
<td style="text-align:left">移位数输入</td>
</tr>
<tr>
<td style="text-align:left">out</td>
<td style="text-align:left">O</td>
<td style="text-align:left">32</td>
<td style="text-align:left">输出 ALU 计算结果</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>ALUOp</th>
<th>指令</th>
<th>Opcode</th>
<th>Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td>add</td>
<td>00000</td>
<td>ALURes = SrcA+SrcB</td>
</tr>
<tr>
<td>减法</td>
<td>sub</td>
<td>00001</td>
<td>ALURes = SrcA-SrcB</td>
</tr>
<tr>
<td>乘法(low)</td>
<td>mul</td>
<td>00010</td>
<td>ALURes = SrcA*SrcB</td>
</tr>
<tr>
<td>除法(商)</td>
<td>div</td>
<td>00011</td>
<td>ALURes = SrcA / SrcB</td>
</tr>
<tr>
<td>与运算</td>
<td>and</td>
<td>00100</td>
<td>ALURes = SrcA &amp; SrcB</td>
</tr>
<tr>
<td>或运算</td>
<td>or</td>
<td>00101</td>
<td>ALURes = SrcA | SrcB</td>
</tr>
<tr>
<td>异或运算</td>
<td>xor</td>
<td>00110</td>
<td>ALURes = SrcA $\oplus$ SrcB</td>
</tr>
<tr>
<td>或非运算</td>
<td>nor</td>
<td>00111</td>
<td>ALURes = ~(SrcA | SrcB)</td>
</tr>
<tr>
<td>逻辑左移</td>
<td>sll</td>
<td>01000</td>
<td>ALURes = SrcB &lt;&lt; Shift</td>
</tr>
<tr>
<td>逻辑右移</td>
<td>srl</td>
<td>01001</td>
<td>ALURes = SrcB &gt;&gt; Shift</td>
</tr>
<tr>
<td>算数右移</td>
<td>sra</td>
<td>01010</td>
<td>ALURes = SrcB &gt;&gt;&gt; Shift</td>
</tr>
</tbody>
</table>
<h3><span id="m_dm数据存储器">M_DM（数据存储器）</span></h3>
<ul>
<li><strong>端口定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_clk</td>
<td>I</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>i_reset</td>
<td>I</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>i_Addr</td>
<td>I</td>
<td>32</td>
<td>内存中的地址信号</td>
</tr>
<tr>
<td>i_dmOp</td>
<td>I</td>
<td>2</td>
<td>选择信号<br>2’b00:word<br>2’b01:half_word<br>2’b10:byte</td>
</tr>
<tr>
<td>i_WriteEn</td>
<td>I</td>
<td>1</td>
<td>写使能信号<br>1：写入有效<br>0：写入无效</td>
</tr>
<tr>
<td>i_writeData</td>
<td>I</td>
<td>32</td>
<td>在写入信号有效时，写入内存地址的数据</td>
</tr>
<tr>
<td>o_RD</td>
<td>O</td>
<td>32</td>
<td>输出内存中对应地址的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>功能定义</strong></li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>复位</td>
<td>reset信号有效时，所有寄存器的中存储的值均被清零</td>
</tr>
<tr>
<td>2</td>
<td>读数据</td>
<td>读出A地址对应的存储单元的数据，将其加载到RD</td>
</tr>
<tr>
<td>3</td>
<td>写数据</td>
<td>当WE信号有效且时钟上升沿来临时，将WD中的数据写入到A地址对应的存储单元</td>
</tr>
</tbody>
</table>
<h2><span id="流水器寄存器模块定义">流水器寄存器模块定义</span></h2>
<p>采用的是分布式译码，流水的是pc和instr，在每个阶段实例化CU模块，得到该阶段的对应控制信号。</p>
<h3><span id="fd_refifid流水寄存器">FD_REF(IF/ID流水寄存器)</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v 中的 clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v 中的 reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器使能信号</td>
<td style="text-align:left">HCU 中 stall 信号取反</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">D 级寄存器清空信号</td>
<td style="text-align:left">默认为 1‘b0</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 instr 输入</td>
<td style="text-align:left">IFU_instr</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">F_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">F 级 pc 输入</td>
<td style="text-align:left">IFU_pc</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 instr 输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">D_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D 级 pc 输出</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3><span id="de_regidex-流水寄存器">DE_Reg（ID/EX 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>端口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from GRF</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">D级产生的有效信号</td>
<td style="text-align:left">from EXT</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_grf_RD2</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left">传给E级的有效信号</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<p>$Tnew_D = (Tnew_E &gt; 0) ? (Tnew_D-1) : 0$</p>
</li>
</ul>
<h3><span id="em_regexmem-流水寄存器">EM_Reg（EX/MEM 流水寄存器）</span></h3>
<ul>
<li>
<p>端口定义</p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left">关于sw的来自GRF_RD2的信号</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_mem_writeData</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>运算功能</strong></p>
<blockquote>
<p>我这里暂停部分在专门的一个模块HU中解决了</p>
</blockquote>
<p>$Tnew_E = (Tnew_D &gt; 0) ? (Tnew_E-1) : 0$</p>
</li>
</ul>
<h3><span id="mw_regmemwb-流水寄存器">MW_Reg（MEM/WB 流水寄存器）</span></h3>
<ul>
<li>
<p><strong>接口定义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">方向</th>
<th style="text-align:left">信号名</th>
<th style="text-align:left">位宽</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">输入来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_clk</td>
<td style="text-align:left">1</td>
<td style="text-align:left">时钟信号</td>
<td style="text-align:left">mips.v中的clk</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_reset</td>
<td style="text-align:left">1</td>
<td style="text-align:left">同步复位信号</td>
<td style="text-align:left">mips.v中的reset</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_en</td>
<td style="text-align:left">1</td>
<td style="text-align:left">使能信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_flush</td>
<td style="text-align:left">1</td>
<td style="text-align:left">清空信号</td>
<td style="text-align:left">from HU</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_pc</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_instr</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left">来自dm的数据读出信号</td>
<td style="text-align:left">from M_DM</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">i_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_dm_RD</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_alu_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">or_ext_result</td>
<td style="text-align:left">32</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2><span id="控制单元_cu">控制单元_CU</span></h2>
<p>输入改为instr，之前为opcode和func</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>Opcode[31:26]</th>
<th>[25:21]</th>
<th>[20:16]</th>
<th>[15:11]</th>
<th>[10:6]</th>
<th>[5:0]</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>rs</td>
<td>rt</td>
<td>rd</td>
<td>00000</td>
<td>100010</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td>rs</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td>base</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td>rs</td>
<td>rt</td>
<td>offset</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td>00000</td>
<td>rt</td>
<td>immediate</td>
<td>~</td>
<td>~</td>
</tr>
<tr>
<td>nop</td>
<td>000000</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3><span id="分支转移实现">分支转移实现</span></h3>
<h4><span id="b-类指令">B 类指令</span></h4>
<p>为了减少因控制冲突导致的暂停（<strong>stall</strong>），我们将 B 类指令的判断进行前置，单独使用 CMP 模块进行判断。当 B 类指令进入 D 级后（此时 F 级的指令为编译优化调度的指令），CMP 模块的判断结果进入 NPC，如过 CMP 结果为真（CMP_out = 1）而且 NPCOp 信号为 0x001（说明当前指令为 B 类指令），NPC 输出转移的地址 npc 并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h4><span id="j-和-jal">j 和 jal</span></h4>
<p>当 j 或 jal 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_instr 中 imm26 域的数据进入 NPC 进行处理，如果当前 NPCOp 信号为 0x010（说明当前指令为 jal 或 j 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<p>jal 指令在实现跳转的同时，还需要将下一条指令的地址存入 31 号寄存器中，因此我们需要在 IFU 中计算出改地址，并随着 jal 指令进行流水，最终在 W 级写入 GRF 的 31 号寄存器。由于存在延迟槽，pc+4 地址中的指令是编译优化机制调度过来的，因此我们要保存的地址应该为 pc+8。</p>
<h4><span id="jr">jr</span></h4>
<p>当 jr 进入 D 级后（此时 F 级的指令为编译优化调度的指令），D_V1_f（经过转发后的 D_V1 值）进入 NPC，如果当前 NPCOp 信号为 0x011（说明当前指令为 jr 指令），NPC 输出转移的地址 npc，并进入 IFU 的输入端，在下一时钟沿上升时进入 F 级，实现转移。</p>
<h2><span id="冒险处理">冒险处理</span></h2>
<p>冒险处理我们均通过 “A_T” 法实现 ——</p>
<h3><span id="转发forward">转发（forward）</span></h3>
<p><strong>无脑转发策略。</strong></p>
<p><strong>将所有在该层级后面的均进行转发。</strong></p>
<p><strong>比如ID级流水，需要用到D_rs和D_rt的对应寄存器的值。对于写入寄存器的值，可能为E级中的，E_alu_result, M_mem_writeData。</strong></p>
<p>当前面的指令要写寄存器但还未写入，而后面的指令需要用到没有被写入的值时，这时候会产生<strong>数据冒险</strong>，我们首先考虑进行转发。我们<strong>假设所有的数据冒险均可通过转发解决</strong>。也就是说，当某一指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并<strong>存储于后续某个流水线寄存器中</strong>。</p>
<p>在这一阶段，我们不管需要的值有没由计算出，都要进行转发，即暴力转发。为实现这一机制，我们要清楚哪些模块需要转发后的数据（<strong>需求者</strong>）和保存着写入值的流水寄存器（<strong>供应者</strong>）</p>
<ul>
<li>
<p><strong>供应者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">流水级</th>
<th style="text-align:left">产生数据</th>
<th style="text-align:left">MUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">E_E32，E_pc8</td>
<td style="text-align:left">MUX_E_out &amp; SelEMOut</td>
<td style="text-align:left">E_out</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">M_AO，M_pc8</td>
<td style="text-align:left">MUX_M_out &amp; SelEMOut</td>
<td style="text-align:left">M_out</td>
</tr>
<tr>
<td style="text-align:left">W</td>
<td style="text-align:left">W_AO，W_RD，W_pc8</td>
<td style="text-align:left">MUX_W_out &amp; SelWOut</td>
<td style="text-align:left">W_out</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>需求者及其产生的数据</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">接收端口</th>
<th style="text-align:left">选择数据</th>
<th style="text-align:left">HMUX 名 &amp; 选择信号名</th>
<th style="text-align:left">MUX 输出名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMP_D1/NPC_ra</td>
<td style="text-align:left">D_V1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D1 &amp; FwdCMPD1</td>
<td style="text-align:left">D_V1_f</td>
</tr>
<tr>
<td style="text-align:left">CMP_D2</td>
<td style="text-align:left">D_v1，M_out，E_out</td>
<td style="text-align:left">HMUX_CMP_D2 &amp; FwdCMPD2</td>
<td style="text-align:left">D_V2_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_A</td>
<td style="text-align:left">E_V1， W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_A &amp; FwdALUA</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">ALU_B</td>
<td style="text-align:left">E_V2，W_out，M_out</td>
<td style="text-align:left">HMUX_ALU_B &amp; FwdALUB</td>
<td style="text-align:left">E_V1_f</td>
</tr>
<tr>
<td style="text-align:left">DM_WD</td>
<td style="text-align:left">M_V2， W_out</td>
<td style="text-align:left">HMUX_DM &amp; FwdDM</td>
<td style="text-align:left">M_V2_f</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>从上表可以看出，W 级中的数据没有转发到 D 级，原因是我们在 GRF 内实现了内部转发机制，将 GRF 输入端的数据（还未写入）及时反映到 RD1 或这 RD2，判断条件为 <code>A3 == A2</code> 或者 <code>A3 == A1</code>。</p>
<p>此时为了生成 HMUX 的选择信号，我们需要向 HCU（冒险控制器）输入”A” 数据，然后进行选择信号的计算，执行转发的条件为 ——</p>
<ul>
<li><strong>前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></li>
<li><strong>写使能信号有效</strong></li>
</ul>
<p>根据以上条件我们可以生成上面的 5 个 HMUX 选择信号，选择信号的输出值应遵循 “就近原则”，及最先产生的数据最先被转发。</p>
<h3><span id="暂停stall">暂停（stall）</span></h3>
<p>接下来，我们来处理通过转发不能处理的数据冒险。在这种情况下，新的数据还未来得及产生。我们只能暂停流水线，等待新的数据产生。为了方便处理，我们仅仅为 D 级的指令进行暂停处理。</p>
<p>我们把 Tuse 和 Tnew 作为暂停的判断依据 ——</p>
<ul>
<li>Tuse：指令进入 <strong>D 级</strong>后，其后的某个功能部件<strong>再</strong>经过多少时钟周期就<strong>必须</strong>要使用寄存器值。对于有两个操作数的指令，其<strong>每个操作数的 Tuse 值可能不等</strong>（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2 ）。</li>
<li>Tnew：位于 <strong>E 级及其后各级</strong>的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max (Tnew@E - 1, 0)</li>
</ul>
<p>在这一阶段，我们找到 D 级生成的 Tuse_rs 和 Tuse_rt 和在 E,M,W 级寄存器中流水的 Tnew_D，Tnew_M，Tnew_W，如下表所示</p>
<ul>
<li>
<p><strong>Tuse 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tuse_rs</th>
<th style="text-align:left">Tuse_rt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">X</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">1</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jump</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">0</td>
<td style="text-align:left">X</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Tnew 表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">指令类型</th>
<th style="text-align:left">Tnew_D</th>
<th style="text-align:left">Tnew_E</th>
<th style="text-align:left">Tnew_M</th>
<th style="text-align:left">Tnew_W</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">calc_R</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">calc_I</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shift</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">shiftv</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">store</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">branch</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">jal</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">jr</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">lui</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>然后我们 Tnew 和 Tuse 传入 HCU（冒险控制器中），然后进行 stall 信号的计算。如果 Tnew &gt; TuseHCU 中的 stall 信号值为 1，此时执行以下操作 ——</p>
<ul>
<li><strong>冻结 PC 寄存器（IFU_en = ~stall = 0）</strong></li>
<li><strong>冻结 D 级寄存器（D_en = ~stall = 0）</strong></li>
<li><strong>清空 E 级寄存器（E_clr = stall = 1）</strong></li>
</ul>
<h1><span id="碎碎念">碎碎念</span></h1>
<ul>
<li>
<p>关于slt</p>
<blockquote>
<p>下面这种是错的</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> signed_srcA<span class="token punctuation">,</span> signed_srcB<span class="token punctuation">;</span>
 <span class="token keyword">assign</span> signed_srcB <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">assign</span> signed_srcA <span class="token operator">=</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  signed_srcA <span class="token operator">&lt;</span> signed_srcB<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这种是对的</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token punctuation">(</span>i_aluOp <span class="token operator">==</span> <span class="token constant">`ALU_slt</span> <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>  <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcA<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>i_srcB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</li>
<li>
<p>关于lb</p>
<blockquote>
<p>不知道这个为什么会有问题</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v<span class="token punctuation">:</span>
<span class="token constant">`define</span> GRF_WD_PC4          <span class="token number">3'b000</span>
<span class="token constant">`define</span> GRF_WD_PC8          <span class="token number">3'b001</span>
<span class="token constant">`define</span> GRF_WD_ALU_RESULT   <span class="token number">3'b010</span>
<span class="token constant">`define</span> GRF_WD_MEM_RD       <span class="token number">3'b011</span>
<span class="token constant">`define</span> GRF_WD_EXT          <span class="token number">3'b100</span>
<span class="token constant">`define</span> GRF_WD_MDU_RESULT   <span class="token number">3'b101</span>
# CU<span class="token punctuation">.</span>v<span class="token punctuation">:</span>
	<span class="token keyword">assign</span> o_grf_WD_Sel       <span class="token operator">=</span> <span class="token punctuation">(</span>o_load             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MEM_RD</span>     <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_calc_r <span class="token operator">|</span> o_calc_i<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_mf               <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_MDU_RESULT</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_link             <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_PC8</span>        <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_lui              <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`GRF_WD_EXT</span>        <span class="token punctuation">:</span> 
                                                     <span class="token constant">`GRF_WD_ALU_RESULT</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个W级CU的控制信号（我采用的是分布式译码），然后本来是o_calc_r和o_calc_i那个是第一行，为了测试调整了一下，按照仿真结果</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126002548684.png" alt="image-20231126002548684"></p>
<p>o_load确实是1,但是为什么这个Sel（grf的写入数据写入信号）为什么还是010（也就是ALU的那个呀）</p>
<p>测试代码如下：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003114530.png" alt="image-20231126003114530"></p>
<p>标准输出：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003204669.png" alt="image-20231126003204669"></p>
<p>我的输出：</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126003137500.png" alt="image-20231126003137500"></p>
<p>这个0x0000260f正好就是alu_result也就是计算得到的lb的地址</p>
</blockquote>
</li>
<li>
<p>bne</p>
<blockquote>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"># def<span class="token punctuation">.</span>v
<span class="token constant">`define</span> NPC_PC4       <span class="token number">3'b000</span>
<span class="token constant">`define</span> NPC_BRANCH    <span class="token number">3'b001</span>
<span class="token constant">`define</span> NPC_J         <span class="token number">3'b010</span>
<span class="token constant">`define</span> NPC_JR        <span class="token number">3'b011</span>
# CU<span class="token punctuation">.</span>v
		<span class="token keyword">assign</span> o_npcOp        <span class="token operator">=</span> <span class="token punctuation">(</span>o_b_type <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_BRANCH</span> <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_j_imm26<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_J</span>  <span class="token punctuation">:</span>
                             <span class="token punctuation">(</span>o_j_r    <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`NPC_JR</span> <span class="token punctuation">:</span>
                                           <span class="token constant">`NPC_PC4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也出现了类似上面的情况</p>
<p><img src="/2024/02/21/p7-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231126010102868.png" alt="image-20231126010102868"></p>
<p>也就是o_b_type为1,但是npcOp仍然是PC4的000，而不是001</p>
</blockquote>
</li>
</ul>
<h1><span id="思考题">思考题</span></h1>
<blockquote>
<p>1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p>
</blockquote>
<ul>
<li>乘除法都有较高的延迟，若整合进 ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在 D 级，造成了极大的性能损失。单独设置 MDU 的话，无关的指令还能正常的在 ALU 运行，效率较高。</li>
<li>HI，LO 寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于 GRF 中，内置在 MDU 中即可。</li>
</ul>
<blockquote>
<p>2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p>
</blockquote>
<ul>
<li>
<p>真实的流水线 CPU 采用的乘法是有加法器和移位器循环，具体实现过程为：</p>
<blockquote>
<p>首先 CPU 会初始化三个通用寄存器用来存放被乘数，乘数，部分积。<br>
部分积寄存器初始化为 0。<br>
判断乘数寄存器的低位是 0|1，如果为 0 则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。<br>
在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。<br>
同时部分积寄存器高位补 0。如果为 1 则将部分积寄存器加上被乘数寄存器，再进行移位操作。<br>
当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。</p>
</blockquote>
</li>
<li>
<p>还有另一种乘法的方式：</p>
<blockquote>
<p>只需两个寄存器，A [31:0],B [63:0]，A 初始化为被乘数，B 初始化为乘数。<br>
每一次取 B 的最低位，为 1 则将 A [31:0]+B [63:32] -&gt; B [63:32]，为 0 则不操作。<br>
每次将 B &gt;&gt; 1，然后高位补 0。</p>
</blockquote>
</li>
<li>
<p>除法实现：</p>
<blockquote>
<p>与乘法的操作基本相反，首先 CPU 会初始化三个寄存器，用来存放被除数，除数，部分商。余数 (被除数与除数比较的结果) 放到被除数的有效高位上。CPU 做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先 CPU 会把被除数 bit 位与除数 bit 位对齐，然后再让对齐的被除数与除数比较 (双符号位判断)。比如 01-10=11 (前面的 1 是符号位) 1-2=-1 计算机通过符号位和后一位的 bit 位来判断大于和小于，那么 01-10=11 就说明 01 小于 10，如果得数为 01 就代表大于，如果得数为 00 代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位 (上商就是将商的最低位左移 1 位腾出商寄存器最低位上新的商) 如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p>
</blockquote>
<ul>
<li>除 cnt—，和 BusyReg 置位以外全是组合逻辑的操作（不然可能会多出来一个空周期）</li>
<li>对于乘除指令：
<ul>
<li>将 Busy，start_E，MDUOp_D 传入 HCU</li>
<li>然后 md 暂停信号为 <code>(Busy | start_E) &amp; (MDUOp_D != 0)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p>
</blockquote>
<ul>
<li>对于需要写入的位置更加的直观，相当于将 DMWE、DMOP 写入的 A [1:0] 用四位字节使能信号表示，十分的统一。</li>
</ul>
<blockquote>
<p>5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p>
</blockquote>
<ul>
<li>按字节读写的时候，我们获得的是一字节，但是我们如果要 lw 或 lh 的话我们就需要拼接。如果是 sw 或 sh 的话我们需要多次存入。</li>
<li>若用 lb，sb，lh，sh 这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。</li>
</ul>
<blockquote>
<p>6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p>
</blockquote>
<ul>
<li>我们根据不同指令之间的相似性将指令分成了几类 ——calc_R、calc_I、shift、shiftv、load、store、B 类、J 类、md 类、mf 类、mt 类， 并设置对应信号帮助译码，防止计算表达式过长，而且在处理数据冲突时我们只需要将表示该类的信号写入表达式即可。此外，我们将相似功能的控制信号用一个多位宽信号来表示，如针对 DM 的访存功能，我们设置一个 3 位 LSOp 信号；针对乘除槽中的 md、mf、mt 功能，我们设置一个 MDUOp 信号来控制，从而减少了流水寄存器的接口数目，从而降低复杂度。</li>
</ul>
<blockquote>
<p>7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p>
</blockquote>
<p>tuse和tnew部分有</p>
<blockquote>
<p>8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p>
</blockquote>
<p>白嫖捏</p>
<h3><span id="参考">参考</span></h3>
<p><a href="https://thysrael.github.io/posts/59164957">一篇写的非常好的博客</a></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>p7</tag>
      </tags>
  </entry>
  <entry>
    <title>字典序</title>
    <url>/2023/05/25/%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
    <content><![CDATA[<h1><span id="字典序">字典序</span></h1>
<h2><span id="说在前面">说在前面</span></h2>
<blockquote>
<p>字典序(dictionary order)，又称字母序(alphabetical order)，原意是表示英文单词在字典中的先后顺序，后引申为任意两个字符串的大小关系</p>
</blockquote>
<p>那么大家就清楚了这指的是一种大小关系，一种序，正如我们数学分析中的有序集的序有类似的概念，这里大家需要与字典树(Tire)区分开来，字典树实质上是一种数据结构中的用于存储和查找单词的一种树状结构，详情可以看这个<a href="https://www.hugohealthy.top/2023/05/25/Trie/">tire</a>。(在我的另一篇blog可以看到哦)</p>
<h2><span id="字典序算法相关">字典序算法相关</span></h2>
<h3><span id="字典序全排列问题">字典序全排列问题</span></h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token comment">//交换两个字符，注意这里传过去的是地址，改变的是地址对应的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//将一个字符串begin到end的部分逆序</span>
<span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        begin<span class="token operator">++</span><span class="token punctuation">;</span>
        end<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">next_permutation</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> str<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token comment">//从后往前找到第一个正序的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">//表示找完了，已经全部是逆序了</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//从i开始找到前面的第一个比str[i]大的，那么就进行交换</span>
<span class="token comment">//再把i+1以后的逆序一遍</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abd"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该代码可以实现一个<strong>顺序的字符串</strong>的所有字母的按字典序输出的全排列。</p>
<p>否则的话就是输出比改字符串的字典序大于等于的字符串。</p>
<p>当然简单调整当然可以是任意顺序的一个字符串的操作。</p>
<h3><span id="字典序排序">字典序排序</span></h3>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_37050329/article/details/86637183">https://blog.csdn.net/qq_37050329/article/details/86637183</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典序</tag>
      </tags>
  </entry>
  <entry>
    <title>离散2</title>
    <url>/2023/11/24/%E7%A6%BB%E6%95%A32/</url>
    <content><![CDATA[<h1><span id="离散2">离散2</span></h1>
<p>这里会放上我的一些作业</p>
<span id="more"></span>
<h2><span id="作业5">作业5</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)不是\<br>
&amp;A = {1, 2, 3}\<br>
&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;1,2&gt;,&lt;2,1&gt;, &lt;1,3&gt;,&lt;3,1&gt;,&lt;2,3&gt;,&lt;3,2&gt;}\<br>
&amp;R_2 = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;1,2&gt;,&lt;2,1&gt;}\<br>
&amp;则r(R_1 - R_2) = {&lt;1,1&gt;, &lt;2,2&gt;, &lt;3,3&gt;,&lt;2,3&gt;,&lt;3,2&gt;,&lt;1,3&gt;,&lt;3,1&gt;}\<br>
&amp;而有&lt;1,3&gt;,&lt;3,2&gt;\in r(R_1 - R_2) 但是&lt;1,2&gt; \notin r(R_1 - R_2),故r(R_1-R_2)不是传递的，因而不是等价关系\<br>
&amp;(2)不是\<br>
&amp; 上课已经讲过，R_1 , R_2是对称时，R_1 \circ R_2 不一定对称\<br>
&amp; 比如取A = {1, 2, 3}\<br>
&amp;R_1 = {&lt;1,1&gt;, &lt;2,2&gt;,&lt;1,2&gt;,&lt;2,1&gt;,}\<br>
&amp;R_2 = {&lt;2,2&gt;, &lt;3,3&gt;, &lt;2,3&gt;,&lt;3,2&gt;}\<br>
&amp;则R_1\circ R_2 = {&lt;2,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;,&lt;1,2&gt;}显然不是等价关系\<br>
&amp;(3)是\<br>
&amp;R_1,R_2都是等价关系，那么都是自反，对称，传递的\<br>
&amp;就有R_1\cup R_2是自反的，对称的\<br>
&amp;同时如果R_1 \cup R_2 是自反的，对称的，那么t(R_1,R_2)仍然是自反、对称的，同时还是传递的\<br>
&amp;由等价关系的定义可知t(R_1, R_2)是等价关系<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(a)\<br>
&amp;左到右:\<br>
&amp;S_1 \in A/R1,则\forall s_1 \in S_1\<br>
&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>
&amp;又R_1\subseteq R_2,及&lt;x,y&gt; \in R_1 有&lt;x,y&gt; \in R_2，即xR_2y\<br>
&amp;故s_1 \in S_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y}\<br>
&amp;即S_1 \subseteq S_2,由加细的定义有A/R_1 \le A/R_2\<br>
&amp;右到左:\<br>
&amp;A/R_1 \le A/R_2\<br>
&amp;有\forall S_1 \in A/R_1 , \exist S_2 \in A/R_2 , s.t. S_1 \subseteq S_2\<br>
&amp;\forall s_1 \in S_1\<br>
&amp;s_1 = [x]<em>{R_1} = {y|y\in A \wedge x R_1y},x为A中元素\<br>
&amp;故\exist s_2 = [x]</em>{R_2} = {y|y \in A \wedge xR_2y},s_1 \subseteq s_2 \<br>
&amp;即\forall xR_1y,有xR_2y,即R_1 \subseteq R_2\<br>
&amp;综上即可得证\<br>
&amp;(b)\<br>
&amp;左到右:\<br>
&amp;R_1 \subset R_2 必然有R_1 \subseteq R_2，则A/R_1 \le A/R_2\<br>
&amp;又R_1\ne R_2,即\exist &lt;x_0,y&gt; \in R_2,&lt;x_0,y&gt;\notin R_1\<br>
&amp;取s_2 = [x_0]<em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2 \in S_2，其中S_2 \in A/R_2\<br>
&amp;且由于&lt;x_0,y&gt;\notin R_1 ,s_2 \notin S_1,故S_1 \ne S_2,其中S_1 \in A/R_1\<br>
&amp;即A/R_1 \ne A/R_2\<br>
&amp;右到左:\<br>
&amp;A/R_1 \subset A/R_2,则同样易有R_1\subseteq R_2\<br>
&amp;A/R_1 \ne A/R_2\<br>
&amp;则存在S_2 \in A/R_2,找不到S_1 \in A/R_1,s.t. S_2 \subseteq S_1,\<br>
&amp;同样取s_2 = [x_0]</em>{R_2} = {y|y \in A \wedge x_0R_2y},s_2\in S_2，且s_2 \notin S_1\<br>
&amp;即\exist &lt;x_0,y_0&gt;,s.t. x_0R_2y_0,x_0\overline{R_1}y_0\<br>
&amp;即R_1 \ne R_2\<br>
&amp;故R_1 \subset R_2\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;看法不对,证明就不可能对了嘛。\<br>
&amp;若R是非空集合A的空关系，由于前件为0，R是对称和传递的，但是\forall x \in A, &lt;x,x&gt;\notin R\<br>
&amp;R不是自反的\<br>
&amp;故即可完成论证\<br>
\end{align}<br>
$$</p>
<ol start="4">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;必要性:\<br>
&amp;(显然bushi)R是等价关系，且&lt;a,b&gt;\in R,&lt;a,c&gt; \in R\<br>
&amp;由于R是对称的，有&lt;b,a&gt;\in R\<br>
&amp;由于R是传递的，有&lt;b,c&gt;\in R\<br>
&amp;必要性即证\<br>
&amp;充分性:\<br>
&amp;若&lt;a,b&gt;\in R,&lt;a,c&gt;\in R,则&lt;b,c&gt;\in R\<br>
&amp;同时R是自反的\<br>
&amp;\forall &lt;a,b&gt;\in R, 且由自反性有&lt;a,a&gt; \in R \<br>
&amp;由条件可得，&lt;b,a&gt; \in R，故R是对称的\<br>
&amp;\forall &lt;a,b&gt; \in R , &lt;b,c&gt; \in R\<br>
&amp;证明了对称性，有&lt;b,a&gt;\in R,则结合条件可得\<br>
&amp;&lt;a,c&gt;\in R，故R是传递的\<br>
&amp;由等价关系的定义可知R是等价关系\<br>
&amp;充分性得证\<br>
&amp;综上即可得证\<br>
\end{align}<br>
$$</p>
<ol start="5">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;必要性:\<br>
&amp;(也挺显然的)&lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>
&amp;则由传递性，&lt;x,z&gt;\in R\<br>
&amp;再由对称性，&lt;z,x&gt;\in R\<br>
&amp;必要性即证\<br>
&amp;充分性:\<br>
&amp;R是自反的，且R是循环的\<br>
&amp;\forall &lt;x,y&gt; \in R, 由自反性&lt;y,y&gt;\in R\<br>
&amp;再有循环性，有&lt;y,x&gt;\in R，即R是对称的\<br>
&amp;\forall &lt;x,y&gt;\in R,&lt;y,z&gt;\in R\<br>
&amp;由循环性,&lt;z,x&gt;\in R,又已经证明R是对称的\<br>
&amp;则有&lt;x,z&gt;\in R，故R是传递的\<br>
&amp;必要性得证\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<h2><span id="作业六">作业六</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)能够\<br>
&amp;dom = {1,2,3,4}\<br>
&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;1,4&gt;}\<br>
&amp;(2)能够\<br>
&amp;dom = {1,2,3}\<br>
&amp;ran = {&lt;2,3&gt;,&lt;3,4&gt;,&lt;3,2&gt;}\<br>
&amp;(3)不能够\<br>
&amp;(4)能够\<br>
&amp;dom = {1,2,3}\<br>
&amp;ran = {&lt;2,3&gt;}\<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp; (1)\forall y \in f[A] - f[B]\<br>
&amp;\Rightarrow y \in f[A] \wedge y \notin f[B]\<br>
&amp;\exist x\in A \quad s.t. \quad y = f(x)\<br>
&amp;若x\in B,则与y\notin f[B]矛盾,故x\in A - B\<br>
&amp;即y \in f[A- B]\<br>
&amp;反例:\<br>
&amp;X= {1,2},Y = {0}\<br>
&amp;f = {&lt;1,0&gt;,&lt;2,0&gt;}\<br>
&amp;A = {1,2}, B = {1}\<br>
&amp;此时f[A] = {0},f[B] = {0},f[A] - f[B] = \varnothing\<br>
&amp;f[A-B] = {0}，等号不成立\<br>
&amp;(2)\forall x \in f^{-1}[C-D]\<br>
&amp;\exist y \in C- D , y = f(x)\<br>
&amp;\Rightarrow y\in C\wedge y\notin D\<br>
&amp;\Rightarrow x\in f^{-1}[C] \wedge x \notin f^{-1}[D]\<br>
&amp;\Rightarrow x \in f^{-1}[C]-f^{-1}[D]\<br>
&amp;因此有f^{-1}[C-D]\subseteq f^{-1}[C]-f^{-1}[D]\<br>
&amp;\forall x \in f^{-1}[C]-f^{-1}[D]\<br>
&amp;\exist y \in C ,y = f(x)\<br>
&amp;若y\in D,则x\in f^{-1}[D],矛盾，因此y\notin D\<br>
&amp;\Rightarrow y\in C-D\<br>
&amp;即x \in f^{-1}[C-D]\<br>
&amp;因此有f^{-1}[C]-f^{-a}[D] \subseteq f^{-a}[C-D]\<br>
&amp;故综上有f^{-1}[C-D] = f^{-1}[C]- f^{-1}[D]\<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;单射：(1),(2)\<br>
&amp;满射：(2),(3)\<br>
&amp;双射：(2)\<br>
\end{align}<br>
$$</p>
<h2><span id="作业七">作业七</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;由上课讲的定理显然可得：\<br>
&amp;(定理如下，课上证明了，课下就不证了了吧)\<br>
&amp;f:X ⟶ Y 和 g: Y ⟶ Z，则\<br>
&amp;(1) 若 f 和 g 都是满射，则 g\circ ƒ 也是满射\<br>
&amp;(2) 若 f 和 g 都是单射，则 g\circ ƒ 也是单射\<br>
&amp;(3) 若 f 和 g 都是双射，则 g\circ ƒ 也是双射\<br>
&amp;用数学归纳法显然可证\<br>
&amp;n = 1时，结论成立 \<br>
&amp;若n时结论成立，则n+1时\<br>
&amp;f^{n+1} = f^n \circ f\<br>
&amp;f^n和f都是满射，单射或双射，则f^{n+1}时满射，单射或双射\<br>
&amp;由数学归纳法即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;(1)g\circ f为满射，g为单射\<br>
&amp;则ran(g\circ f) = Z\<br>
&amp;且由课上结论,g为满射，故g为1-1映射\<br>
&amp;dom(g) = Y,g^{-1}[Z] = Y \<br>
&amp;又g[ran(f)] = Z\<br>
&amp;即ran(f) = Y\<br>
&amp;故f为满射\<br>
&amp;综上即可得证\<br>
&amp;(2)g\circ f为单射,f为满射\<br>
&amp;且由课上结论，f为单射，故f为1-1映射\<br>
&amp;\forall y_1 ,y_2\in Y,且y_1 \ne y_2\<br>
&amp;由于f为1-1映射,故存在唯一x_1,x_2,s.t.y_1 = f(x_1),y_2 = f(x_2)\<br>
&amp;若x_1 = x_2 ,则显然y_1 = y_2，故有x_1 \ne x_2\<br>
&amp;则g\circ f(x_1) = g(y_1)  = z_1,g\circ f(x_2) = g(y_2) = z_2\<br>
&amp;由g\circ f为单射,故z_1\ne z_2\<br>
&amp;故可得g也为单射\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;dom(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>
&amp;ran(f\circ f) = {x | x\in \R \wedge x \ne 0}\<br>
&amp;dom(h\circ g) = {x | x\in \R}\<br>
&amp;ran(h\circ g) = {x | x\in \R_+ | x = 0}\<br>
&amp;dom(g\circ h) = {x|x \in \R_+ | x = 0}\<br>
&amp;ran(g\circ h) = {x|x \in \R_+ | x = 0}\</p>
<p>\end{align}<br>
$$</p>
<h2><span id="作业7">作业7</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;左推右\<br>
&amp;显然!!f可逆等价于f有唯一的左逆和右逆\<br>
&amp;右推左\<br>
&amp;若f有唯一的左逆(右逆证明类似)\<br>
&amp;那么可以推出f是单射\<br>
&amp;需要证明f是可逆的，那么只需要证明f是右可逆的\<br>
&amp;这里采用反证法，假设f不是右可逆的，那么等价于f不是满射\<br>
&amp;设A中至少有的两个元素为a_1, a_2,由于f是单射\<br>
&amp;设f(a_1) = b_1, f(a_2) = b_2,且有b_1 \ne b_2，同时由于不是满射\<br>
&amp;B中至少存在一个元素，设为b_3,A中没有元素映射到b_3\<br>
&amp;接下来我们构造g_1,g_2,使得g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2\<br>
&amp;g_1(x) = \begin{cases}<br>
a_i, &amp; if, x = b_i,i=1,2\<br>
a_1, &amp; if, x = b_3\<br>
f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>
\end{cases}\<br>
&amp;g_2(x) = \begin{cases}<br>
a_i, &amp; if, x = b_i,i=1,2\<br>
a_2, &amp; if, x = b_3\<br>
f^{-1}(x), &amp; if, x \in ran(f) \wedge x \notin{b_1, b_2}<br>
\end{cases}\<br>
&amp;那么就有g_1 \circ f = I_A,g_2\circ f_2 = I_A，且g_1 \ne g_2成立，与f有唯一的左逆矛盾\<br>
&amp;故有上面的反证法可以得到f是右可逆的，那么f是可逆，即可得证\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
(1)&amp;f是左可逆，右可逆，可逆的\<br>
&amp;显然f是单射，满射，因此是可逆的。同时求出f的逆即为f的左逆和右逆\<br>
&amp;构造g(x) = \begin{cases}<br>
4,&amp; if, x= 0\<br>
x-1,&amp; if, x = 1,2,3,4\<br>
x,&amp; if, x &gt; 5<br>
\end{cases}\<br>
&amp;可以验证f\circ g = I_N, g\circ f = I_N\<br>
&amp;即为所求\<br>
(2)&amp;f是右可逆，不是左可逆，不是可逆\<br>
&amp;由于f(1)  = f(3) =  3,因此f不是单射，f不是左可逆\<br>
&amp;f是满射，\forall x \in N,\exist f(2x) = x,2x \in N;<br>
&amp;下面构造f的右逆g\<br>
&amp;g(x) = 2x, x \in N;即为右逆之一<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;\chi_{A-B\cap C}\<br>
&amp;= \chi_A - \chi_A <em>\chi_{B\cap C}\<br>
&amp;= \chi_A - \chi_A</em>\chi_B*\chi_C\<br>
&amp;\chi_{(A-B)\cup (A-C)}\<br>
&amp;=\chi_{A-B} + \chi_{A-C}-\chi_{A-B}<em>\chi_{A-C}\<br>
&amp;=\chi_A-\chi_A</em>\chi_B+\chi_A-\chi_A*\chi_C - (\chi_A-\chi_A*\chi_B)<em>(\chi_A-\chi_A</em>\chi_C)\<br>
&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_A*\chi_C-\chi_A*\chi_B*\chi_A+\chi_A*\chi_B*\chi_A*\chi_C)\<br>
&amp;=\chi_A-\chi_A*\chi_B+\chi_A-\chi_A*\chi_C-(\chi_A-\chi_A*\chi_C-\chi_A*\chi_B+\chi_A*\chi_B*\chi_C)\<br>
&amp;=\chi_A - \chi_A*\chi_B*\chi_C\<br>
&amp;于是显然有\chi_{A-B\cap C} = \chi_{(A-B)\cup (A-C)}\<br>
&amp;于是可以证明A-B\cap C = (A-B)\cup(A-C)\<br>
\end{align}<br>
$$</p>
<ol start="4">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;\chi_{A\oplus B}\<br>
&amp;=\chi_{A} - \chi_{A\cap B} + \chi_{B}-\chi_{A\cap B}\<br>
&amp;=\chi_{A} + \chi_{B} - 2*\chi_{A}<em>\chi_{B}\<br>
&amp;=0\<br>
&amp;那么有\chi_{A}</em>(1-\chi_{B}) = \chi_B*(1-\chi_{A})\<br>
&amp;\iff \chi_{A}<em>\chi_{\sim B} = \chi_{B}</em>\chi_{\sim A}\<br>
&amp;\iff \chi_{A\cap \sim B} = \chi_{B\cap \sim A}\<br>
&amp;\iff A\cap \sim B = B \cap \sim A\<br>
&amp;即为所求<br>
\end{align}<br>
$$</p>
<h2><span id="作业8">作业8</span></h2>
<ol>
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;利用第一数学归纳法进行证明\<br>
&amp;(1)由于为自然数序列，所以显然有0\le a_0\<br>
&amp;(2)\forall n\ge 0,若n \le a_n,下面证明n^+\le a_{n^+}\<br>
&amp;由于为单调递增序列，因此显然有a_n &lt;a_{n^+}\<br>
&amp;同时为正整数序列，由于正整数是不稠密的\<br>
&amp;有a_n + 1 \le a_{n^+}\<br>
&amp;n^+ = n + 1 \le a_n + 1\le a_{n^+}\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<ol start="2">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;对于本题我们先证明如下结论:\<br>
&amp;\forall i \in n, 有i \subseteq n\<br>
&amp;使用第一数学归纳法进行证明\<br>
&amp;(1)n = 0时显然成立。\<br>
&amp;(2)\forall n \ge 0,若结论成立，即\forall i \in n, 有i\subseteq n\<br>
&amp;那么对于n^+,有n^+ = {n,{n}}\<br>
&amp;\forall i \in n^+, 有i = n 或者i \in n(由三歧性可得)\<br>
&amp;若i = n,显然有i\subseteq n^+\<br>
&amp;若i\in n,由归纳假设，i\in n\<br>
&amp;又n\in n^=,则又i\in n^+\<br>
&amp;故该结论得证\<br>
&amp;对于本题,\forall a \in n,\forall x \in a\<br>
&amp;由于可推出a \in n, 于是显然有x \in n\<br>
&amp;故综上即可得证\forall n \in N 是传递的<br>
\end{align}<br>
$$</p>
<ol start="3">
<li></li>
</ol>
<p>$$<br>
\begin{align}<br>
&amp;本题应该是想用二重归纳法做，但是太麻烦了，我就直接用构造法哈(goutou)\<br>
&amp;设n = k(m+1) + t,(t &lt; m+1)\<br>
&amp;由于n &gt; m 且(m+1)\nmid n\<br>
&amp;可得k \ge 1, t \ne 0\<br>
&amp;那么甲第一次取t个球，然后每次乙取x个球\<br>
&amp;甲取(m+1-x)个球，一轮取球数维m+1，故经过k轮\<br>
&amp;恰好甲取完最后的球，获胜<br>
\end{align}<br>
$$</p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散2</tag>
      </tags>
  </entry>
  <entry>
    <title>离散1</title>
    <url>/2023/05/04/%E7%A6%BB%E6%95%A31/</url>
    <content><![CDATA[<p>这里记录了大一下学期的离散作业与答案，我会在每次作业截止后马上把我的答案放上来<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>
<p>$$<br>
\newcommand{\lfa}[0]{\leftrightarrow}\<br>
\newcommand{\w}[0]{\wedge}\<br>
\newcommand{\v}[0]{\vee}\<br>
\newcommand{\an}[0]{\wedge}\<br>
\newcommand{\o}[0]{\vee}\<br>
\newcommand{\n}[0]{\neg}\<br>
\newcommand{\a}[0]{\forall}\<br>
\newcommand{\e}[0]{\exists}\<br>
$$</p>
<h1><span id="第一次作业">第一次作业</span></h1>
<h2><span id="11">$1.1$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/1.png" alt></p>
<blockquote>
<p>a</p>
</blockquote>
<h2><span id="21">$2.1$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/2.png" alt></p>
<ol>
<li>
<p>不是命题；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>不是命题；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
<li>
<p>是命题，真值为0；</p>
</li>
</ol>
<h2><span id="22">$2.2$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/3.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.\neg p\<br>
&amp;2.(\neg p)\wedge (\neg q)\<br>
&amp;3.p\oplus q\<br>
&amp;4.p\to q\<br>
&amp;5.p\to q\<br>
&amp;6.(p\wedge q)\to (r\vee s)\<br>
&amp;7.p\leftrightarrow (q \oplus r)\<br>
&amp;8.p\to q\<br>
&amp;9.p\to q\<br>
&amp;10.p\leftrightarrow q\<br>
&amp;11.\neg(p\vee q)\to r<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/4.png" alt></p>
<h2><span id="23">$2.3$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/5.png" alt></p>
<ol>
<li>永真式</li>
<li>可满足式</li>
<li>可满足式</li>
<li>永真式</li>
<li>永真式</li>
<li>永假式</li>
<li>永真式</li>
</ol>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/6.png" alt></p>
<h2><span id="24">$2.4$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/7.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;p\to (q\to r)\<br>
\iff &amp;\neg p\vee(\neg q\vee r)\<br>
\iff &amp;(\neg p \vee \neg q)\vee r\<br>
\iff &amp;(\neg q \vee \neg p)\vee r\<br>
\iff &amp;\neg q \vee (\neg p\vee r)\<br>
\iff &amp;\neg q \vee (p\to r)\<br>
\iff &amp;q\to(p\to r)\<br>
(2)\<br>
&amp;(p\to q)\wedge(p\to r)\<br>
\iff&amp;(\neg p\vee q)\wedge(\neg p\vee r)\<br>
\iff&amp;\neg p \vee (q\wedge r)\<br>
\iff&amp;p\to q\wedge r\<br>
(3)\<br>
&amp;(p\to q)\vee(r\to q)\<br>
\iff&amp;(\neg p\vee q)\vee(\neg r \vee q)\<br>
\iff&amp;\neg  p\vee\neg r\vee (q\vee q)\<br>
\iff&amp;\neg  p\vee\neg r\vee q\<br>
\iff&amp;\neg(p\wedge r)\vee q\<br>
\iff&amp;p\wedge r \to q\<br>
(4)\<br>
&amp;p\to (q \to p)\<br>
\iff&amp;\neg p \vee (\neg q \vee p)\<br>
\iff&amp;(\neg p\vee p)\vee \neg q\<br>
\iff&amp;1\vee \neg q\<br>
\iff&amp;1\<br>
同时又有&amp;\neg p \to (p\to q)\<br>
\iff&amp;\neg \neg p \vee (\neg p \vee q)\<br>
\iff&amp;(p\vee \neg p)\vee q\<br>
\iff&amp;1\vee q\<br>
\iff&amp;1\<br>
&amp;二者均为永真式，且等值与1，故有二者等值<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/8.png" alt></p>
<h2><span id="25">$2.5$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/32.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;易知(q\to r)\iff (\neg r\to\neg q)\<br>
&amp;由替换实例进行替换\<br>
&amp;有(Q\to R)\iff (\neg R\to\neg Q)\<br>
(2)\<br>
&amp;(p\wedge q)\to r\<br>
\iff&amp;\neg(p\wedge q)\vee r\<br>
\iff&amp;\neg p\vee \neg q\vee r\<br>
\iff&amp;\neg p\vee(\neg q\vee r)\<br>
\iff&amp;\neg p\vee(q\to r)\<br>
\iff&amp;p\to(q\to r)\<br>
&amp;由替换实例进行替换\<br>
&amp;有(P\wedge Q)\to R\iff P\to(Q\to R)<br>
\end{align}<br>
$$</p>
<h2><span id="26">$2.6$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/33.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;\neg(Q\wedge R)\wedge (\neg Q \vee \neg R)\<br>
(2)\<br>
&amp;(p\vee(Q\vee R))\wedge((P\vee Q)\vee R)\wedge 1<br>
\end{align}<br>
$$</p>
<h2><span id="27">$2.7$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/9.png" alt><br>
$$<br>
\begin{align}<br>
&amp;由对偶定理\<br>
(1)\<br>
&amp;A是永真式，则取R为1，R^<em>为0\<br>
&amp;有A\iff R&amp;\<br>
&amp;故A^</em>\iff R^<em>\<br>
&amp;即A^</em> \iff 0\<br>
&amp;故A为永假式\<br>
(2)\<br>
(1)\<br>
&amp;A是永假式，则取R为0，R^<em>为1\<br>
&amp;有A\iff R&amp;\<br>
&amp;故A^</em>\iff R^<em>\<br>
&amp;即A^</em> \iff 1\<br>
&amp;故A为永真式\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/10.png" alt></p>
<h1><span id="第二次作业">第二次作业</span></h1>
<h2><span id="text11">$\text{1.1}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/11.png" alt><br>
$$<br>
\begin{align}<br>
(1)\<br>
&amp;(q\to p)\wedge(\neg p \to q)\leftrightarrow \neg p\<br>
\iff&amp;(\neg q \vee p)\wedge(\neg(\neg p) \vee q)\leftrightarrow\neg p\<br>
\iff&amp;(\neg q \vee p)\wedge(q\vee p)\leftrightarrow\neg p\<br>
\iff&amp;(\neg q \wedge q)\vee p \leftrightarrow\neg p\<br>
\iff&amp;p\leftrightarrow \neg p\<br>
\iff &amp;0\<br>
&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>
(2)\<br>
&amp;(p\to q)\wedge(q\to r)\wedge\neg(p\to r)\<br>
\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge\neg(\neg p \vee r)\<br>
\iff&amp;(\neg p \vee q)\wedge(\neg q \vee r)\wedge(p\wedge \neg r)\<br>
\iff&amp;((\neg p \vee q)\wedge p)\wedge((\neg q \vee r)\wedge \neg r)\<br>
\iff&amp;((\neg p \wedge p ) \vee(q \wedge p))\wedge((\neg q \wedge r)\vee (r \wedge \neg r)) \<br>
\iff&amp;(0 \vee(q \wedge p))\wedge((\neg q \wedge r)\vee 0)\<br>
\iff&amp;(q\wedge p)\wedge (\neg q \wedge r)\<br>
\iff&amp;p \wedge (q\wedge \neg q)\wedge r\<br>
\iff&amp;p\wedge 0 \wedge r\<br>
\iff&amp;0\<br>
&amp;该公式通过真值演算等值于0，故该公式为永假式\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/12.png" alt></p>
<h2><span id="text12">$\text{1.2}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/13.png" alt><br>
$$<br>
\begin{align}<br>
(1)<br>
&amp;\neg(\neg p \wedge \neg q)\vee \neg (\neg p \vee q)\<br>
\iff&amp;(p\wedge q)\vee (p\wedge \neg q)\<br>
\iff&amp;p\wedge (q\vee \neg q)\<br>
\iff&amp;p\<br>
&amp;故即证该等值式，由对偶定理有\<br>
&amp;\neg (\neg p\wedge \neg q)\wedge \neg (\neg p\wedge  q)\iff  p\<br>
(2)<br>
&amp;(p\vee \neg q)\wedge(p\vee q)\wedge(\neg p \vee \neg q)\<br>
\iff&amp;p\vee (\neg q \wedge q)\wedge (\neg p \vee \neg q)\<br>
\iff&amp;(p\wedge \neg p)\vee(p \wedge \neg q)\<br>
\iff&amp;\neg (\neg p \vee q)\<br>
&amp;故即证该等值式，由对偶定理有\<br>
&amp;(p\wedge \neg q)\vee (p\wedge q)\vee(\neg p \wedge \neg q)\iff\neg (\neg p \wedge q)<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/14.png" alt></p>
<h2><span id="text13">$\text{1.3}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/15.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.{0,\to}\<br>
&amp;首先我们有{\neg ,\to }为极小完全集\<br>
&amp;又由于\neg p \iff p\to 0\<br>
&amp;故{\neg ,\to }是完全集\<br>
&amp;同时只含0的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;2.{\oplus ,\to}\<br>
&amp;首先我们有{\neg ,\to }为极小完全集\<br>
&amp;又由于\neg p \iff p\oplus (p\to p)\<br>
&amp;故{\oplus,\to}是完全集\<br>
&amp;又同时只含\oplus的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;而只含\to 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;3.{\oplus,\wedge,\leftrightarrow}\<br>
&amp;首先我们有{\neg ,\wedge }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集(书上的例题应该可以用吧）\<br>
&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>
&amp;故{\oplus,\wedge,\leftrightarrow}是完全集\<br>
&amp;又同时只含{\oplus，\wedge}的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;只含{\wedge,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\</p>
<p>&amp;4.{\oplus,\vee,\leftrightarrow}\<br>
&amp;首先我们有{\neg ,\vee }为极小完全集,而且{\oplus,\leftrightarrow}不是完全集\<br>
&amp;又由于\neg p \iff p\oplus (p\leftrightarrow p)\<br>
&amp;故{\oplus,\vee,\leftrightarrow}是完全集\<br>
&amp;又同时只含{\oplus，\vee}的集合，无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = ,即此时无法表示\neg\<br>
&amp;只含{\vee,\leftrightarrow} 的集合，无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;即任意去掉一个后均不能构成完全集，故该集合为极小完全集\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/16.png" alt></p>
<h2><span id="text14">$\text{1.4}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/17.png" alt><br>
$$<br>
\begin{align}<br>
&amp;1.{\wedge, \vee, \to ,\leftrightarrow}\<br>
&amp;该集合无法表示真值赋值v(A) = 0\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/1)),而v(\neg p) = 0,即此时无法表示\neg\<br>
&amp;故该集合不是完全集\<br>
&amp;2.{\wedge,\vee,\oplus}\<br>
&amp;该集合无法表示真值赋值v(A) = 1\<br>
&amp;(其中A为只含命题变元p而不含其他命题变元的公式，取v(p/0)),而v(\neg p) = 1,即此时无法表示\neg\<br>
&amp;故该集合不是完全集\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/18.png" alt></p>
<h2><span id="text15">$\text{1.5}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/19.png" alt><br>
$$<br>
\begin{align}<br>
1.\<br>
&amp;{\uparrow}是完全集\<br>
&amp;首先我们知道{\neg,\wedge}是完全集\<br>
&amp;且有\neg p \iff p \uparrow p\<br>
&amp;p \wedge q\iff \neg(p \uparrow q)\iff(p \uparrow q)\uparrow(p \uparrow q)\<br>
&amp;故即证该集合为完全集\<br>
2.\<br>
&amp;{\downarrow}是完全集\<br>
&amp;首先我们知道{\neg,\vee}是完全集\<br>
&amp;且有\neg p \iff p \downarrow p\<br>
&amp;p \vee q\iff \neg(p \downarrow q)\iff(p \downarrow q)\downarrow(p \downarrow q)\<br>
&amp;故即证该集合为完全集\<br>
3.\<br>
&amp;{\Delta}为完全集\<br>
&amp;首先若有0 \Delta 0 = 0,或者1 \Delta 1 = 1\<br>
&amp;即0 \Delta 0 = 1,且1 \Delta 1 =0\<br>
&amp;那么\Delta无法表示\neg \<br>
&amp;又类似{\oplus,\leftrightarrow},若1\Delta0\neq 0\Delta 1\<br>
&amp;则仅含p,q两个命题变元而不含其他命题变元的公式A的真值情况中1的个数一定是偶数个\<br>
&amp;故该集合无法表示\wedge,\vee\<br>
&amp;于是\<br>
&amp;若1\Delta0=0\Delta1=0,则此时\Delta 即为\downarrow\<br>
&amp;若1\Delta0=0\Delta1=1,故此时\Delta即为\uparrow\<br>
&amp;综上即可得证<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/20.png" alt></p>
<h2><span id="text16">$\text{1.6}$</span></h2>
<img src="/2023/05/04/%E7%A6%BB%E6%95%A31/Pictures\Screenshots\image-20230416203036176.png" width="800" height="200" alt="图片名称" align="left">
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve_formula</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">"False"</span><span class="token punctuation">}</span>

    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>

    has_true <span class="token operator">=</span> <span class="token boolean">False</span>
    has_false <span class="token operator">=</span> <span class="token boolean">False</span>
    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>
        const_exp <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> variables<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">if</span> x <span class="token keyword">in</span> variables <span class="token keyword">else</span> x<span class="token punctuation">,</span> tokens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            has_true <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            has_false <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">if</span> <span class="token keyword">not</span> has_false<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'永真式'</span>
    <span class="token keyword">elif</span> <span class="token keyword">not</span> has_true<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'永假式'</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'可满足式'</span>

s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入一个合式公式，命题变元最多有p,q,r三个，仅包含与、或、非三种运算，用and,or,not来表示: "</span><span class="token punctuation">)</span>
result <span class="token operator">=</span> solve_formula<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/21.png" alt></p>
<h1><span id="第三次作业">第三次作业</span></h1>
<h2><span id="draft">draft</span></h2>
<p>$$<br>
\begin{align}<br>
&amp;p \lfa q\<br>
\iff&amp;(p\to q)\w(q\to p)\<br>
\iff&amp;(\n p \v q)\w(\n q \v  p)\<br>
\iff&amp;((\n p \v q) \w \n q)\v((\n p  \v q) \w p)\<br>
\iff&amp;(\n p\w \n q)\v(q \w \n q)\v (\n p \w p)\v(q\w p)\<br>
\iff&amp;(p\w q)\v(\n p\w \n q)\<br>
&amp;( p\v q\v r)\w( p\v q\v\n r)\w( p\v\n q\v r)\w( p\v\n q\v\n r)\<br>
&amp;\w( p\v q\v r)\w(\n p\v q\v\n r)\w(\n p\v\n q\v r)\w(\n p\v\n q\v\n r)\<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/22.png" alt></p>
<h2><span id="text11">$\text{1.1}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/23.png" alt><br>
$$<br>
\begin{align}<br>
&amp;析取范式:\<br>
&amp;p,p\vee q,p\wedge \neg r,p\vee \neg p;\<br>
&amp;合取范式:\<br>
&amp;p,(p\vee q)\wedge r,p\wedge \neg r.p\vee \neg p;<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/24.png" alt></p>
<p>$p \vee q也是合取范式$</p>
<h2><span id="text12">$\text{1.2}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/25.png" alt></p>
<p>$$<br>
\begin{align}<br>
&amp;1.析取范式有:\<br>
&amp;(1),(2),(3),(5)\<br>
&amp;2.合取范式有:\<br>
&amp;(1),(2),(4)\<br>
&amp;3.主析取范式有:\<br>
&amp;(1),(5)\<br>
&amp;4.主合取范式有:\<br>
&amp;(1)<br>
\end{align}<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/26.png" alt></p>
<h2><span id="text13">$\text{1.3}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/27.png" alt></p>
<p>$$<br>
\begin{align}<br>
(1)&amp;\neg p \wedge q \to r\<br>
\iff&amp;\neg(\neg p \wedge q)\vee r\<br>
\iff&amp;p\vee \neg q\vee r\<br>
&amp;可知主合取范式为:p\vee \neg q\vee r\<br>
&amp;主析取范式为:(\neg p\wedge\neg q\wedge\neg r )\vee(\neg p\wedge\neg q\wedge r )\vee(\neg p\wedge q\wedge r )\vee( p\wedge\neg q\wedge\neg r )\<br>
&amp;\vee( p\wedge\neg q\wedge r )\vee( p\wedge q\wedge\neg r )\vee(p\wedge q\wedge r)\<br>
&amp;且该合式公式为可满足式\<br>
(2)&amp;(p\to q)\to r\<br>
\iff&amp;\neg(\neg p \vee q)\vee r\<br>
\iff&amp;(p\wedge q)\vee r\<br>
\iff&amp;(p\vee r)\wedge(q\vee r)\<br>
\iff&amp;(p\wedge(q\vee \neg q)\vee r)\wedge((p\vee \neg p)\wedge q\vee r)\<br>
\iff&amp;(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>
&amp;可知主合取范式为:(p\vee q\vee r)\wedge(p \vee \neg q \vee r)\wedge (\neg p \vee q\vee r)\<br>
&amp;主析取范式为:(\neg p \wedge \neg q \wedge r)\vee(\neg p \wedge q\wedge r)\vee(p \wedge \neg q \wedge r)\vee(p\wedge q\wedge \neg r)\v(p\w q\w r)\<br>
&amp;且该合式公式为可满足式\<br>
(3)&amp;\n p\v \n q\to (p\lfa \n q)\<br>
\iff&amp;\n (\n p \v \n q)\v (p \w \n q)\v(\n p \w q)\<br>
\iff&amp;(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>
&amp;可知主析取范式为:(p \w q)\v (p \w \n q)\v(\n p \w q)\<br>
&amp;主合取范式:p\v q\<br>
&amp;且该合式公式为可满足式\<br>
(4)&amp;p\v(p\to q\v(\n q \to r))\<br>
\iff&amp;p \v(\n p \v q\v (\n(\n q)\v r))\<br>
\iff&amp;p \v(\n p \v q\v q\v r)\<br>
\iff&amp;1\<br>
&amp;可知主合取范式为:1\<br>
&amp;主析取范式为:(\n p\w\n q\w\n r)\v(\n p \w \n q \w r)\v(\n p \w q \w \n r)\v(\n p\w q\w r)\<br>
&amp;\v(p\w \n q \w \n r)\v(p\w \n q \w  r)\v(p\w q\w \n r)\v(p\w q\w r)\<br>
&amp;且该合式公式为永真式\<br>
(5)&amp;(p\to q \w r)\w(\n p\to \n q\w \n r)\<br>
\iff&amp;(\n p\v(q\w r))\w(\n(\n p)\v(\n q\w \n r))\<br>
\iff&amp;(\n p \v q)\w(\n p \v r)\w(p\v \n q)\w(p\v \n r)\<br>
\iff&amp;((\n p \v q)\v(r\w \n r))\w(\n p \v(q\w \n q)\v r)\w((p\v \n q)\v(r\w \n r))\w(p\v(q\w \n q)\v \n r)\<br>
\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v q\v r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\<br>
&amp;\w(p\v \n q\v\n r)\w(p\v q\v \n r)\w(p\v \n q\v \n r)\<br>
\iff&amp;(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>
&amp;可知主合取范式为:(\n p \v q\v r)\w(\n p\v q\v \n r)\w(\n p\v\n q\v r)\w(p\v\n q\v r)\w(p\v \n q\v\n r)\w(p\v q\v \n r)\<br>
&amp;主析取范式为:(p \w q \w r)\v(\n p\w \n q\w \n r)\<br>
&amp;且该合式公式为可满足式\<br>
(6)&amp;p\w q\w (\n p\v \n q)\<br>
\iff&amp;(p\w q\w \n p)\v(p\w q\w \n q)\<br>
\iff&amp;0\<br>
&amp;可知主析取范式为:0\<br>
&amp;主合取范式为:(p\v q)\w(p\v\n q)\w(\n p\v q)\w(\n p\v\n q)\<br>
&amp;且该合式公式为永假式\<br>
\end{align}<br>
$$</p>
<h2><span id="text14">$\text{1.4}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/34.png" alt></p>
<p>有，<code>p</code>既是关于<code>p</code>的主析取范式，又是关于<code>p</code>的主合取范式</p>
<h2><span id="text15">$\text{1.5}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/28.png" alt><br>
$$<br>
Q\v R,\n Q\vDash R<br>
$$</p>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/29.png" alt></p>
<h2><span id="text16">$\text{1.6}$</span></h2>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/30.png" alt></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">terms</span><span class="token punctuation">(</span>exp<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    variables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    var_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    operations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">}</span>

    exp <span class="token operator">=</span> <span class="token string">' ( '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    exp <span class="token operator">=</span> <span class="token string">' ) '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    tokens <span class="token operator">=</span> exp<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
        <span class="token keyword">if</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> operations <span class="token keyword">and</span> t <span class="token keyword">not</span> <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            variables<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>
            var_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>

    cnt_true <span class="token operator">=</span> <span class="token number">0</span>
    cnt_false <span class="token operator">=</span> <span class="token number">0</span>
    lim <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>lim<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>var_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'True'</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                variables<span class="token punctuation">[</span>var_list<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'False'</span>
        const_exp <span class="token operator">=</span> exp
        <span class="token keyword">for</span> v <span class="token keyword">in</span> variables<span class="token punctuation">:</span>
            const_exp <span class="token operator">=</span> const_exp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>v<span class="token punctuation">,</span> variables<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">eval</span><span class="token punctuation">(</span>const_exp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            cnt_true <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            cnt_false <span class="token operator">+=</span> <span class="token number">1</span>
            
    <span class="token keyword">return</span> cnt_false


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>terms<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/05/04/%E7%A6%BB%E6%95%A31/31.png" alt></p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>离散1</tag>
      </tags>
  </entry>
  <entry>
    <title>高代期末</title>
    <url>/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/</url>
    <content><![CDATA[<h1><span id="线代期末串讲">线代期末串讲</span></h1>
<blockquote>
<p><a href="https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C">https://bhpan.buaa.edu.cn/link/AA8158DA29E46E4B62A400D7DA65647D7C</a><br>
文件夹名：高代期末串讲<br>
有效期限：永久有效</p>
</blockquote>
<p>资料如上</p>
<span id="more"></span>
<blockquote>
<p>2023 12.31 <a href="hugohealthy.top">胡健</a></p>
</blockquote>
<p>线性代数这门课程的切入点有很多，这里从知识层面上划分出来了线性方程组和向量组，线性空间，矩阵与行列式这三大部分。同时，会讲到几个重要的定理和公式。</p>
<h2><span id="线性方程组和向量组">线性方程组和向量组</span></h2>
<ul>
<li>线性方程组</li>
</ul>
<p>齐次解和非齐次解的讨论<br>
$$<br>
AX=O\<br>
AX=\beta<br>
$$<br>
齐次：有唯一解，有无穷多组解</p>
<p>非齐次：无解，有唯一解，有无穷多组解<br>
$$<br>
有解\iff r(A)=r(A|\beta)<br>
$$<br>
<strong>可拓展到矩阵方程的解的情况</strong></p>
<p>通解问题<br>
$$<br>
\begin{align}<br>
&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p\<br>
&amp;X=t_1\varepsilon_1+\dots t_p\varepsilon_p + X_1<br>
\end{align}<br>
$$</p>
<ul>
<li>向量组</li>
</ul>
<p>(列向量组)<br>
$$<br>
\alpha_i\in R^n,{\alpha_1\dots \alpha_p}<br>
$$<br>
线性相关与线性无关的含义<br>
$$<br>
\begin{align}<br>
&amp;存在不全为0的k_1\dots k_p,k_1\alpha_1 +\dots k_p\alpha_p = 0\Rightarrow线性相关\<br>
&amp;k_1\alpha_1 +\dots k_p\alpha_p = 0\rightarrow k_1\dots k_p = 0\Rightarrow线性无关<br>
\end{align}<br>
$$</p>
<ul>
<li>极大线性无关与秩</li>
</ul>
<p>极大线性无关组指的是：<br>
$$<br>
\alpha_1\dots\alpha_m线性无关，且加上向量组中任一向量\alpha后线性相关<br>
$$<br>
向量组的秩的含义是极大线性无关组中向量的个数</p>
<ul>
<li>向量组的等价</li>
</ul>
<p>一个向量组A中的每一个向量可以用另一个向量组B来线性表示，称向量组A能由向量组B线性表示</p>
<p>向量组的等价指的是可以相互线性表示</p>
<ul>
<li>
<p>向量组的一些性质</p>
</li>
<li>
<p>相关的线性表示（及其逆，单边法则）</p>
</li>
</ul>
<blockquote>
<p>由线性相关的定义可推出，其中某个向量可以由其余向量线性表示，这又可推出其中的某个向量可以写成前面的向量的线性组合。<br>
所以我们逆过来看，线性无关，等价于<br>
$每一个向量都不可由前面的向量表示（\alpha_i = 0） $<br>
这我们叫做单边法则</p>
</blockquote>
<ul>
<li>大数法则/不大法则</li>
</ul>
<blockquote>
<p>我们先来看，一个向量组被另一个向量组表示被表示的意义。<br>
$S_1组被S_2组表示\Leftrightarrow \forall \alpha_i \in S_1 , \alpha_i 可以被 \beta_j \in S_2 表示 $<br>
大的向量组可以被小的向量组表示，大组必相关<br>
（逆否命题：若A组无关，但可以被B组表示，则A比B小 ——不大法则）<br>
为啥可以被表示，我们可以理解了后面的秩再来说，是不是说AX=B有解啊。</p>
</blockquote>
<ul>
<li>表示的传递性</li>
</ul>
<blockquote>
<p>$我们说S_2 能被S_1表示，S_1能被S_0表示，则S_2能被S_0表示$</p>
</blockquote>
<ul>
<li>唯一表示法则</li>
</ul>
<blockquote>
<p>${\alpha_1,……,\alpha_n}无关,{\alpha_1,……,\alpha_n,\beta}相关，则\beta 由{\alpha_1,……,\alpha_n}唯一表示 $</p>
</blockquote>
<ul>
<li>子组相关法则</li>
</ul>
<blockquote>
<p>子组相关，全组必定相关<br>
proof:<br>
$k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p = 0 (k_1,……,k_p不全为零) $<br>
$\therefore k_1\alpha_1 + k_2\alpha_2 +……+k_p\alpha_p + 0\alpha_{p+1} + …… + 0\alpha_n  = 0$</p>
</blockquote>
<ul>
<li>等数法则</li>
</ul>
<blockquote>
<p>${\alpha_1,……\alpha_p},{\beta_1,……\beta_q}两组无关，且能相互表示，则p=q $<br>
由不大法则可证</p>
</blockquote>
<ul>
<li>长短法则</li>
</ul>
<blockquote>
<p>长相关则短相关，短无关则长无关<br>
看具体怎么理解了，有的老师说“如果矩阵A的子矩阵A0的各行（列）线性无关，则由A0的这些行（列）扩充得到的A的行（列）线性无关。”<br>
这是从大到小，从矩阵看问题<br>
也可以这么理解（从小到大，从向量组）</p>
</blockquote>
<ul>
<li>行变再行变，列的关系不改变</li>
</ul>
<h2><span id="空间解空间内积空间">空间(解空间，内积空间)</span></h2>
<p>解空间(初次接触)</p>
<p>张成空间(你已经会很多了)</p>
<p>欧式空间(你会的差不多了)</p>
<p>线性空间(你会了！！)</p>
<ul>
<li>定义</li>
</ul>
<p>满足八条性质，其实就是满足封闭性和线性性</p>
<ul>
<li>生成空间的定义</li>
</ul>
<p>由向量组表示的所有向量的集合<br>
$$<br>
\begin{align}<br>
&amp;\alpha_1\dots\alpha_m\<br>
&amp;L={\lambda_1\alpha_1 \dots \lambda_m\alpha_m|\lambda_1\dots\lambda_m\in R}<br>
\end{align}<br>
$$</p>
<ul>
<li>解空间的理解</li>
</ul>
<p>定义：n元齐次线性方程组的解集是n维向量空间$F^n$的非空子集(易证满足封闭性和线性性)</p>
<p>生成空间角度：基础解的张成空间</p>
<p>矩阵内积的理解：<br>
$$<br>
(\alpha_1,\dots,\alpha_m)<br>
\begin{pmatrix}<br>
x_1\<br>
\vdots\<br>
x_m<br>
\end{pmatrix}\<br>
AX<br>
$$</p>
<blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230223324226.png" alt></p>
</blockquote>
<ul>
<li>空间的交与和（还有<strong>直和</strong>和<strong>并</strong>，应该不考）</li>
</ul>
<p>how to solve？</p>
<p>$V_1:\alpha_1\dots \alpha_p,V_2:\beta_1\dots\beta_q$</p>
<p>空间的交：<br>
$$<br>
\begin{align}<br>
&amp;\gamma = s_1\alpha_1+\dots s_p\alpha_p = t_1\beta_1+\dots t_q\beta_q\<br>
&amp;解出来后得到s_1\dots s_p\<br>
&amp;带入后易得<br>
\end{align}<br>
$$<br>
空间的和：<br>
$$<br>
\begin{align}<br>
&amp;{\alpha_1\dots\alpha_p,\beta_1\dots\beta_q}这个向量组的极大线性无关组\<br>
&amp;和空间的维数即为极大线性无关组的秩<br>
\end{align}<br>
$$<br>
维数公式<br>
$$<br>
\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim (W_1\cap W_2)<br>
$$<br>
其中$W_1+W_2={w_1+w_2:w_1\in W_1,w_2\in W_2}$</p>
<ul>
<li>内积与Gram矩阵</li>
</ul>
<p>$$<br>
\begin{align}<br>
&amp;A={\alpha_1\dots\alpha_n}\<br>
&amp;Gram=<br>
\begin{pmatrix}<br>
(\alpha_1,\alpha_1)&amp;\dots &amp;(\alpha_1,\alpha_n)\<br>
\vdots &amp;  &amp;\vdots\<br>
(\alpha_n,\alpha_1) &amp;\dots &amp;(\alpha_n,\alpha_n)<br>
\end{pmatrix}\<br>
&amp;Gram=A^TA<br>
\end{align}<br>
$$</p>
<p>定义预正交阵和正交阵</p>
<p>预正交阵：列向量两两正交</p>
<p>正交阵：两向量两两正交且每个列向量的模为1</p>
<p>度量阵：由基向量产生的Gram矩阵，特殊情况下是单位阵</p>
<p>二次型<br>
$$<br>
\begin{align}<br>
&amp;f=\sum_{i=1}^n\sum_{j=1}^na_{ij}x_ix_j\<br>
&amp;二次型对应的矩阵为：\<br>
&amp;\begin{pmatrix}<br>
a_{11}&amp;\dots &amp;a_{1n}\<br>
\vdots &amp;  &amp;\vdots\<br>
a_{n1} &amp;\dots &amp;a_{nn}<br>
\end{pmatrix}\<br>
&amp;a_{ij}=a_{ji}<br>
\end{align}<br>
$$</p>
<ul>
<li>线性映射和线性变换</li>
</ul>
<p>线性映射：$R^n\rightarrow R^m$</p>
<p>线性变换：$R^n\rightarrow R^n$</p>
<blockquote>
<p>这个概念挺抽象的</p>
<p>不同书定义也不一样(点名批评同济大学的紫书)</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231230234949295.png" alt></p>
<p>这里以《矩阵论》上面的定义为准</p>
</blockquote>
<ul>
<li>
<p>过渡矩阵与坐标变换公式</p>
<p>若两组基$ S=\begin{bmatrix}{\varepsilon_1,\cdots,\varepsilon_n}\end{bmatrix}, T=\begin{bmatrix}{\eta_1,\dots,\eta_n}\end{bmatrix}$满足基变换公式$ T= S P$，则称$ P$是从$\S$到$ T$的过渡矩阵。</p>
<p>设向量$\alpha$在$ S, T$下的坐标分别为$ X, Y$，则满足坐标变换公式$ X= P Y$。</p>
</li>
<li>
<p>线性变换矩阵</p>
<p>对于一组基$\xi_1,\dots,\xi_n$，若存在矩阵$A$使得线性变换$\sigma$满足$\sigma(\xi_1,\dots,\xi_n)=(\xi_1,\dots,\xi_n) A$，则称矩阵$ A$为线性变换$\sigma$在基$\xi_1,\dots,\xi_n$下所对应的矩阵。</p>
<p>若线性空间$V$的线性变换$\sigma$在两组基$\xi_1,\dots,\xi_n$以及$\eta_1,\dots,\eta_n$下对应的矩阵分别为$ A, B$，$\xi_1,\dots,\xi_n$到$\eta_1,\dots,\eta_n$的过渡矩阵为$ P$，则有$ B= P^{-1} A P$。</p>
</li>
</ul>
<blockquote>
<p>虽然这个也有点抽象，但是整理了一下也就这几个公式</p>
<p>理解不了就记住吧</p>
</blockquote>
<h2><span id="矩阵与行列式">矩阵与行列式</span></h2>
<ul>
<li>矩阵的可逆与正交</li>
</ul>
<p>$$<br>
\begin{align}<br>
&amp;A=A_{n\times n}\<br>
&amp;r(A)=n\<br>
\iff&amp;行满秩\<br>
\iff&amp;列满秩\<br>
\iff&amp;A^{-1}存在\<br>
\iff&amp;|A|\ne 0\<br>
\iff&amp;\lambda_i\ne 0|A|=\lambda_1\dots\lambda_n\<br>
\end{align}<br>
$$</p>
<p>正交：$A^T=A^{-1}$或者$A^TA^{-1}=A^{-1}A^T=I_n$</p>
<ul>
<li>矩阵的秩</li>
</ul>
<p>行秩：行向量组的秩</p>
<p>列秩：列向量组的秩</p>
<p>阶梯秩：化为阶梯阵后非零行的个数</p>
<p>古典秩：存在k阶子式的行列式不为0，任意k+1阶子式的行列式都为0</p>
<blockquote>
<p>这四个是等价的</p>
</blockquote>
<ul>
<li>行列式的计算</li>
</ul>
<blockquote>
<p>这个我感觉高阶的也不会让你算</p>
<p>低阶的直接爆算或者化为上三角行列式</p>
</blockquote>
<p>范德蒙德行列式</p>
<p><strong>下降公式/换位公式</strong></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5C3%E6%8D%A2%E4%BD%8D%E5%85%AC%E5%BC%8F%E4%BE%8B%E9%A2%98.png" alt="换位公式例题"></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004939668.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231004927501.png" alt></p>
<ul>
<li>相伴秩公式</li>
</ul>
<p>$$<br>
A=A_{n\times n}\<br>
A^*=<br>
\begin{pmatrix}<br>
A_{11} &amp;A_{21}&amp;\dots &amp;A_{n1}\<br>
\vdots &amp;&amp;&amp;\vdots\<br>
A_{1n} &amp;A_{2n}&amp;\dots &amp;A_{nn}<br>
\end{pmatrix}<br>
$$</p>
<p>注意这里还转置了一下</p>
<p>$AA^*=|A|I_n$</p>
<p>可得$|A^*| = |A|^{n-1}$</p>
<p>和伴随矩阵有关的秩的公式<br>
$$<br>
r(A^*) =<br>
\begin{cases}<br>
n,r(A) = n\<br>
1,r(A)=n-1\<br>
0,else<br>
\end{cases}<br>
$$</p>
<blockquote>
<p>proof:由古典秩的含义</p>
<p>第二个用到$AA^<em>=O 有r(A)+r(A^</em>) \le n $</p>
<p>且$r(A^*) \ge 1$</p>
</blockquote>
<h2><span id="特征值与二次型">特征值与二次型</span></h2>
<ul>
<li>根的遗传公式</li>
</ul>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010720537.png" alt></p>
<blockquote>
<p>零化式</p>
</blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231010812719.png" alt></p>
<blockquote>
<p>theory</p>
</blockquote>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011008818.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011031258.png" alt></p>
<ul>
<li>Cayley定理</li>
</ul>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011404990.png" alt></p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231011426721.png" alt></p>
<ul>
<li>许尔公式</li>
<li>相似对角化</li>
</ul>
<p>可对角化</p>
<ol>
<li>n阶矩阵A与对角阵相似（即A能对角化）的充分必要条件是A有n个线性无关的特征向量。</li>
<li>如果n阶矩阵A的n个特征值互不相等，则A与对角阵相似。</li>
<li>对称阵的特征值为实数</li>
<li>不同特征根的特征向量正交</li>
</ol>
<p>对称阵A对角化的步骤</p>
<ol>
<li>
<p>求出A的全部互不相等的特征值$\lambda_1,\dots \lambda_s$，它们的重数依次为$k_1,\dots k_s(k_1+\dots +k_s = n)$。</p>
</li>
<li>
<p>对每个$k_i$重特征值$\lambda_i$，求方程$(A-\lambda_i I)X=O$的基础解系，得$k_i$个线性无关的特征向量。再把它们<strong>正交化</strong>、单位化，得ki个两两正交的单位特征向量。因$k_1+\dots +k_s=n$，故总共可得n个两两正交的单位特征向量。</p>
</li>
</ol>
<p>$Schimidt$正交化方法</p>
<p>若有$n$个线性无关的向量$\alpha_1,\dots,\alpha_n$，则过程分为正交化和单位化</p>
<p>正交化过程<br>
$$<br>
\beta_k=\alpha_k-\sum_{i=1}^{k-1}\frac{(\beta_i,\alpha_k)}{(\beta_i,\beta_i)}\beta_i,\quad k=1,\dots,n<br>
$$<br>
单位化过程<br>
$$<br>
\eta_k=\frac{\beta_k}{||\beta_k||},\quad k=1,\dots,n<br>
$$<br>
从而得到一组单位正交向量$\eta_1\cdots,\eta_n$。</p>
<ol start="3">
<li>把这n个两两正交的单位特征向量构成正交阵P，便有$P^{-1}AP = P^TAP = Λ$。注意Λ中对角元的排列次序应与P中列向量的排列次序相对应。</li>
</ol>
<ul>
<li>实对称阵的性质</li>
</ul>
<p>实对称矩阵的正交相似对角化</p>
<p>（1）实对称矩阵的特征值均为实数；</p>
<p>（2）实对称矩阵对应不同特征值的特征向量相互正交；</p>
<p>（3）实对称矩阵必定可以相似对角化；</p>
<p>（4）若$ A$是$n$阶实对称矩阵，且特征值为$\lambda_1,\cdots,\lambda_n$，则存在正交矩阵$ Q$，使得<br>
$$<br>
Q^T A Q=\begin{bmatrix}\lambda_1&amp;&amp;\&amp;\ddots\&amp;&amp;\lambda_n\end{bmatrix}<br>
$$<br>
（5）若$ A$和$ B$均为$n$阶实对称矩阵，则$ A$和$ B$相似的充要条件是$ A$和$ B$有相同的特征值。</p>
<ul>
<li>二次型与六二条件</li>
</ul>
<p>正定矩阵：</p>
<p>（1）$ A$所有特征值均为正;</p>
<p>（2）$ A$正惯性指数为$n$；</p>
<p>（3）$ A$与单位阵合同；</p>
<p>（4）$ A$的各阶顺序主子式大于零；</p>
<p>（5）存在可逆矩阵$ P$使得$ A= P^T P$。</p>
<p>（6）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&gt;0$</p>
<p>负定矩阵：</p>
<p>（1）若对任意$n$维维非零向量$ \alpha$均有$\alpha^T A\alpha&lt;0$</p>
<p>（2）$ A$的奇数阶主子式为负，偶数阶主子式为正；</p>
<ul>
<li>双合同定理</li>
</ul>
<p>若$A,B$同阶实对称，其中一个为正定，可设$A$正定，存在可逆$W$,$W^TAW=I_n，W^TBW=diag(d_1,\dots,d_n)$,即$W^TAW,W^TBW$都为对角形</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231015741579.png" alt="image-20231231015741579"></p>
<p><a href="https://zhuanlan.zhihu.com/p/376561675">more</a></p>
<h2><span id="一些典型的整理">一些典型的整理</span></h2>
<ul>
<li>秩公式</li>
</ul>
<p>阶梯阵概念，及其与向量组秩的联系。</p>
<blockquote>
<p>矩阵就是向量组拼起来的，所以矩阵的秩就是向量组的秩。<br>
我们在线性方程组的矩阵消元法中见识过，我们把一个矩阵变成阶梯状，我们考虑一下，变成阶梯状以后，后面的向量前缀都是零，所以不可能可以表示前面的向量，所以很简单，阶梯有多少阶，就会有多少秩。<br>
那么到底是行向量的秩还是列向量的秩呢，不用纠结我们通过阶梯可以看出，行向量的秩就是列向量的秩。<br>
所以三种同解变形，其实就代表着三种初等变换。</p>
</blockquote>
<p>秩一阵</p>
<blockquote>
<p>我们来看一个矩阵，秩一阵，可分解为两个向量之间的乘积。</p>
</blockquote>
<p>我们在最后再来谈秩的各种公式的关系</p>
<blockquote>
<ul>
<li>满秩则有唯一解<br>
$proof: \because r(A) = n $<br>
$\therefore {\alpha_1,……,\alpha_n}可作为一组基 $<br>
$\therefore \forall \beta \in R^n 都会存在\beta 的坐标(x_1,……,x_n) $<br>
$坐标即为唯一解 $</li>
<li>满秩则可逆<br>
$proof: 由上可知：AX_1 = \varepsilon_1, AX_2 = \varepsilon_2,……,AX_n = \varepsilon_n 都有解$<br>
$所以AA^{-1} = I可解出A^{-1} = (X_1,X_2,……,X_n) $</li>
</ul>
</blockquote>
<p>所以说到这就只需要明确一个事情，满秩，行向量组列向量组无关，行列式不等于0，可逆，只有唯一解，非奇异这都是等价的概念</p>
<blockquote>
<p>分块秩公式</p>
</blockquote>
<p>$$<br>
r\begin{pmatrix}<br>
A &amp;O\<br>
O &amp;B<br>
\end{pmatrix}=r(A)+a(B)\<br>
r\begin{pmatrix}<br>
O &amp;B\<br>
A &amp;O<br>
\end{pmatrix}=r(A)+a(B)\<br>
r\begin{pmatrix}<br>
A &amp;C\<br>
O &amp;B<br>
\end{pmatrix}\ge r(A)+a(B)\<br>
$$</p>
<blockquote>
<p>乘积不增秩公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;r(AB)\le r(A),r(B)\<br>
&amp;A=A_{m\times n} = (\alpha_1,\dots,\alpha_n),B=B_{n\times p} = (\beta_1,\dots,\beta_p)\<br>
&amp;AB=(A\beta_1,\dots,A\beta_p)\<br>
&amp;A\beta_i=\alpha_1b_1+\dots+\alpha_nb_n,\beta_i=\begin{pmatrix}<br>
b_1\b_2\\vdots\b_n<br>
\end{pmatrix}\<br>
&amp;AB可以被{\alpha_1,\dots,\alpha_n}表示<br>
\end{align}<br>
$$</p>
<blockquote>
<p>积0公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;AB=O\<br>
&amp;r(A)+r(B)\le n<br>
\end{align}<br>
$$</p>
<blockquote>
<p>转置积秩公式</p>
</blockquote>
<p>$$<br>
r(A)+r(B)\le r(AB)+n<br>
$$</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/image-20231231021249979.png" alt></p>
<blockquote>
<p>加减秩公式</p>
</blockquote>
<p>$$<br>
\begin{align}<br>
&amp;r(A+B)\le r(A)+r(B)\<br>
&amp;r(A-B)\le r(A)+r(B)\<br>
&amp;r(A+B)=r(A|B)r\begin{pmatrix}I_n\I_n\end{pmatrix}\le r(A|B)\le r(A)+r(B)<br>
\end{align}<br>
$$</p>
<ul>
<li>可逆的等价表示</li>
</ul>
<ol>
<li>
<p>$A$的行列式不等于0</p>
</li>
<li>
<p>$A$的秩等于$n$，即$A$为满秩矩阵</p>
</li>
<li>
<p>$A$的行（列）向量组线性无关</p>
</li>
<li>
<p>齐次方程组$Ax=0$只有零解</p>
</li>
<li>
<p>对于任意$b$属于$R^n$(表示向量空间)，Ax=b总有唯一解</p>
</li>
<li>
<p>A与单位矩阵等价</p>
</li>
<li>
<p>A可表示成若干个初等矩阵的乘积</p>
</li>
<li>
<p>A的列向量可以作为n维向量空间$R^n$的一组基</p>
</li>
<li>
<p>$R^n$中任意一个向量都可以由$A$的列向量线性表出</p>
</li>
<li>
<p>$A$的特征值全不为0</p>
</li>
<li>
<p>$A^TA$是正定矩阵</p>
</li>
<li>
<p>$A$是非奇异的</p>
</li>
</ol>
<ul>
<li>求逆的方法学</li>
</ul>
<p>初等变换（常用且方便）</p>
<p>伴随矩阵法</p>
<p>分块矩阵法</p>
<p><img src="/2023/12/31/%E9%AB%98%E4%BB%A3%E6%9C%9F%E6%9C%AB/E:%5CPictures%5Ctypora%5Cimage-20231231021933921.png" alt="image-20231231021933921"></p>
<p>零化式法</p>
<ul>
<li>下降公式</li>
</ul>
]]></content>
      <categories>
        <category>高等代数</category>
      </categories>
      <tags>
        <tag>高代</tag>
      </tags>
  </entry>
  <entry>
    <title>高数应用</title>
    <url>/2022/10/23/%E9%AB%98%E6%95%B0%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<div align="center"><font size="24" face="宋体">高等数学不等式问题探讨</font></div>
<span id="more"></span>
<div align="center"><font size="6" face="仿宋">hugo</font></div>
<p>​				<font size="4.5" face="楷体">[<b>摘要</b>]</font>:本文将介绍大学高等数学中遇到的相关不等式问题，介绍一些著名的不等式，如算术几何平均不等式、$\text{Bernoulli}$不等式、$\text{Jensen}$不等式、$\text{Cauchy}$不等式、$\text{Young}$不等式、$\text{Holder}$不等式、$\text{Minkowski}$不等式，以及在遇到不等式问题的常用处理办法，利用构造函数，求导分析单调性等方法，最后再结合一些例题进行具体分析讨论。</p>
<p>​				<font size="4.5" face="楷体">[<b>关键词</b>]</font>:算术几何平均不等式；$\text{Jensen}$不等式；$\text{Cauchy}$不等式；$\text{Young}$不等式；$\text{Bernoulli}$不等式；$\text{Holder}$不等式；$\text{Minkowski}$不等式；构造函数；变上限积分</p>
<h1><span id="1-引言">1   引言</span></h1>
<p>​	在第五届全国大学生数学竞赛非数学类决赛第三题是一道与常微分方程有关的不等式问题：<br>
$$<br>
设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\</p>
<p>f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\</p>
<p>试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>
$$<br>
​	在第八届全国大学生数学竞赛非数学类决赛第二题是一道不等式的综合问题：<br>
$$<br>
设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>
$$<br>
​	在第八届全国大学生数学竞赛非数学类初赛第二题是一道构造变上限积分的题目：<br>
$$<br>
设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\<br>
有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>
$$<br>
​	在第十届全国大学生数学竞赛非数学类第三题是一道典型的运用到了积分形式的$Cauchy$不等式的题目：<br>
$$<br>
设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>
1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>
$$<br>
​	可以看到不等式问题在考试中的考察还是比较多的，特别是近年有增多的趋势，其次在课后练习及相关研究中，不等式问题具有其独特的数学魅力。不等式问题是许多证明题的重要内容，涵盖的知识点丰富，有许多重要的不等式，这些经典的不等式的处理方法多种多样，在这里我将介绍其中个别方法，并对其在n维度量空间的推广加以介绍。同时将就大学高等数学中出现的不等式问题常用到的方法进行分析，如在导数部分常常用到的构造函数求导分析单调性，在积分部分通过构造变上限积分来证明不等式的问题，同时部分不等式证明题还可以用到$\text{Taylor}$展开、微分中值定理和积分中值定理进行证明。</p>
<h1><span id="2-几个重要不等式">2   几个重要不等式</span></h1>
<h4><span id="算术几何平均不等式">算术几何平均不等式</span></h4>
<p>设$n\in N^*,a_i&gt;0(i=1,2,3\dots n)$,则有<br>
$$<br>
{n\over\frac1{a_1}+\frac1{a_2}+\dots +\frac1{a_n}}\le\sqrt[n]{a_1a_2\dots a_n}\le{a_1+a_2+\dots+a_n\over n}\le\sqrt{a_1^2+a_2^2+\dots+a_n^2\over n}\<br>
$$<br>
当且仅当$a_1=a_2=\dots=a_n$时等号成立</p>
<p>**证明：**由归纳法易证</p>
<h4><span id="bernoulli不等式">Bernoulli不等式</span></h4>
<p>当$x\ge -1$时，有<br>
$$<br>
\begin{align}<br>
&amp;(1)若\alpha&gt;1,则有(1+x)^\alpha\ge1+\alpha x;\<br>
&amp;(2)若0&lt;\alpha&lt;1,则有(1+x)^\alpha\le1+\alpha x.<br>
\end{align}<br>
$$<br>
**证明：**构造函数求导分析单调性易证</p>
<h4><span id="jensen不等式">Jensen不等式</span></h4>
<p>设f(x)是区间$I$上的凸函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>
$$<br>
f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\le\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).\<br>
$$<br>
如果f(x)是区间I上的凹函数，则对任意的$x_1,x_2,\dots,x_n\in I$,以及满足条件$\lambda_1+\lambda_2+\dots+\lambda_n=1$的任意正数$\lambda_1,\lambda_2,\dots,\lambda_n$,成立<br>
$$<br>
f(\lambda_1x_1+\lambda_2x_2+\dots+\lambda_nx_n)\ge\lambda_1f(x_1)+\lambda_2f(x_2)+\dots+\lambda_nf(x_n).<br>
$$</p>
<p><strong>证明</strong>：由归纳法易证</p>
<h4><span id="young不等式">Young不等式</span></h4>
<p>设$a,b\ge0,p,q&gt;1,\frac1p+\frac1q=1$,则有<br>
$$<br>
ab\le\frac{a^p}p+\frac{b^q}q<br>
$$<br>
当且仅当$a^{\frac1q}=b^{\frac1p}$时等号成立</p>
<p><strong>证明：</strong></p>
<p>若$a=b=0$，则有不等式成立，否则不妨设$b&gt;0$。</p>
<p>考虑证明$\text{Young}$不等式的等价形式<br>
$$<br>
\begin{align}<br>
&amp;a^{\frac1p}b^{\frac1q}\le\frac ap+\frac bq\<br>
&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab\right)+1-\frac1p\<br>
&amp;\left(\frac ab\right)^{\frac1p}\le\frac1p\cdot\left(\frac ab -1\right)+1<br>
\end{align}<br>
$$<br>
作换元$x=\frac ab$，则等价于<br>
$$<br>
\left(x\right)^{\frac1p}\le\frac1p\cdot\left(x -1\right)+1<br>
$$<br>
构造函数，结合函数的上凸性易证</p>
<h5><span id="n度量空间的young不等式">n度量空间的Young不等式</span></h5>
<p>设$x_i\ge0,p_i\ge1(i=1,2,\dots,n),\sum_{i=1}^n\frac1{p_i}=1$,则有<br>
$$<br>
\prod_{i=1}^n\le\sum_{i=1}^n\frac{x_i^{p_i}}{p_i}<br>
$$<br>
当且仅当$\frac{x_1^{p_1}}{p_1}=\frac{x_2^{p_2}}{p_2}=\dots=\frac{x_n^{p_n}}{p_n}$时等式成立</p>
<p><strong>证明：</strong></p>
<p>与证明2度量空间的$\text{Young}$不等式的方法类似，只不过需要利用$n-1$维函数$f(x_1,x_2,\dots,x_{n-1})$的上凸性<br>
$$<br>
f(x_1,x_2,\dots,x_{n-1})=\prod_{i=1}^{n-1}x_i^{\frac1{p_i}}<br>
$$<br>
易证</p>
<h4><span id="cauchy不等式">Cauchy不等式</span></h4>
<p>设$a_i,b_i\in R,i=1,2,\dots,n$,有<br>
$$<br>
\left(\sum_{i=1}^na_ib_i\right)^2\le\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)<br>
$$<br>
当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立<br>
$$<br>
\frac{a_1}{b_1}=\frac{a_2}{b_2}=\dots=\frac{a_n}{b_n}<br>
$$</p>
<p><strong>证明：</strong><br>
法一:由归纳法易证<br>
法二:构造二次函数证明<br>
做二次函数<br>
$$<br>
\begin{align}<br>
f(x)&amp;=\left(\sum_{i=1}^na_i^2\right)x^2+2\left(\sum_{i=1}^na_ib_i\right)x+\left(\sum_{i=1}^nb_i^2\right)\<br>
&amp;=\sum_{i=1}^n(a_ix+b_i)^2\<br>
&amp;\ge0<br>
\end{align}<br>
$$<br>
由于<br>
$$<br>
\left(\sum_{i=1}^na_i^2\right)&gt;0<br>
$$<br>
则有<br>
$$<br>
\Delta=4\left(\sum_{i=1}^na_ib_i\right)^2-4\left(\sum_{i=1}^na_i^2\right)\left(\sum_{i=1}^nb_i^2\right)\le 0<br>
$$<br>
即证</p>
<h4><span id="holder不等式">Holder不等式</span></h4>
<p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q&gt;1,\frac1p+\frac1q=1$，则有<br>
$$<br>
\sum_{i=1}^na_ib_i\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
$$<br>
当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p>
<p>易见$\text{Cauchy}$不等式是$\text{Holder}$不等式的特例。</p>
<p><strong>证明：</strong></p>
<p>若$a_1=\dots=a_n=0$或$b_1=\dots=b_n=0$则显然结论成立，否则不妨设$a_1,b_1&gt;0$。</p>
<p>令<br>
$$<br>
t=\left(\sum_{i=1}^na_i^p\over\sum_{i=1}^nb_i^q\right)^{\frac1{pq}}<br>
$$<br>
于是有<br>
$$<br>
\begin{align}<br>
&amp;\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)=\frac1p\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}\<br>
&amp;\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)=\frac1q\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
\end{align}<br>
$$<br>
由$\text{Young}$不等式易知该不等式成立<br>
$$<br>
\begin{align}<br>
\sum_{i=1}^na_ib_i&amp;=\sum_{i=1}^n(t\cdot a_i)(\frac{b_i}t)\<br>
&amp;\le\frac{t^p}p\cdot\left(\sum_{i=1}^na_i^p\right)+\frac1{q\cdot t^q}\cdot\left(\sum_{i=1}^nb_i^q\right)<br>
\end{align}<br>
$$<br>
由$\text{Young}$不等式成立的条件易知该不等式成立的条件即为当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时。</p>
<p>即证</p>
<p>$\text{Holder}$不等式还可以做一个小推广</p>
<p>设$a_i,b_i\ge0,i=1,2,\dots,n,p,q,r&gt;1,\frac1p+\frac1q=\frac1r$，则有<br>
$$<br>
\left(\sum_{i=1}^na_ib_i\right)^{\frac1r}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}\left(\sum_{i=1}^nb_i^q\right)^{\frac1q}<br>
$$<br>
当且仅当向量$(a_1^p,a_2^p,\dots,a_n^p)$与向量$(b_1^q,b_2^q,\dots,b_n^q)$平行时等式成立。</p>
<p><strong>证明：</strong></p>
<p>考虑到$r&lt;p,r&lt;q,\frac rp+\frac rq=1$，然后应用$\text{Holder}$不等式即可得证。</p>
<h5><span id="n度量空间的holder不等式">n度量空间的Holder不等式</span></h5>
<p>设$x_{i,j}\ge0,r&gt;1,p_i&gt;1,\sum_{i=1}^n\frac1{p_i}=\frac1r$，其中$(1\le i\le n,1\le j\le m)$，则有<br>
$$<br>
\left(\sum_{j=1}^m\left(\prod_{i=1}^nx_{i,j}\right)^r\right)^{\frac1r}\le\prod_{i=1}^n\left(\sum_{j=1}^mx_{i,j}^{p_i}\right)^{\frac1{p_i}}<br>
$$<br>
定义一组向量$\vec {x_i}=(x_{i,1}^{p_i},x_{i,2}^{p_i},\dots,x_{i,m}^{p_i}),i=1,2,\dots,n$,当且仅当$\vec {x_i}$相互平行时等式成立。</p>
<p><strong>证明：</strong></p>
<p>用$\text{Holder}$不等式和归纳法进行证明即可。</p>
<h4><span id="minkowski不等式">Minkowski不等式</span></h4>
<p>设$a_i,b_i\ge0,p&gt;1$，则有<br>
$$<br>
\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1p}\le\left(\sum_{i=1}^na_i^p\right)^{\frac1p}+\left(\sum_{i=1}^nb_i^p\right)^{\frac1p}<br>
$$<br>
当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时等式成立</p>
<p><strong>证明：</strong></p>
<p>由$\text{Holder}$不等式有<br>
$$<br>
\begin{align}<br>
\left(\sum_{i=1}^n(a_i+b_i)^p\right)&amp;=\sum_{i=1}^n(a_i+b_i)^{p-1}a_i+\sum_{i=1}^n(a_i+b_i)^{p-1}b_i\<br>
&amp;\le\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum a_i^p\right)^{\frac1p}+\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\sum b_i^p\right)^{\frac1p}\<br>
&amp;=\left(\sum_{i=1}^n(a_i+b_i)^{q(p-1)}\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)\<br>
&amp;=\left(\sum_{i=1}^n(a_i+b_i)^p\right)^{\frac1q}\left(\left(\sum a_i^p\right)^{\frac1p}+\left(\sum b_i^p\right)^{\frac1p}\right)<br>
\end{align}<br>
$$<br>
由$\text{Holder}$不等式易知不等式的成立当且仅当向量$(a_1,a_2,\dots,a_n)$与向量$(b_1,b_2,\dots,b_n)$平行时。</p>
<p>即证。</p>
<h1><span id="3-不等式证明常用方法">3   不等式证明常用方法</span></h1>
<h3><span id="放缩法">放缩法</span></h3>
<p>如第五届全国大学生数学竞赛非数学类决赛第三题<br>
$$<br>
设当x&gt;-1时，可微函数f(x)满足条件\hspace{9cm}\<br>
f’(x)+f(x)-\frac1{1+x}\int_0^xf(t)dt=0且f(0)=1.\<br>
试证:当x\ge0时，有e^{-x}\le f(x)\le 1成立\hspace{8.3cm}<br>
$$<br>
<strong>解：</strong></p>
<p>在求导和利用分离变量法求得<br>
$$<br>
\begin{align}<br>
&amp;f’(x)=-\frac{e^{-x}}{1+x}\<br>
&amp;f’(x)&lt;0且f(0)=1\<br>
&amp;有f(x)\le1\<br>
&amp;另一方面\<br>
&amp;f(x)=f(0)-\int_0^x\frac{e^{-t}}{1+t}dt\ge1-\int_0^xe^{-t}dt=e^{-x}.<br>
\end{align}<br>
$$<br>
此题就是典型的利用放缩法求证不等式</p>
<h3><span id="求导法">求导法</span></h3>
<p>如第八届全国大学生数学竞赛非数学类决赛第二题<br>
$$<br>
设0&lt;x&lt;\frac\pi2,证明:\frac4{\pi^2}&lt;\frac1{x^2}-\frac1{\tan^2 x}&lt;\frac23.<br>
$$<br>
<strong>解：</strong><br>
$$<br>
\begin{align}<br>
&amp;f(x)=\frac1{x^2}-\frac1{\tan^2 x}\left(0&lt;x&lt;\frac\pi2\right),则\<br>
&amp;f’(x)={2(x^3\cos x-\sin^3x)\over x^3\sin^3x}\<br>
&amp;令g(x)={six\over \sqrt[3]{\cos x}}-x\left(0&lt;x&lt;\frac\pi2\right)\<br>
&amp;g’(x)=\frac23\cos^{\frac23}x+\frac13\cos^{-\frac43}x-1\<br>
&amp;结合均值不等式可得g’(x)&gt;0,又g(0)=0\<br>
&amp;则有g(x)&gt;0\<br>
&amp;故f’(x)&lt;0,从而f(x)单调递减\<br>
&amp;又\lim\limits_{x\rightarrow \frac\pi2-}=\frac4{\pi^2};\lim\limits_{x\rightarrow0+}=\frac23\<br>
&amp;故即可得证<br>
\end{align}<br>
$$</p>
<h3><span id="构造函数变上限积分">构造函数（变上限积分）</span></h3>
<p>如第八届全国大学生数学竞赛非数学类初赛第二题：<br>
$$<br>
设f(x)在[0,1]上可导，f(0)=0,且当x\in(0,1),0&lt;f’(x)&lt;1.试证:当a\in(0,1)时，\有\left(\int_0^af(x)dx\right)^2&gt;\int_0^af^3(x)dx.<br>
$$<br>
<strong>解：</strong></p>
<p>构造<br>
$$<br>
\begin{align}<br>
&amp;令F(x)=\left(\int_0^xf(t)dt\right)^2-\int_0^xf^3(t)dt\<br>
&amp;求导有，F’(x)=f(x)\left(2\int_0^xf(t)dt-f^2(x)\right)\<br>
&amp;令G(x)=2\int_0^xf(t)dt-f^2(x)\<br>
&amp;G’(x)=2f(x)(1-f’(x))\<br>
&amp;有G’(x)&gt;0,则G(x)单调递增\<br>
&amp;又G(0)=0,则G(x)&gt;0\<br>
&amp;有F’(X)&gt;0,则F(x)单调递增\<br>
&amp;又F(0)=0\<br>
&amp;即可得证<br>
\end{align}<br>
$$</p>
<h3><span id="利用重要不等式">利用重要不等式</span></h3>
<p>如第十届全国大学生数学竞赛非数学类第三题<br>
$$<br>
设f(x)在区间[0,1]上连续，且1\le f(x)\le3.证明:\hspace{7cm}\<br>
1\le \int_0^1f(x)dx\int_0^1\frac1{f(x)}dx\le\frac43.<br>
$$<br>
<strong>解：</strong></p>
<p>所证式子的左式由$\text{Cauchy}$不等式即证</p>
<p>右式由于由基本不等式（算术几何平均不等式的二阶形式）<br>
$$<br>
\begin{align}<br>
\int_0^1f(x)dx\int_0^1\frac3{f(x)}dx&amp;\le\frac14\left(\int_0^1f(x)dx+\int_0^1\frac3{f(x)}dx\right)^2\<br>
&amp;\le4<br>
\end{align}<br>
$$<br>
即证</p>
]]></content>
      <categories>
        <category>数学分析</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
</search>
